<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>knight</title>
  <subtitle>knight</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/lgrknight/lgrknight.github.io/"/>
  <updated>2018-01-22T03:44:43.018Z</updated>
  <id>https://github.com/lgrknight/lgrknight.github.io/</id>
  
  <author>
    <name>knight</name>
    <email>lgrknight@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL优化</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2018/01/22/SQL%E4%BC%98%E5%8C%96/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2018/01/22/SQL优化/</id>
    <published>2018-01-22T03:27:44.000Z</published>
    <updated>2018-01-22T03:44:43.018Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>知事故而不世故</p>
</blockquote>
<h3 id="优化指引"><a href="#优化指引" class="headerlink" title="优化指引"></a>优化指引</h3><ul>
<li>每个表都要在关键字段（频繁用于查询的字段）建立索引。<br>查询字段不用*号，写出具体的字段名；只查询出需要用到的字段，查询字段越少查询速度就会越快。</li>
<li>多表查询，尽量给每个表取别名，并在字段前加别名，减轻数据库用来解析每个字段归属表与歧义的时间。（经常有多个表有相同名的字段名）</li>
<li>数据库一般按照从右到左的顺序处理from子句中的表名，from子句中写在最后的表(基础表)将被最先处理。在from子句中包含2个表的情况下，必须选择记录条数较少的表作为基础表；如果有3个以上的表连接查询，那就需要选择交叉表作为基础表。（交叉表是指那个被其他表所引用的表）。</li>
<li>where子句中查询条件：用于表与表之间的连接部分，写在where子句靠前位置，能过滤掉越多记录数的查询条件，越写在WHERE子句的末尾。</li>
<li>在where子句里，有索引的字段不要进行数据转换后再进行比较（比如用函数把数字转成字符，再比较），这样会失掉索引的作用。</li>
<li>用到group by的sql，select后面的字段顺序和数量与group by后面的字段顺序和数量一致。</li>
<li>能在on条件过滤掉的（如关联查询时）数据，不留到where；能在where条件中过滤掉的数据，不留到having过滤；having一般与一些聚合函数一起使用。</li>
<li>避免在索引列判断is null 或is not null，否则索引将失效。</li>
<li>比较运算，“&gt;=”符号比“&gt;”效率要高。</li>
<li>能不用like 或 in ，就尽量不用。</li>
<li>通常情况下，用union替换where子句中的or将会起到较好的效果。对索引列使用or将造成全表扫描，即索引失效，可考虑用union 把or分成两个sql，这样保证其中一个或者两个都可以用到索引。</li>
<li>如果可用in与or，尽量用in，如：<br>高效：select … from tableA where A in ( 10,20,30)<br>低效：select … from tableA where A=10 or A=20 or A=30 </li>
<li>用EXISTS替代IN、用NOT EXISTS替代NOT IN<br>高效：select … from tableA where exists(select 1 from tableB  where tableA.A=tableB.A and  tableB.B=’X’))<br>低效：select  … from tableA where tableA.A in(select tableB.A from tableB where tableB.B=’X’)</li>
<li>子查询里使用group by会加快查询速度，尽量少用或不用distinct，如下边情况:<br>select  top 100  t1.*  from  table1  t1  where  t1.FId  in (<br>高效：select t2.FId from table2 t2 where t2.FName=‘xxx’ group by t2.FId<br>低效：select distinct t2.FId from table2 t2 where t2.FName=‘xxx’<br>)。</li>
<li>不要写过于复杂的SQL语句。有限度的在from里使用嵌套子查询，就是from （select f1,f2,f3 from table1 where f4=‘xx’）p 的方式。遇到需要用到多个这样的嵌套查询时，建议使用临时表处理。使用临时表会提高查询速度，大数据量查询效果更明显。注意：临时表使用完后应该drop掉。</li>
<li>多表查询时，尽量用表连接替换exists子句、子查询；能用inner join 的，尽量不用left/right join。</li>
<li>count(<em>)快于conut(1)，如果列有索引，count(列)快于count(</em>)</li>
<li>如果是全表数据删除，truncate比delete效率高，truncate 删除数据是不作日志记录的。</li>
</ul>
<h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><p>应用程序里写SQL：</p>
<ul>
<li>禁止直接使用select * from Table1而不加条件限制；需要什么字段应写明字段名称。</li>
<li>多表查询，查询条件里必须包含所有的表，禁止在where 部分仅写个where 1=1 而不加其它条件，因为这样相当做了一个笛卡尔积，如果两个表的记录都是1万，则查询的结果将是1亿行，这样就容易把数据库的tempdb爆满，引发故障并导致系统不能用。</li>
<li>在代码里编写SQL语句，在进行多表关联查询时，表的后面必须加上别名；在字段名前也要加上表别名，明确字段归属的表。 别名的命名按次序a,b,c,d…，或者用简写，如tbMm1Traffic  tfc, tbNeIp  ip。</li>
<li>为考虑数据库兼容与移植问题：<ul>
<li>编写SQL时，字段名、表名必须遵循大小写敏感的规则，就算当前所用的数据库可以忽略大小写（例如MYSQL，oracle，SqlServer，DB2）。</li>
<li>要求对字段起别名，并且别名也强制区分大小写，从而保证界面元素名称与字段的对应。<code>如：Select  iStaffId “iStffId”, sStaffName “sStaffName” from tbOsStaff。</code></li>
<li>要将一个完整的SQL实例做为注释写在代码里（编程时，查询条件部分多为动态拼装，所以源码里的SQL一般不是完整的SQL实例，可以做一次完整查询，然后从控制台copy一个完整实例贴在注释里）。–此点为曹雄所提。</li>
</ul>
</li>
<li>编写比较复杂的查询语句时，需要格式化（加上回车换行符）和加上详细的注释说明。</li>
<li>一些枚举、基础配置表的翻译，不要使用数据库表关联的方式翻译；两个以上字段是这种情况，就应该单独查询出来，然后在程序中转换。</li>
<li>不要将所有的应用压力都推向数据库。需要做比较复杂的运算时，不要企图用一个SQL语句实现或通过编写一批十分复杂的SQL实现，例如：数据的行转列，完全可以使用程序语言的灵活性处理。</li>
<li>开发时要关注运行速度慢的SQL（标准：超过1秒的SQL），着情进行优化处理，对于不能优化的，用程序处理。</li>
<li>查询字段的选择，尽量使用ID或有索引的字段，或者说对频繁查询的字段，应该加索引，这样可以大大加快查询的速度。</li>
<li>尽量用短事务。在事务里尽量只写新增、删除、修改的语句，少写查询SQL。 </li>
<li>如果要判断某一字符字段是否为空，应该使用以下的判断条件：rtrim(fieldName) is null。<code>如：rtrim(&#39;  &#39;) is null返回的是true； &#39;  &#39; is null 返回的是false。</code></li>
<li>不要在in 条件里放过多的条件（in 里是子查询除外），这样有可能使查询失败，例如Sybase里in的条件不能超过300个。其他的数据库具体数目不清楚，不过在编写代码的时候必须要留意是否会有这样的情况出现。</li>
<li>表里的时间字段，如果是取当前时间的，使用数据库服务器的时间。</li>
<li>手工键入的字符串查询条件都要求模糊匹配。如果还要求不区分大小写，可用upper(fieldName) like upper(‘%+查询条件+%’)，查询字段和条件都用upper进行转换，注意索引失效的情况。</li>
<li>尽量写标准的SQL，如： *=，= null 这些sybase 特有的语法，而标准SQL: a left join b on …，is null。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;知事故而不世故&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;优化指引&quot;&gt;&lt;a href=&quot;#优化指引&quot; class=&quot;headerlink&quot; title=&quot;优化指引&quot;&gt;&lt;/a&gt;优化指引&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个表都要在关键字段（频繁用
    
    </summary>
    
    
      <category term="数据库" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式和抽象工厂模式</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2018/01/20/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2018/01/20/工厂方法模式和抽象工厂模式/</id>
    <published>2018-01-20T04:30:10.000Z</published>
    <updated>2018-01-20T07:03:57.663Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前几天刚写了反射，工厂模式也是用到了反射实现。上次写到为了保证一类指标一种结果我用到了单例模式，其实工厂方法模式中有个延迟始化的应用也能够实现这一需求。</p>
</blockquote>
<h3 id="工厂方法模式【Factory-Method-Pattern】"><a href="#工厂方法模式【Factory-Method-Pattern】" class="headerlink" title="工厂方法模式【Factory Method Pattern】"></a>工厂方法模式【Factory Method Pattern】</h3><p>定义：工厂方法模式又称为工厂模式，也叫虚拟构造器（Virtual Constructor）模式或者多态工厂模式（Polymorphic Factory），在工厂方法模式中，父类负责定义创建对象的公共接口，而子类则负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成，即由子类来决定究竟应该实例化（创建）哪一个类。<br>工厂方式法模式（Factory Method），定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。</p>
<p>工厂方法模式有一个非常重要的应用，就是延迟始化(Lazy initiali zation)，<br>一个对象初始化完毕后就不释放，等到再次用到得就不用再次初始化了，直接从内存过中拿到就可以了,看例子： </p>
<pre><code>package com.cbf4life.advance;

import java.util.HashMap;

@SuppressWarnings(&quot;all&quot;)
public class HumanFactory {
    // 定义一个 MAP, 初始化过的 Human 对象都放在这里

    private static HashMap&lt;String, Human&gt; humans = new HashMap&lt;String, Human&gt;();

    // 定一个烤箱，泥巴塞进去，人就出来，这个太先进了
    public static Human createHuman(Class c) {
        Human human = null;
        // 定义一个类型的人类
        try {
            // 如果 MAP 中有，则直接从取出，不用初始化了
            if (humans.containsKey(c.getSimpleName())) {
                human = humans.get(c.getSimpleName());
            } else {
                human = (Human) Class.forName(c.getName()).newInstance();
                // 放到 MAP 中
                humans.put(c.getSimpleName(), human);
            }
        } catch (InstantiationException e) {
            // 你要是不说个人种颜色的话，没法烤，要白的 黑，你说话了才好烤
            System.out.println(&quot; 必须指定人种的颜色 &quot;);
        } catch (IllegalAccessException e) {
            // 一定定义的人种有问题，那就烤不出来了， 这是 ...
            System.out.println(&quot; 人种定义错误！ &quot;);
        } catch (ClassNotFoundException e) {
            // 你随便说个人种，我到哪里给你制造去？！
            System.out.println(&quot; 混蛋，你指定的人种找不到！ &quot;);
        }
        return human;
    }
}
</code></pre><p>这个在类初始化很消耗资源的情况比较实用，比如你要连接硬件 ，或 者 是 为 了 初 始 化 一 个 类 需 要 准 备 比 较 多 条 件（ 参数 ），通 过 这 种 方 式 可 以 很 好 的 减 少 项 目 的 复 杂 程 度 。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前几天刚写了反射，工厂模式也是用到了反射实现。上次写到为了保证一类指标一种结果我用到了单例模式，其实工厂方法模式中有个延迟始化的应用也能够实现这一需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;工厂方法模式【Factory-Method
    
    </summary>
    
    
      <category term="Java" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>反射机制和单例模式</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2018/01/18/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2018/01/18/反射机制和单例模式/</id>
    <published>2018-01-18T14:56:12.000Z</published>
    <updated>2018-01-19T01:52:10.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>反射机制和单例模式两个知识点，jokeLiang刚跟我说完要好好了解反射机制在后续的一个文件解析处理项目中用到了，而和单例模式一起写的原因是因为在项目中一种指标又多个文件，为了保证一种指标只有一个最终值，所以我利用单例模式实现。</p>
</blockquote>
<h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h2><h3 id="反射机制介绍"><a href="#反射机制介绍" class="headerlink" title="反射机制介绍"></a>反射机制介绍</h3><p>简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。其实最早接触反射机制应该是在jdbc的学习的时候，Class.forName(“com.mysql.jdbc.Driver.class”).newInstance();<br>这句在当时记住的作用是生成驱动对象实例。后期看到很多开发框架中也用到了反射机制，hibernate、struts都是用反射机制实现的。 </p>
<h3 id="反射机制的优缺点"><a href="#反射机制的优缺点" class="headerlink" title="反射机制的优缺点"></a>反射机制的优缺点</h3><p>先了解动态编译与静态编译<br>静态编译：在编译时确定类型，绑定对象,即通过。<br>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。</p>
<ol>
<li>优点： 可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。 </li>
<li>缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</li>
</ol>
<h3 id="反射机制能够进行的操作"><a href="#反射机制能够进行的操作" class="headerlink" title="反射机制能够进行的操作"></a>反射机制能够进行的操作</h3><p> 反射是在知道类名字的情况下，只要你类中有什么信息，就能获得什么信息。</p>
<ol>
<li>首先得根据传入的类的全名来创建Class对象。<br><code>Class c=Class.forName(&quot;className&quot;);注明：className必须为全名，也就是得包含包名，比如，com.knight.pojo.UserInfo;</code><br><code>Object obj=c.newInstance();//创建对象的实例</code></li>
<li>获得构造函数的方法<br><code>Constructor getConstructor(Class[] params)//根据指定参数获得public构造器</code><br><code>Constructor[] getConstructors()//获得public的所有构造器</code><br><code>Constructor getDeclaredConstructor(Class[] params)//根据指定参数获得public和非public的构造器</code><br><code>Constructor[] getDeclaredConstructors()//获得public的所有构造器</code></li>
<li>获得类方法的方法<br><code>Method getMethod(String name, Class[] params),根据方法名，参数类型获得方法</code><br><code>Method[] getMethods()//获得所有的public方法</code><br><code>Method getDeclaredMethod(String name, Class[] params)//根据方法名和参数类型，获得public和非public的方法</code><br><code>Method[] getDeclaredMethods()//获得所以的public和非public方法</code></li>
<li>获得类中属性的方法<br><code>Field getField(String name)//根据变量名得到相应的public变量</code><br><code>Field[] getFields()//获得类中所以public的方法</code><br><code>Field getDeclaredField(String name)//根据方法名获得public和非public变量</code><br><code>Field[] getDeclaredFields()//获得类中所有的public和非public方法</code></li>
</ol>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>注意：</p>
<pre><code>1、单例类只能有一个实例。
2、单例类必须自己创建自己的唯一实例。
3、单例类必须给所有其他对象提供这一实例。
</code></pre><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>
<li>主要解决：一个全局使用的类频繁地创建与销毁。</li>
<li>何时使用：当您想控制实例数目，节省系统资源的时候。</li>
<li>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</li>
<li>关键代码：构造函数是私有的。</li>
<li>应用实例： 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
<li>优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</li>
<li>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br>使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
<li>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</li>
</ul>
<h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3><h4 id="1、懒汉式，线程不安全"><a href="#1、懒汉式，线程不安全" class="headerlink" title="1、懒汉式，线程不安全"></a>1、懒汉式，线程不安全</h4><p>是否 Lazy 初始化：是<br>是否多线程安全：否<br>实现难度：易<br>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>
<pre><code>//懒汉式单例类.在第一次调用的时候实例化自己   
public class Singleton {  
    private Singleton() {}  
    private static Singleton single=null;  
    //静态工厂方法   
    public static Singleton getInstance() {  
         if (single == null) {    
             single = new Singleton();  
         }    
        return single;  
    }  
}  
</code></pre><h4 id="2、懒汉式，线程安全"><a href="#2、懒汉式，线程安全" class="headerlink" title="2、懒汉式，线程安全"></a>2、懒汉式，线程安全</h4><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：易<br>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。<br>代码实例：</p>
<pre><code>public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public static synchronized Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
} 
</code></pre><h4 id="3、饿汉式"><a href="#3、饿汉式" class="headerlink" title="3、饿汉式"></a>3、饿汉式</h4><p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易<br>描述：这种方式比较常用，但容易产生垃圾对象。<br>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。<br>代码实例：</p>
<pre><code>public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
           return instance;  
    }  
}   
</code></pre><h4 id="4、双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4、双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4、双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h4><p>JDK 版本：JDK1.5 起<br>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：较复杂<br>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。<br>代码实例： </p>
<pre><code>public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
            if (singleton == null) {  
                singleton = new Singleton();  
            }  
        }  
    }  
    return singleton;  
    }  
} 
</code></pre><h4 id="5、登记式-静态内部类"><a href="#5、登记式-静态内部类" class="headerlink" title="5、登记式/静态内部类"></a>5、登记式/静态内部类</h4><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：一般<br>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。<br>代码实例：</p>
<pre><code>public class Singleton {  
    private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
    }  
}  
</code></pre><h4 id="6、枚举"><a href="#6、枚举" class="headerlink" title="6、枚举"></a>6、枚举</h4><p>JDK 版本：JDK1.5 起<br>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易<br>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。<br>代码实例：</p>
<pre><code>public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
</code></pre><p>*一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;反射机制和单例模式两个知识点，jokeLiang刚跟我说完要好好了解反射机制在后续的一个文件解析处理项目中用到了，而和单例模式一起写的原因是因为在项目中一种指标又多个文件，为了保证一种指标只有一个最终值，所以我利用单例模式实现。&lt;/p&gt;
&lt;/blo
    
    </summary>
    
    
      <category term="Java" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>携手2017，展望2018</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2018/01/06/%E6%90%BA%E6%89%8B2017%EF%BC%8C%E5%B1%95%E6%9C%9B2018/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2018/01/06/携手2017，展望2018/</id>
    <published>2018-01-06T02:52:16.000Z</published>
    <updated>2018-01-06T10:04:32.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天才写2017的年度总结在时间上有点晚了，但是在我个人的意义来说总结自己的一段过去永远都不会晚。想起写下一段文字来记下自己的一年是因为昨天看了jokerliang关于2017的青春流水账满满的感动。我眼中唤起我们相识的点滴，也唤起了我们当初四人创建博客的初衷—装逼+记录。装逼环节早就做完了，毕竟现在都社会人了，剩下的就是记录了。致初心。</p>
</blockquote>
<p>我的2017中有两种模式的过渡吧，暑假是过渡期，时间很分明。在2017上半年（默默点上根烟，回忆一下啊）在一开学我最浓郁的想法就是学习专业知识吧，我感觉自己专业知识应该不是那个样子，可以更厉害更全面的，其实内心最在的促进是jokerliang，jokerliang在大一暑假单独修炼的一身Android功夫后展露头角，其实想想我也不知道怎么和他玩到一起去的，也道不清是什么牵引我们走到一起，哈哈，可能那就是志同道合吧。jokerliang在后面的专业学习都很不错，学东西也很快，能比我们先接触一些更新的东西，这也是我和三位老铁在一起特别独特的感受，他们总能给我讲一些新的东西，即使我听的不是很明白，但我能感受到没错那就是美好的东西。我和jokerliang两人做了现在认为也挺酷的事情，我们俩天天泡图书馆，上午专业课中午寝室睡会，两点准时去图书馆，jokerliang找了黑马各种学习资料，然后我们就看视频学着写项目，那时候我在学车考驾照，有时候会比jokerliang落后一些，但是在周末jokerliang回家后，我有几次后还自己一个人去图书馆补，现在想想自己也挺感动的，哈哈可那时候还是贪玩，在持续几周这样的生活后，我因为一些其他诱惑有些松懈，但也还是感谢和jokerliang一起学到了很多东西，在打卡三十多天后迎来的是移动开发大赛，开始满哥是想我和jokerliang、啊德一起去的，但阿德说不去，哈哈，立马安插自己人。CHEN走前端说自己走前端，学习点不在这边所以没来，一哥说自己能力有限但是还是愿意去试试。其实我和CHEN两人内心有点偏不自信的人，最开始步入大学两人都是有点内向的那种，两人在大一全选一样的课，两人坐一起，一年课上下来也没多认识几个人。而一哥也偏稳重但是一哥很有尝试新事物的勇气，很多事情他不会立马说干，但是他都有尝试的勇气甚至内心其实也有尝试的渴望，我很多犹豫着事情，问一哥干不干，他都会哎呦，做就做啊有什么的，你要做的话就一起啊，每想起这些情节我耳边都能闪现他说这番话的口气，正因为这胆识也每被我少坑热狗和奶茶，在这事情上CHENS是神补刀了，jokerliang不太热衷，他是一个愿意主动分享的人，有时候还让我有点不好意思的那种（一哥如果看到这里，下次我欣赏你胆识的时候就不要先拒绝了，主动点我才会触手不及的，哈哈）jokerliang在我们合作一些事情的时候总能坚定的要不要做，在我说我们做不做的时候，他会说“哪有什么的，做啊”，其实他有个优点就是他是有自己的明确方向并且会扩展自己的能力去添补自己膨胀野心的，虽然他老说自己喜欢安稳，但事实是安稳比折腾更难，很多人不明白他追求的那份安稳，就像很多人也不明白平庸和平凡的区别。突然写人去了，没有学会一哥欲扬先抑的手法，那继续按时间叙事手法写事情吧。后面我、jokerliang和一哥就组队参加了学校关于移动应用开发大赛的筛选，记得我们获得学校参赛资格的是时候，满哥那天没课跑来学校找我们，那天下雨开车带我们回寝室拿电脑，安排好单独教室从大老远地方牵网线让我们展开备赛，备赛的日子还是很舒服的，一个多月不用上课，单独教室开着空调一哥去办公室泡好茶。日子过的美滋滋也过的后面越来越悠闲了，哈哈在那个月歪点子一来做了个1024的项目，白天写项目写到脸红，现在想起来也挺厉害的，是我们几个太善良，不然这可能也是一个赚钱的黑产了，一哥还是比较过分的，那段时间天天喊腰疼了，也没有把这么好的东西分享给别人造福一下。一个月很快就到了省赛，比赛的地方是在望城信息职院那里，满哥带我们下了一次还上档次的馆子，本来他说进国赛就带我们去他家吃一顿，但是我们只拿了省赛二等奖没有国赛资格，但是经历还是挺开心的，参赛三人同床共枕的感受，颁奖的感受都很特别。今年回去答辩的时候一定请满哥吃顿饭，然后看看能不能能不能去他家里搓一顿哈哈。其实在那个地方比赛还有一个很特别的感受，就是我们住的那条街是一年前和女朋友为了去靖港古镇待过两天的地方，再次回到那里让我想起了很多事情。物是人非伤感。比赛后，还和jokerliang坚持了小一段时间去图书馆，后面又一起用以前的一个农家乐APP参加了创新创业大赛，匠新团队是从那时成立，我们四人想用一生去组建的梦想团队。这次校内创业大赛对我和CHEN是带来很多转变，我也是那时候在学校第一次穿正装，记得我们之前说参加国赛要一起穿正装去，哈哈憧憬和老铁们一起穿着正装干点事业。</p>
<p>后面就来到暑假了，我记得那时候我跟家里说我暑假要在长沙生存两个月，家里给我打三千后叮嘱家里不是特殊情况千万别给我打钱。哈哈那时候很想证明自己成长了不再是个巨婴。我记得那时候和CHEN在外面找了好多天房子，太多都是被中介垄断很少个人房源，但是个人房源没有中介费，所以我们就一直看房子，在下大雨的一天我们找到了，也是要离校的最后一天。后面就是找工作，最开始找专业的面试了好多家培训机构，后面找了个销售办理POS机，开始上班都是兢兢业业，我开始也没有想到这份工作会这么难，我比较幸运的是有个好的开头，在上班的第一天装出去一台奠定了一点信心，其实我也是知道没有退路，房租交了一千八，不工作下个月就没办法养活自己。之后就开始了疯狂的展业，开始去大厦扫楼，记得跑到国储电脑城坐电梯到四十楼往下面扫装了一台，后面感觉市区竞争人太多，我就跑星沙长沙县那些偏远的地方提高业绩，那是每天三十多度的夏天，我每天在长沙县那边的安置区啊各种地方扫街，每天面临无数的拒绝无数次陌拜，后面知道在没有客户资源的情况业绩是和陌拜数量成正比的，我就快速的提高陌拜数量，在大街上是个成年人我都会问他是否需要POS机，不需要的我也尽可能的加微信，那时候学到了很多摸排滚打的销售技巧，业绩也真的上去了，晒得黑乎乎的还跟经理说这是个肤色代表业绩的季节，那一个月真的是我一辈子体验过最苦的日子，八点出去跑是不知道往里跑的那种，晚上九点到家，回家洗完澡还要洗衣服，真的是很抗拒的，主要是CHEN还有女朋友洗。哎，不过那时候我下班晚家里要是做了饭会给我放电饭煲热着，每天在六七点在群里大家开启点菜模式真的很有意思，那时候我要是下班早我也很乐意做菜，对！在暑假我比较自豪的就是自己学会了做菜，还是色香味俱全的那种。后面一个月我把工作辞了，之前在创新创业认识的一个人一起说开公司创业，在暑假和CHEN、Jokerliang一起做了njstay项目，我负责微信这一块，这是我们第一个完整的孩子。后面的一个月就是在家和CHEN、jokerliang一起完善项目，这是之前放假前一起约定好的项目，但第一个月我去上班了，虽然有时候晚上回来早会一起商定一下需求，但我基本上没有什么时间，心里感觉也挺对不起他们的对不起自己说的梦想。后面njstay项目快做完了一直等不到商家资料录入做测试，后面也慢慢夭折了。其实主要是创业项目当初考虑的太片面了，很多事情总想着要把下一件事做出来能怎么做，但往往即使把下一件事做完了你也不知道怎么做，商家也并不是的一个许诺就能换来合作，要承担多少风险能换来多少盈利，这才是实际的。说到这里我也很感激和我一起做事的老铁，做项目没管能赚多少钱就是做，后面项目出了问题拿不到钱，jokerliang自己那么苦还跟我说无论如何不能要我的钱，你是我2017最对不起的一个男人。其实也很对不起CHEN，你的情况我是最清楚的，对jokerliang的愧疚我跟你说了，我没说你的，我感觉也说不出口，我们暑假同在一个屋檐下生活了两个月，而你也太了解我心里那些小心思了，咱俩像是坐在一起很多就在不言中了，希望咱俩能一直明白对方的欲言又止。</p>
<p>陆陆续续又到了开学，我在这个学期基本上是没什么心思在专业学习上，到大学在校园的最后一个学期我才知道利用好一些校园资源很多都能赚钱，开学后我拿着过去客户资源办理POS机，跟着做房地产营销活动的老乡做活动，做驾校的招募，也做过旅行社的秋游导游，承接校园毕业册的拍摄，接了几场商家品牌的校园推广。这些活做好都能赚钱，但我也只是缺钱花的才鼓起干劲去做，一是我知道要赚大钱很多方面就要付出更多做到更加专业，二是我不想丢了自己的专业，并不是我没有勇气去跨越，而是开发这条路我才走了点皮毛，在这路上我遇到了我认为这辈子很重要的人，在这上面还有我的梦想，我还想走走。在后面Jokerliang找到工作后我也再沉淀了一个月专业知识，很感激jokerliang其中对我的一些帮助，拿到了广州公司这边的offer，我现在坐在广州公司的宿舍写年度总结，但我当初拿到offer的时候没有想到自己会来到这里，我很清楚记得来之前和jokerliang打的那通电话，我来广州一是看清楚找我合作的商家看重是我手上的学校资源他们不了解学生群体，但多年后我也会站在他们那个位置，我没有一个长线的方案来做，待在长沙的话也没那么容易脱手，有些事情不是说不做就能不做的，至少我当时想放一放了。二是我想选择这边的平台来历练自己，我想到高一点的地方看多点东西。三是我其实也想孤立一点，待在长沙和老铁们聚在一起更多的是因为寂寞，当然在一个城市能有人聚在取暖很幸福，但更想的是我们因为孤独，我们有着别人都不能懂的东西非得要就咱几个聚一起。聚是一团火，散是满天星。我相信他们是那样的人，我要把自己塑造好，匠新都还没有成长，怎么敢自己沉沦。四是和回来找我的女朋友出了些问题，她回来找我的时候我以为我又拥有了所有，但事实是可能很多事情都回不去了吧。好啦，说了这么多，2017最后一天是和家人一起度过的，在外工作的第一个年头真的很难得的幸福，接下来说说2018吧。</p>
<p>2017我看到自己两个很大的缺陷，一是胆识不够，遇到很多事情容易紧张退缩，主要原因是因为我考虑事情比较细腻，一件事喜欢考虑很多种情况，但是又不够自信，自己容易被考虑到的一些情况吓到退缩。2018我要慢慢找到自己所擅长的方面，在那方面建立起自己的自信。二是我不太愿分享，对自己玩的好的人稍微好点，但是对于其他人在很多事上太小心眼了，这也是我如今比较烦的一点，因为很多事情从道理上我知道要分享，可是分享出去自己心里难受，2018我要建立分享的良性循环，主动去分享，只有这样我才能把手上的事情做的更好，路走的更远。大方针说完小目标就是：戒烟，早睡，练肌肉，处理好感情做个好男人，月薪5K+，匠新团队做一个项目，年底和jokerliang看跨年演讲。<br><img src="http://omhz9w11z.bkt.clouddn.com/biyece.jpg" alt=""></p>
<p><img src="http://omhz9w11z.bkt.clouddn.com/menkou.jpg" alt=""></p>
<p><img src="http://omhz9w11z.bkt.clouddn.com/banjiang.jpg" alt=""><br><img src="http://omhz9w11z.bkt.clouddn.com/beisa.jpg" alt=""><br><img src="https://i.imgur.com/v7gPqYE.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天才写2017的年度总结在时间上有点晚了，但是在我个人的意义来说总结自己的一段过去永远都不会晚。想起写下一段文字来记下自己的一年是因为昨天看了jokerliang关于2017的青春流水账满满的感动。我眼中唤起我们相识的点滴，也唤起了我们当初四人创
    
    </summary>
    
    
      <category term="观看与感悟" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/%E8%A7%82%E7%9C%8B%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>struts2总结</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/10/18/struts2%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/10/18/struts2总结/</id>
    <published>2017-10-18T08:44:20.000Z</published>
    <updated>2017-10-18T13:57:21.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>人身难得今已得，佛法难闻今已闻，此身不向今生度，更待何生度此身。</p>
</blockquote>
<h3 id="1-结果跳转方式"><a href="#1-结果跳转方式" class="headerlink" title="1.结果跳转方式"></a>1.结果跳转方式</h3><ol>
<li><p>转发</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"DemoAction"</span> <span class="attr">class</span>=<span class="string">"cn.knight.DemoAction"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"dispatcher"</span>&gt;</span>/hello.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>重定向</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"DemoAction"</span> <span class="attr">class</span>=<span class="string">"cn.knight.DemoAction"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"redirect"</span>&gt;</span>/hello.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>转发Action</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"DemoAction"</span> <span class="attr">class</span>=<span class="string">"cn.knight.DemoAction"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"chain"</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!--action的名字--&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> =<span class="string">"actionName"</span>&gt;</span>DemoAction<span class="tag">&lt;/<span class="name">param</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!--action的所在命名空间--&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> =<span class="string">"namespace"</span>&gt;</span>/<span class="tag">&lt;/<span class="name">param</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>重定向Action</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"DemoAction"</span> <span class="attr">class</span>=<span class="string">"cn.knight.DemoAction"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!--action的名字--&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> =<span class="string">"actionName"</span>&gt;</span>DemoAction<span class="tag">&lt;/<span class="name">param</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!--action的所在命名空间--&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> =<span class="string">"namespace"</span>&gt;</span>/<span class="tag">&lt;/<span class="name">param</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-访问ServletAPI方式"><a href="#2-访问ServletAPI方式" class="headerlink" title="2.访问ServletAPI方式"></a>2.访问ServletAPI方式</h3><ol>
<li>原理<br><img src="https://i.imgur.com/uS0f48J.png" alt=""></li>
<li><p>通过ActionContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//如何在action中获得原生ServletAPI</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5Action</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">//request域=&gt; map (struts2并不推荐使用原生request域)</span></div><div class="line">		<span class="comment">//不推荐</span></div><div class="line">		Map&lt;String, Object&gt; requestScope = (Map&lt;String, Object&gt;) ActionContext.getContext().get(<span class="string">"request"</span>);</div><div class="line">		<span class="comment">//推荐</span></div><div class="line">		ActionContext.getContext().put(<span class="string">"name"</span>, <span class="string">"requestTom"</span>);</div><div class="line">		<span class="comment">//session域 =&gt; map</span></div><div class="line">		Map&lt;String, Object&gt; sessionScope = ActionContext.getContext().getSession();</div><div class="line">		sessionScope.put(<span class="string">"name"</span>, <span class="string">"sessionTom"</span>);</div><div class="line">		<span class="comment">//application域=&gt;map</span></div><div class="line">		Map&lt;String, Object&gt; applicationScope = ActionContext.getContext().getApplication();</div><div class="line">		applicationScope.put(<span class="string">"name"</span>, <span class="string">"applicationTom"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> SUCCESS;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过ServletActionContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//并不推荐</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="comment">//原生request</span></div><div class="line">	HttpServletRequest request = ServletActionContext.getRequest();</div><div class="line">	<span class="comment">//原生session</span></div><div class="line">	HttpSession session = request.getSession();</div><div class="line">	<span class="comment">//原生response</span></div><div class="line">	HttpServletResponse response = ServletActionContext.getResponse();</div><div class="line">	<span class="comment">//原生servletContext</span></div><div class="line">	ServletContext servletContext = ServletActionContext.getServletContext();</div><div class="line">	<span class="keyword">return</span> SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过实现接口的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7Action</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ServletRequestAware</span> </span>&#123;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> HttpServletRequest request;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"原生request:"</span>+request);</div><div class="line">		<span class="keyword">return</span> SUCCESS;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServletRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.request = request;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-参数"><a href="#3-参数" class="headerlink" title="3.参数"></a>3.参数</h3><ol>
<li>属性驱动<pre><code>|-Action准备与参数键同名属性
</code></pre>jsp<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;form action="$&#123;pageContext.request.contextPath&#125;/Demo8Action"&gt;</div><div class="line">	用户名:&lt;input type="text" name="name" /&gt;&lt;br&gt;</div><div class="line">	年龄:&lt;input type="text" name="age" /&gt;&lt;br&gt;</div><div class="line">	生日:&lt;input type="text" name="birthday" /&gt;&lt;br&gt;</div><div class="line">	&lt;input type="submit" value="提交" /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Action<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//准备与参数键名称相同的属性</span></div><div class="line"><span class="keyword">private</span> String name;</div><div class="line"><span class="comment">//自动类型转换 只能转换8大基本数据类型以及对应包装类</span></div><div class="line"><span class="keyword">private</span> Integer age;</div><div class="line"><span class="comment">//支持特定类型字符串转换为Date ,例如 yyyy-MM-dd</span></div><div class="line"><span class="keyword">private</span> Date   birthday;</div></pre></td></tr></table></figure></p>
<ol>
<li>对象驱动<pre><code>|-Action准备与参数键同名属性. xxx.yyy
</code></pre>jsp<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;form action="$&#123;pageContext.request.contextPath&#125;/Demo9Action"&gt;</div><div class="line">	用户名:&lt;input type="text" name="user.name" /&gt;&lt;br&gt;</div><div class="line">	年龄:&lt;input type="text" name="user.age" /&gt;&lt;br&gt;</div><div class="line">	生日:&lt;input type="text" name="user.birthday" /&gt;&lt;br&gt;</div><div class="line">	&lt;input type="submit" value="提交" /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Action<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo9Action</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span>  </span>&#123;</div><div class="line">	<span class="comment">//准备user对象</span></div><div class="line">	<span class="keyword">private</span> User user;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; 	</div><div class="line">		System.out.println(user);	</div><div class="line">		<span class="keyword">return</span> SUCCESS;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> user;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.user = user;</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>模型驱动<br>jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;form action="$&#123;pageContext.request.contextPath&#125;/Demo10Action"&gt;</div><div class="line">	用户名:&lt;input type="text" name="name" /&gt;&lt;br&gt;</div><div class="line">	年龄:&lt;input type="text" name="age" /&gt;&lt;br&gt;</div><div class="line">	生日:&lt;input type="text" name="birthday" /&gt;&lt;br&gt;</div><div class="line">	&lt;input type="submit" value="提交" /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p> |- 1.实现ModelDriven接口<br> |- 2.实现getModel方法.返回需要封装参数的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10Action</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">//准备user 成员变量</span></div><div class="line">	<span class="keyword">private</span> User user =<span class="keyword">new</span> User();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; 	</div><div class="line">		System.out.println(user);</div><div class="line">		<span class="keyword">return</span> SUCCESS;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getModel</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> user;</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>复杂参数封装<br>List集合<br> 提交键: list        <pre><code>list[index]
</code></pre>Map结合<pre><code>提交键: map[&apos;key&apos;]
</code></pre></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人身难得今已得，佛法难闻今已闻，此身不向今生度，更待何生度此身。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-结果跳转方式&quot;&gt;&lt;a href=&quot;#1-结果跳转方式&quot; class=&quot;headerlink&quot; title=&quot;1.结果跳转方式&quot;
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>佛偈</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/10/13/%E4%BD%9B%E5%81%88/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/10/13/佛偈/</id>
    <published>2017-10-13T01:27:54.000Z</published>
    <updated>2018-01-08T02:52:20.862Z</updated>
    
    <content type="html"><![CDATA[<p>来时欢喜去时悲，空在人间走一回，不如不来也不去，也无欢喜也无悲。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来时欢喜去时悲，空在人间走一回，不如不来也不去，也无欢喜也无悲。&lt;/p&gt;

    
    </summary>
    
    
      <category term="观看与感悟" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/%E8%A7%82%E7%9C%8B%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>struts2_day01</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/09/23/struts2-day01/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/09/23/struts2-day01/</id>
    <published>2017-09-23T14:39:53.000Z</published>
    <updated>2017-09-23T15:43:53.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>博客很久没有更新了，也并不是段时间停止了学习，只是自己在生活中扮演了其他的角色，在其他方面学习。今天重新拾起博客，因为写博客是个好习惯，不管是记录学习内容还是记录生活其他经历经验，这份坚持都应该持续下去，但是放弃以前在写博客的一些不必要的执念，这个平台内容不需要多华丽的用词，不需要多精湛的技术分享记录，需要的是我一直坚持的真实表达。</p>
</blockquote>
<h3 id="什么是struts2"><a href="#什么是struts2" class="headerlink" title="什么是struts2"></a>什么是struts2</h3><ol>
<li>运行在web层，负责处理请求的。</li>
<li>struts2已经封装了很多web中常用的功能（拦截器）。</li>
<li>struts2与struts1没有什么关系，struts2主要是基于webwoke框架。</li>
</ol>
<h3 id="struts2框架搭建"><a href="#struts2框架搭建" class="headerlink" title="struts2框架搭建"></a>struts2框架搭建</h3><h4 id="1、导包"><a href="#1、导包" class="headerlink" title="1、导包"></a>1、导包</h4><pre><code>|-struts2/apps/struts-blank.war/WEB-INF/lib
</code></pre><h4 id="2、书写Action"><a href="#2、书写Action" class="headerlink" title="2、书写Action"></a>2、书写Action</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">Customer</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">private</span> CustomerService cs = <span class="keyword">new</span> CustomerServiceImpl();</div><div class="line">	<span class="keyword">private</span> Customer customer = <span class="keyword">new</span> Customer();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">//1 接受参数</span></div><div class="line">		String cust_name = ServletActionContext.getRequest().getParameter(<span class="string">"cust_name"</span>);</div><div class="line">		<span class="comment">//2 创建离线查询对象</span></div><div class="line">		DetachedCriteria dc =DetachedCriteria.forClass(Customer.class);</div><div class="line">		<span class="comment">//3 判断参数拼装条件</span></div><div class="line">		<span class="keyword">if</span>(StringUtils.isNotBlank(cust_name))&#123;</div><div class="line">			dc.add(Restrictions.like(<span class="string">"cust_name"</span>, <span class="string">"%"</span>+cust_name+<span class="string">"%"</span>));</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//4 调用Service将离线对象传递</span></div><div class="line">		List&lt;Customer&gt; list = cs.getAll(dc);</div><div class="line">		<span class="comment">//5 将返回的list放入request域.转发到list.jsp显示</span></div><div class="line">		ServletActionContext.getRequest().setAttribute(<span class="string">"list"</span>, list);</div><div class="line">		<span class="keyword">return</span> <span class="string">"list"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//添加客户</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		<span class="comment">//1 调用Service</span></div><div class="line">		cs.save(customer);</div><div class="line">		<span class="comment">//2 重定向到列表action方法</span></div><div class="line">		<span class="keyword">return</span> <span class="string">"toList"</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Customer <span class="title">getModel</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> customer;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、书写主配置文件-src-struts-xml"><a href="#3、书写主配置文件-src-struts-xml" class="headerlink" title="3、书写主配置文件 src/struts.xml"></a>3、书写主配置文件 src/struts.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></div><div class="line">	"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</div><div class="line">	"http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!-- i18n:国际化. 解决post提交乱码 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.i18n.encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">constant</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 指定反问action时的后缀名 </span></div><div class="line">		http://localhost:8080/struts2_day01/hello/HelloAction.do</div><div class="line">	--&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action"</span>&gt;</span><span class="tag">&lt;/<span class="name">constant</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 指定struts2是否以开发模式运行</span></div><div class="line">			1.热加载主配置.(不需要重启即可生效)</div><div class="line">			2.提供更多错误信息输出,方便开发时的调试</div><div class="line">	 --&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">constant</span>&gt;</span></div><div class="line">	</div><div class="line">	</div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- package:将Action配置封装.就是可以在Package中配置很多action.</span></div><div class="line">			name属性: 给包起个名字,起到标识作用.随便起.不能其他包名重复.</div><div class="line">			namespace属性:给action的访问路径中定义一个命名空间</div><div class="line">			extends属性: 继承一个 指定包</div><div class="line">			abstract属性:包是否为抽象的; 标识性属性.标识该包不能独立运行.专门被继承</div><div class="line">	  --&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">namespace</span>=<span class="string">"/hello"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> &gt;</span></div><div class="line">		<span class="comment">&lt;!-- action元素:配置action类</span></div><div class="line">				name属性: 决定了Action访问资源名.</div><div class="line">				class属性: action的完整类名</div><div class="line">				method属性: 指定调用Action中的哪个方法来处理请求</div><div class="line">		 --&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"HelloAction"</span> <span class="attr">class</span>=<span class="string">"cn.itheima.a_hello.HelloAction"</span> <span class="attr">method</span>=<span class="string">"hello"</span> &gt;</span></div><div class="line">			<span class="comment">&lt;!-- result元素:结果配置 </span></div><div class="line">					name属性: 标识结果处理的名称.与action方法的返回值对应.</div><div class="line">					type属性: 指定调用哪一个result类来处理结果,默认使用转发.</div><div class="line">					标签体:填写页面的相对路径</div><div class="line">			--&gt;</div><div class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"dispatcher"</span> &gt;</span>/hello.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">action</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">package</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 引入其他struts配置文件 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"cn/itheima/b_dynamic/struts.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"cn/itheima/c_default/struts.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="4、在web-xml配置过滤器"><a href="#4、在web-xml配置过滤器" class="headerlink" title="4、在web.xml配置过滤器"></a>4、在web.xml配置过滤器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- struts2的核心过滤器 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="struts2架构"><a href="#struts2架构" class="headerlink" title="struts2架构"></a>struts2架构</h3><p><img src="http://www.blogjava.net/images/blogjava_net/lzhidj/15.PNG" alt=""></p>
<p><strong>一个请求在Struts2框架中的处理大概分为以下几个步骤：</strong></p>
<ol>
<li><p>客户端初始化一个指向Servlet容器（例如Tomcat）的请求；</p>
</li>
<li><p>这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh Plugin）；</p>
</li>
<li><p>接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请求是否需要调用某个Action；</p>
</li>
<li><p>如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy；</p>
</li>
<li><p>ActionProxy通过Configuration Manager询问框架的配置文件，找到需要调用的Action类；</p>
</li>
<li><p>ActionProxy创建一个ActionInvocation的实例。</p>
</li>
<li><p>ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。</p>
</li>
<li><p>一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2框架中继承的标签。在这个过程中需要涉及到ActionMapper。</p>
</li>
</ol>
<p>FilterDispatcher是控制器的核心，就是mvc中c控制层的核心。下面粗略的分析下我理解的FilterDispatcher工作流程和原理：FilterDispatcher进行初始化并启用核心doFilter</p>
<h3 id="Action创建"><a href="#Action创建" class="headerlink" title="Action创建"></a>Action创建</h3><ol>
<li>POJO普通java类，不需要继承，不需要实现</li>
<li>实现Action接口</li>
<li>继承ActionSupport</li>
</ol>
<p>Action方法<br>    <code>public String XX() throws Exception{}</code><br>action方法返回String类型，不带参数，可抛异常。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;博客很久没有更新了，也并不是段时间停止了学习，只是自己在生活中扮演了其他的角色，在其他方面学习。今天重新拾起博客，因为写博客是个好习惯，不管是记录学习内容还是记录生活其他经历经验，这份坚持都应该持续下去，但是放弃以前在写博客的一些不必要的执念，这个
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>hibernate（一篇）</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/06/14/hibernate%EF%BC%88%E4%B8%80%E7%AF%87%EF%BC%89/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/06/14/hibernate（一篇）/</id>
    <published>2017-06-14T14:59:22.000Z</published>
    <updated>2017-06-14T15:23:47.716Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>我知道很多人的欲望很难突破，我也不赞成用压抑的方式去对待欲望。欲望事需要被穿越的，而穿越的方法有时候就是追逐、满足它。到了一定时候，你会像我一样精疲力竭，坐会到自己的位子上，才发现，原来我想要的一切，都已经在我出发地方等着我了。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我知道很多人的欲望很难突破，我也不赞成用压抑的方式去对待欲望。欲望事需要被穿越的，而穿越的方法有时候就是追逐、满足它。到了一定时候，你会像我一样精疲力竭，坐会到自己的位子上，才发现，原来我想要的一切，都已经在我出发地方等着我了。&lt;/p&gt;
&lt;/blo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/05/17/%E6%B3%A8%E8%A7%A3/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/05/17/注解/</id>
    <published>2017-05-17T15:40:31.000Z</published>
    <updated>2017-05-17T15:44:44.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解：（重点）"><a href="#注解：（重点）" class="headerlink" title="注解：（重点）"></a>注解：（重点）</h2><h3 id="1使用三个基本的注解"><a href="#1使用三个基本的注解" class="headerlink" title="1使用三个基本的注解"></a>1使用三个基本的注解</h3><p><code>@Deprecated</code><br><code>@SuppressWarnings</code><br><code>@Override</code></p>
<h3 id="2自定义注解：外形"><a href="#2自定义注解：外形" class="headerlink" title="2自定义注解：外形"></a>2自定义注解：外形</h3><p>a、定义注解的语法：<br><code>public @interface MyAnn{}</code>   父类：<code>Annotation</code><br>b、定义注解的属性<br>属性的类型 属性名() [default 默认值];（默认为public）</p>
<p><strong>属性的类型必须是：基本类型、String、Class、注解、枚举及以上类型的一维数组。</strong></p>
<p>注：value是一个特殊属性，赋值时不必给定属性名称。<br>注：给数组类型的属性，可以指定一个值。</p>
<p>不仅要会定义，而且还得会用。</p>
<h3 id="3注解的反射：注入了灵魂"><a href="#3注解的反射：注入了灵魂" class="headerlink" title="3注解的反射：注入了灵魂"></a>3注解的反射：注入了灵魂</h3><h4 id="a、反射注解"><a href="#a、反射注解" class="headerlink" title="a、反射注解"></a>a、反射注解</h4><p>java.lang.reflect.AnnotatedElement:<br><code>&lt;t extends Annotation&gt; getAnnotation(Class&lt;T&gt; annotation):</code>得到指定的注解<br><code>Annotation[] getAnnotations():</code>得到所有的注解<br><code>Annotation[] getDeclareAnnotations():</code>得到直接存在上面的注解<br><code>boolean isAnnotationPresent(Class&lt;T&gt; annotation):</code>判断有没有指定的注解<br>没有指定主语：<br>Class、Method、Field、Constructor、Package实现了该接口。</p>
<h4 id="b、元注解"><a href="#b、元注解" class="headerlink" title="b、元注解"></a>b、元注解</h4><p>元注解：服务于注解的注解。<br><code>@Retention：</code>用于改变注解的生命周期。<br><code>RetentionPolicy：</code><br><code>SOURCE:</code>源代码级别<br><code>CLASS：</code>字节码级别（磁盘上的）<br><code>RUNTIME：</code>字节码级别（运行时，虚拟机内存中的）<br><code>@Target：</code>用于给定注解使用的位置。<br><code>ElementType：</code><br><code>TYPE\METHOD等</code><br><code>@Documented：</code>用于标识使用了注解的类的javadoc文档中出现注解的身影。<br><code>@Inherited：</code>使用了注解的类的子类是否可以继承父类使用的注解。</p>
<p>今后：XML——————&gt;注解</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注解：（重点）&quot;&gt;&lt;a href=&quot;#注解：（重点）&quot; class=&quot;headerlink&quot; title=&quot;注解：（重点）&quot;&gt;&lt;/a&gt;注解：（重点）&lt;/h2&gt;&lt;h3 id=&quot;1使用三个基本的注解&quot;&gt;&lt;a href=&quot;#1使用三个基本的注解&quot; class=&quot;head
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>AJAX和国际化</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/05/16/AJAX%E5%92%8C%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/05/16/AJAX和国际化/</id>
    <published>2017-05-16T08:45:00.000Z</published>
    <updated>2017-05-16T09:18:02.564Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、AJAX简介"><a href="#一、AJAX简介" class="headerlink" title="一、AJAX简介"></a>一、AJAX简介</h3><p>1、Asynchronous JavaScript And XML指异步 JavaScript 及 XML<br>2、老技术新用法。是基于JavaScript、XML、HTML、CSS新用法</p>
<h3 id="二、同步和异步（理解）"><a href="#二、同步和异步（理解）" class="headerlink" title="二、同步和异步（理解）"></a>二、同步和异步（理解）</h3><h3 id="三、第一个异步请求案例（熟悉编码步骤）"><a href="#三、第一个异步请求案例（熟悉编码步骤）" class="headerlink" title="三、第一个异步请求案例（熟悉编码步骤）"></a>三、第一个异步请求案例（熟悉编码步骤）</h3><p><img src="http://i.imgur.com/XnjqLJY.png" alt=""></p>
<h3 id="四、XmlHttpRequest（JS）对象详解（重点）"><a href="#四、XmlHttpRequest（JS）对象详解（重点）" class="headerlink" title="四、XmlHttpRequest（JS）对象详解（重点）"></a>四、XmlHttpRequest（JS）对象详解（重点）</h3><ul>
<li>1、创建XmlHttpRequest对象<br>不同浏览器，设置相同浏览器的版本，创建该对象的方式是不同的。<br>解决办法：<ul>
<li>a、从w3cshool的文档中拷贝。</li>
<li>b、将来：用jQuery等框架</li>
</ul>
</li>
<li><p>2、XmlHttpRequest对象的属性</p>
<ul>
<li>a、readyState：short只读<br>标识着当前的请求状态<br><img src="http://i.imgur.com/Ta2HBk1.png" alt=""><br>0：XmlHttpRequest对象被创建了。此时为0<br>1：建立与服务器的链接，但是请求还没有发出去。此时为1。open(),send()还没有执行。<br>2：发出了请求，但是服务器没有任何响应。此时为2<br>3：接收到了服务器的响应，接收到了服务器发出的响应消息头时，此时3.<br>4：接收到了服务器发送的响应正文，响应结束。此时为4<br><img src="http://i.imgur.com/20dCrmp.png" alt=""><br>b、status：代表着响应状态码<br>c、statusText：响应码描述<br>d、responseText：字符串类型。代表着响应正文内容，把他当做文本对待<br>e、responseXML：Document。代表着响应正文内容，把他当做一个Document对象。（DOM）</li>
</ul>
</li>
<li><p>3、XmlHttpRequest的方法</p>
<ul>
<li>a、getAllResponseHeaders():返回的是所有的响应消息头。是一个字符串。</li>
<li>b、getResponseHeader(var headerName):返回指定响应消息头的值。是一个字符串。</li>
<li>c、open(var method,var url,boolean isAnsy):建立连接。<br>method，请求方式<br>url，请求的地址<br>isAnsy，同步还是异步。默认是true，就是异步。</li>
<li>d、send(var data):向服务器发送请求正文。如果是get请求，请求传入null.<br>如果是post请求：data =”username=abc&amp;password=123”</li>
<li>e、setRequestHeader(var headerName,var headerValue):向服务器发送请求消息头。</li>
</ul>
</li>
</ul>
<ul>
<li>4、XmlHttpRequest的状态监听器<br>onreadystatechange，指向是一个函数。回调函数。<br>何时触发执行，每次XHR对象的readyState发生变化都会触发。</li>
</ul>
<p>一般写法：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">xhr.onreadystatechange=function()&#123;</div><div class="line">	<span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(xhr.status==<span class="number">200</span>)&#123;</div><div class="line">			<span class="comment">//JS之DOM、BOM编程</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="五、案例"><a href="#五、案例" class="headerlink" title="五、案例"></a>五、案例</h3><h3 id="六、JSON-lib、Xstream简介"><a href="#六、JSON-lib、Xstream简介" class="headerlink" title="六、JSON-lib、Xstream简介"></a>六、JSON-lib、Xstream简介</h3><h3 id="七、二级联动（异步请求）"><a href="#七、二级联动（异步请求）" class="headerlink" title="七、二级联动（异步请求）"></a>七、二级联动（异步请求）</h3><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><h3 id="一、固定文本的国际化"><a href="#一、固定文本的国际化" class="headerlink" title="一、固定文本的国际化:"></a>一、固定文本的国际化:</h3><p><strong>一个消息资源包，由多个properties文件组成的(基名和扩展名一致的)。</strong></p>
<p>这些文件有着以下特点：</p>
<ul>
<li><p><code>基名_语言代码(ISO)_国家区域代码(ISO).properties</code></p>
</li>
<li><p><code>message_zh_CN.properties</code></p>
</li>
<li><code>message_en_US.properties</code></li>
<li><code>message.properties(默认的)</code><ul>
<li><code>ResourceBundle</code></li>
<li><code>Locale</code></li>
</ul>
</li>
</ul>
<h3 id="二、日期时间的格式化："><a href="#二、日期时间的格式化：" class="headerlink" title="二、日期时间的格式化："></a>二、日期时间的格式化：</h3><ul>
<li><p><code>DateFormat: SimpleDateFormat</code></p>
</li>
<li><p>用户输入：String————-&gt;java.util.Date<br><code>Date parse(String)</code></p>
</li>
<li><p>显示数据：java.util.Date————-&gt;String<br><code>String format(Date)</code></p>
</li>
</ul>
<h3 id="三、数字的格式化（货币）："><a href="#三、数字的格式化（货币）：" class="headerlink" title="三、数字的格式化（货币）："></a>三、数字的格式化（货币）：</h3><ul>
<li><p><code>NumberFormat:</code></p>
</li>
<li><p>用户输入：String————-&gt;java.lang.Number<br><code>Number parse(String)</code></p>
</li>
<li><p>显示数据：java.util.Number————-&gt;String<br><code>String format(Number)</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、AJAX简介&quot;&gt;&lt;a href=&quot;#一、AJAX简介&quot; class=&quot;headerlink&quot; title=&quot;一、AJAX简介&quot;&gt;&lt;/a&gt;一、AJAX简介&lt;/h3&gt;&lt;p&gt;1、Asynchronous JavaScript And XML指异步 JavaScrip
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>文件上传下载和监听器</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/05/10/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/05/10/文件上传下载和监听器/</id>
    <published>2017-05-10T12:56:05.000Z</published>
    <updated>2017-05-10T13:29:15.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>真正让你失望和绝望的，并不是你的希望，而是你对希望的执着。<br>有了希望，你会产生拒绝；没有希望，你才会接受一切。</p>
</blockquote>
<h3 id="一、文件上传"><a href="#一、文件上传" class="headerlink" title="一、文件上传"></a>一、文件上传</h3><h4 id="1、文件上传的原理分析"><a href="#1、文件上传的原理分析" class="headerlink" title="1、文件上传的原理分析"></a>1、文件上传的原理分析</h4><ul>
<li><p>1.1文件上传的必要前提：</p>
<ul>
<li>a、表单的method必须是post</li>
<li><p>b、表单的enctype属性必须是multipart/form-data类型的。<br>enctype默认值：application/x-www-form-urlencoded<br>作用：告知服务器，请求正文的MIME类型</p>
</li>
<li><p>application/x-www-form-urlencoded   ：   username=abc&amp;password=123</p>
</li>
</ul>
</li>
</ul>
<p>ServletRequest.getParameter(String name);该方法是专门读取该类型的方法</p>
<pre><code>* multipart/form-data:
</code></pre><p><img src="http://i.imgur.com/8NiPrmo.png" alt=""></p>
<ul>
<li>1.2文件上传<br>原理：解析请求正文中的内容。</li>
</ul>
<h4 id="2、借助第三方组件实现文件上传"><a href="#2、借助第三方组件实现文件上传" class="headerlink" title="2、借助第三方组件实现文件上传"></a>2、借助第三方组件实现文件上传</h4><ul>
<li>2.1、commons-fileupload组件：<br>拷贝jar包：commons-fileupload.jar   commons-io.jar 具体参考<br><a href="http://commons.apache.org/proper/commons-fileupload/using.html" target="_blank" rel="external">http://commons.apache.org/proper/commons-fileupload/using.html</a></li>
<li>2.2How it works<br><img src="http://i.imgur.com/SHkRomC.png" alt=""></li>
</ul>
<h4 id="3、文件上传详解"><a href="#3、文件上传详解" class="headerlink" title="3、文件上传详解"></a>3、文件上传详解</h4><ul>
<li><p>3.1DiskFileItemFactory<br><img src="http://i.imgur.com/gtqxJTE.png" alt=""><br>public void setRepository(File repository)：设置临时文件的存放目录<br>public void setSizeThreshold(int sizeThreshold)：设置缓存的大小</p>
</li>
<li><p><strong>专题：关于临时文件</strong><br><img src="http://i.imgur.com/g2bN00i.png" alt=""><br>文件上传时，自己用IO流处理，一定要在流关闭后删除临时文件。FileItem.delete()<br>建议使用：FileItem.writer(File f).会自动删除临时文件。</p>
</li>
<li><p>3.2乱码问题</p>
<ul>
<li>a、普通字段的乱码<br>FileItem.getString(String charset);编码要和客户端一致。</li>
<li>b、上传的中文文件名乱码<br>解决办法：request.setCharacterEncoding(“UTF-8”);编码要和客户端一致。</li>
</ul>
</li>
<li>3.3文件重名问题<br>解决办法：a.txt 多次上传会被覆盖<br>UUID_a.txt<br><img src="http://i.imgur.com/cq2pcw7.png" alt=""></li>
<li><p>3.4保证服务器的安全<br>把存放文件的目录，放到用户直接访问不到的地方。</p>
</li>
<li><p>3.5避免一个文件夹中的文件过多<br>解决方案：分目录存储<br>参考实现：</p>
<ul>
<li>按照日期分目录存储</li>
<li>按照文件名的hashCode计算存储目录</li>
</ul>
</li>
</ul>
<p><img src="http://i.imgur.com/hzUHfuZ.png" alt=""></p>
<ul>
<li><p>3.6限制上传文件的大小，并给出友好提示<br>web方式下不适合传输较大的文件。</p>
<ul>
<li><p>单文件大小：<br><code>ServletFileUpload.setFileSizeMax(3*1024*1024);</code>//设置单个文件上传的大小</p>
</li>
<li><p>总文件大小：（多文件上传）<br><code>ServletFileUpload.setSizeMax(6*1024*1024);</code>//多文件上传时总大小限制</p>
</li>
</ul>
</li>
<li>3.7限制上传文件的类型<br>扩展名+文件的MIME类型：<br>100%防止住：图片的。判断字节的前几位。</li>
</ul>
<h4 id="4、文件的下载"><a href="#4、文件的下载" class="headerlink" title="4、文件的下载"></a>4、文件的下载</h4><p>代码实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String uuidfilename = request.getParameter(<span class="string">"filename"</span>);<span class="comment">//get方式提交的</span></div><div class="line">uuidfilename = <span class="keyword">new</span> String(uuidfilename.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"UTF-8"</span>);<span class="comment">//UUID的文件名</span></div><div class="line">		</div><div class="line">String storeDirectory = getServletContext().getRealPath(<span class="string">"/WEB-INF/files"</span>);</div><div class="line"><span class="comment">//得到存放的子目录</span></div><div class="line">String childDirecotry = makeChildDirectory(storeDirectory, uuidfilename);</div><div class="line">		</div><div class="line"><span class="comment">//构建输入流</span></div><div class="line">InputStream in = <span class="keyword">new</span> FileInputStream(storeDirectory+File.separator+childDirecotry+File.separator+uuidfilename);</div><div class="line"><span class="comment">//下载</span></div><div class="line">String oldfilename = uuidfilename.substring(uuidfilename.indexOf(<span class="string">"_"</span>)+<span class="number">1</span>);</div><div class="line"><span class="comment">//通知客户端以下载的方式打开</span></div><div class="line">response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span>+URLEncoder.encode(oldfilename, <span class="string">"UTF-8"</span>));</div><div class="line">		</div><div class="line">OutputStream out = response.getOutputStream();</div><div class="line">		</div><div class="line"><span class="keyword">int</span> len = -<span class="number">1</span>;</div><div class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">while</span>((len=in.read(b))!=-<span class="number">1</span>)&#123;</div><div class="line">	out.write(b,<span class="number">0</span>,len);</div><div class="line">&#125;</div><div class="line">in.close();</div><div class="line">out.close();</div><div class="line"></div><div class="line"><span class="comment">//计算存放的子目录</span></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">makeChildDirectory</span><span class="params">(String realPath, String fileName)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> hashCode = fileName.hashCode();</div><div class="line">	<span class="keyword">int</span> dir1 = hashCode&amp;<span class="number">0xf</span>;<span class="comment">// 取1~4位</span></div><div class="line">	<span class="keyword">int</span> dir2 = (hashCode&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>;<span class="comment">//取5~8位</span></div><div class="line">	</div><div class="line">	String directory = <span class="string">""</span>+dir1+File.separator+dir2;</div><div class="line">	File file = <span class="keyword">new</span> File(realPath,directory);</div><div class="line">	<span class="keyword">if</span>(!file.exists())</div><div class="line">		file.mkdirs();</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> directory;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="二、Servlet规范中的监听器（回顾）"><a href="#二、Servlet规范中的监听器（回顾）" class="headerlink" title="二、Servlet规范中的监听器（回顾）"></a>二、Servlet规范中的监听器（回顾）</h3><h4 id="1、观察者设计模式："><a href="#1、观察者设计模式：" class="headerlink" title="1、观察者设计模式："></a>1、观察者设计模式：</h4><p>事件源：出发事件的对象。<br>事件：封装了事件源。<br>监听器：一般是一个接口，由使用者来实现。</p>
<h4 id="2、Servlet规范中提供的八个监听器"><a href="#2、Servlet规范中提供的八个监听器" class="headerlink" title="2、Servlet规范中提供的八个监听器"></a>2、Servlet规范中提供的八个监听器</h4><ul>
<li>a、监听ServletContext、HttpSession、ServletRequest创建和销毁的监听器<br><code>ServletContextListener:</code><br><code>HttpSessionListener:</code><br><code>ServletRequestListener:</code></li>
<li>b、监听ServletContext、HttpSession、ServletRequest属性的变化的监听器（attribute）<br>setAttribute() :添加和替换removeAttribute()<br><code>ServletContextAttributeListener:</code><br><code>HttpSessionAttributeListener:</code><br><code>ServletRequestAttributeListener:</code></li>
<li>c、感知型监听器。这种监听器不需要注册。都与会话有关<br><code>HttpSessionBindingListener:</code>感知自己被放到了HttpSession属性中<br><code>HttpSessionActivationListener：</code>感知自己何时随着HttpSession钝化或激活</li>
</ul>
<h4 id="3、监听器案例：查看在线登陆的用户，踢人。"><a href="#3、监听器案例：查看在线登陆的用户，踢人。" class="headerlink" title="3、监听器案例：查看在线登陆的用户，踢人。"></a>3、监听器案例：查看在线登陆的用户，踢人。</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;真正让你失望和绝望的，并不是你的希望，而是你对希望的执着。&lt;br&gt;有了希望，你会产生拒绝；没有希望，你才会接受一切。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、文件上传&quot;&gt;&lt;a href=&quot;#一、文件上传&quot; class=&quot;header
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>过滤器</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/05/07/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/05/07/过滤器/</id>
    <published>2017-05-07T13:17:44.000Z</published>
    <updated>2017-05-07T13:41:28.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>有了希望，你会产生拒绝; 没有希望，你会接受一切。</p>
</blockquote>
<h3 id="一、过滤器是什么？有什么？"><a href="#一、过滤器是什么？有什么？" class="headerlink" title="一、过滤器是什么？有什么？"></a>一、过滤器是什么？有什么？</h3><ul>
<li>1、过滤器属于Servlet规范，从2.3版本就开始有了。</li>
<li>2、过滤器就是对访问的内容进行筛选（拦截）。利用过滤器对请求和响应进行过滤<br><img src="http://i.imgur.com/tphTCRE.png" alt=""></li>
</ul>
<h3 id="二、编写步骤和执行过程"><a href="#二、编写步骤和执行过程" class="headerlink" title="二、编写步骤和执行过程"></a>二、编写步骤和执行过程</h3><ul>
<li><p>1、编码步骤：</p>
<ul>
<li><p>a、编写一个类：实现javax.servlet.Filter接口<br><img src="http://i.imgur.com/DHpgddE.png" alt=""></p>
</li>
<li><p>b、配置web.xml，指定需要过滤的资源。（和Servlet的配置相当类似）<br><img src="http://i.imgur.com/F56CJi2.png" alt=""></p>
</li>
</ul>
</li>
<li><p>2、过滤器的执行过程（生命周期）<br>  <img src="http://i.imgur.com/9r0ivIE.png" alt=""></p>
</li>
<li><p>生命周期：</p>
<ul>
<li>诞生：过滤器的实例是在应用被加载时就完成的实例化，并初始化的。</li>
<li>存活：和应用的生命周期一致的。在内存中是单例的。针对拦截范围内的资源访问，每次访问都会调用void doFIlter(request,response.chain)进行拦截。</li>
<li>死亡：应用被卸载。</li>
</ul>
</li>
<li><p>执行过程：<br><img src="http://i.imgur.com/CCogcDR.png" alt=""></p>
</li>
</ul>
<h3 id="三、串联过滤器"><a href="#三、串联过滤器" class="headerlink" title="三、串联过滤器"></a>三、串联过滤器</h3><p>一个过滤器接着另外一个过滤器。执行的顺序<br><img src="http://i.imgur.com/tgw81wN.png" alt=""></p>
<h3 id="四、案例："><a href="#四、案例：" class="headerlink" title="四、案例："></a>四、案例：</h3><ul>
<li>1、解决请求参数（POST）和响应输出的乱码过滤器</li>
<li>2、动态资源不要缓存的过滤器<br>Servlet/JSP：动态资源不要缓存。</li>
<li>3、静态资源控制缓存时间的过滤器</li>
<li>4、用户自动登录过滤器：<br>Base64编码：很重要<br><img src="http://i.imgur.com/P6s0CrO.png" alt=""><h3 id="五、过滤器配置的细节"><a href="#五、过滤器配置的细节" class="headerlink" title="五、过滤器配置的细节"></a>五、过滤器配置的细节</h3><img src="http://i.imgur.com/4BC83KZ.png" alt=""><br><img src="http://i.imgur.com/3Cv7RVb.png" alt=""></li>
</ul>
<h3 id="六、巩固装饰设计模式"><a href="#六、巩固装饰设计模式" class="headerlink" title="六、巩固装饰设计模式"></a>六、巩固装饰设计模式</h3><ul>
<li>一、装饰<ul>
<li>1、编写一个类，实现与被包装类（数据库驱动对Connection的实现）相同的接口。（使这个类和数据库的驱动实现有着相同的行为）</li>
<li>2、定义一个变量，引用被包装类的实例。</li>
<li>3、定义构造方法，传入被包装类的实例。</li>
<li>4、对于要改写的方法，编写自己的代码即可。</li>
<li>5、对于不需要改写的方法，调用原有对象的对应方法。</li>
</ul>
</li>
<li>二、装饰变体（BufferedReader本身就是包装类，对Reader的包装。LineNumberReader，对BufferedReader的包装，还是他的子类）<ul>
<li>1、编写一个类，继承已经是包装类的类。</li>
<li>2、定义一个变量，引用被包装类的实例。</li>
<li>3、定义构造方法，传入被包装类的实例。</li>
<li>4、覆盖掉需要改写的方法</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有了希望，你会产生拒绝; 没有希望，你会接受一切。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、过滤器是什么？有什么？&quot;&gt;&lt;a href=&quot;#一、过滤器是什么？有什么？&quot; class=&quot;headerlink&quot; title=&quot;一、过滤器是
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>jdbc学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/05/03/jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/05/03/jdbc学习笔记/</id>
    <published>2017-05-03T13:43:55.000Z</published>
    <updated>2017-05-03T15:31:09.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>内心存在的东西，就是“因”，外界给予的东西，就是“缘”。<br>因上努力，果上随缘。</p>
</blockquote>
<h3 id="一、JDBC简介"><a href="#一、JDBC简介" class="headerlink" title="一、JDBC简介"></a>一、JDBC简介</h3><ul>
<li>1、JDBC是SUN公司为了简化操作数据推出一套规范。数据库厂商的驱动就是对JDBC的实现。</li>
<li>2、Java Data Base Connectivity（java数据库连接），它主要由接口组成。<br>java.sql.<em>    javax.sql.</em>   JDK中<br>数据库的驱动jar包</li>
</ul>
<h3 id="二、JDBC的编码步骤"><a href="#二、JDBC的编码步骤" class="headerlink" title="二、JDBC的编码步骤"></a>二、JDBC的编码步骤</h3><ul>
<li>0、前提：拷贝数据库的驱动到构建路径中（classpath）</li>
<li>1、注册驱动</li>
<li>2、获取与数据库的链接</li>
<li>3、创建代表SQL语句的对象</li>
<li>4、执行SQL语句</li>
<li>5、如果是查询语句，需要遍历结果集</li>
<li>6、释放占用的资源</li>
</ul>
<p><img src="http://i1.piimg.com/567571/9c73f966a51950fe.png" alt=""></p>
<h3 id="三、事务入门（重点）"><a href="#三、事务入门（重点）" class="headerlink" title="三、事务入门（重点）"></a>三、事务入门（重点）</h3><ul>
<li>1、MySQL：每一条语句都属于独立事务,默认自动管理的。</li>
<li>2、开启事务：start transaction;   日后的语句都会处于同一个事务之中。<br>提交事务：commit;<br>回滚事务：rollback;</li>
<li>3、JDBC如何控制事务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">conn.setAutoCommit(<span class="number">0</span>);<span class="comment">//修改系统非自动提交。</span></div><div class="line">conn.commit();<span class="comment">//事务提交</span></div><div class="line">conn.rollback();<span class="comment">//事务回滚</span></div><div class="line">SavePoint sp=con.setSavePoint();<span class="comment">//设置保存点</span></div><div class="line">conn.rollback(sp);<span class="comment">//返回保存点</span></div><div class="line">conn.setTransactionIsolation();<span class="comment">//设置隔离级别</span></div><div class="line">conn.getTransactionIsolation();<span class="comment">//获取隔离级别</span></div></pre></td></tr></table></figure>
<ul>
<li>其中隔离级别的设置如下：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">设定事务的隔离级别：con.setTransactionIsolation(Connection.isolationLevel);</div><div class="line">四种隔离级别： </div><div class="line">con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);<span class="comment">//最底级别：只保证不会读到非法数据，上述3个问题有可能发生 </span></div><div class="line">con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED); <span class="comment">//默认级别：可以防止脏读 </span></div><div class="line">con.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);<span class="comment">//可以防止脏读和不可重复读取 </span></div><div class="line">con.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE); <span class="comment">//最高级别：防止上述3种情况，事务串行执行</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="四、事务的特性（重点。面试）"><a href="#四、事务的特性（重点。面试）" class="headerlink" title="四、事务的特性（重点。面试）"></a>四、事务的特性（重点。面试）</h3><ul>
<li>1、事务的特性：<br>原子性：处于事务中的多条语句是不可分割的。<br>一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。比如：转账，转账前A+B=2000，转账后A+B=2000<br>隔离性：多线程并发。一个事务不能被其他线程中的事务所打扰。<br>持久性：事务一旦提交，永久保存起来。</li>
<li>2、事务的隔离级别：属于事务的。都已开启了事务为前提。</li>
<li><p>不考虑事务的隔离级别，会出现以下情况（是错的）</p>
<ul>
<li>脏读：一个线程中的事务读到了另外一个线程中未提交的数据。</li>
<li>不可重复读：一个线程中的事务读到了另外一个线程中已经提交的update的数据。</li>
<li>虚读：一个线程中的事务读到了另外一个线程中已经提交的insert的数据。</li>
</ul>
</li>
<li><p>要想避免以上现象，通过更改事务的隔离级别来避免：</p>
<ul>
<li>READ UNCOMMITTED 脏读、不可重复读、虚读有可能发生。</li>
<li>READ COMMITTED 避免脏读的发生，不可重复读、虚读有可能发生。</li>
<li>REPEATABLE READ 避免脏读、不可重复读的发生，虚读有可能发生。</li>
<li>SERIALIZABLE 避免脏读、不可重复读、虚读的发生。</li>
</ul>
</li>
</ul>
<p>级别依次升高，效率依次降低。<br>MySQL：默认REPEATABLE READ<br>ORACLE：默认READ COMMITTED</p>
<p>MySQL：<br>select @@tx_isolation;//查看当前的隔离级别<br>set transaction isolation level 级别;// 设置当前的事务隔离级别</p>
<h3 id="五、数据库连接池原理：（理解）"><a href="#五、数据库连接池原理：（理解）" class="headerlink" title="五、数据库连接池原理：（理解）"></a>五、数据库连接池原理：（理解）</h3><p><img src="http://i4.buimg.com/567571/1f88728dcfd4cbbd.png" alt=""></p>
<h3 id="六、编程的难点：（设计模式）"><a href="#六、编程的难点：（设计模式）" class="headerlink" title="六、编程的难点：（设计模式）"></a>六、编程的难点：（设计模式）</h3><p>难点：用一个实现了javax.sql.DataSource类的实例时，用户如果调用Connection.close()方法，会把链接关闭，失去了连接池的意义。<br>明确一个问题：用户得到Connection的实现是：数据库驱动对Connection接口的实现。因此，调用的close方法都是数据库驱动的，它会把链接给关闭。（这不是我们要的，我们要把该链接换回池中）。</p>
<p>解决方案：改写驱动原有的close方法。对已知类的某个/某些方法进行功能上的改变，有以下几种编码方案：</p>
<ul>
<li>a、继承：此处行不通。<br>到底针对哪个驱动的实现写子类（很多）<br>数据库驱动对Connection接口的实现类，不允许被继承<br>丢失了原有对象的信息。捡了芝麻丢了西瓜。</li>
<li><p>b、装饰（包装）设计模式：（基础IO）<br>保持被包装对象的原有信息，又可以对某个/某些方法进行改写。<br>口诀：<br>1、编写一个类，实现与被包装类（数据库驱动对Connection的实现）相同的接口。（使这个类和数据库的驱动实现有着相同的行为）<br>2、定义一个变量，引用被包装类的实例。<br>3、定义构造方法，传入被包装类的实例。<br>4、对于要改写的方法，编写自己的代码即可。<br>5、对于不需要改写的方法，调用原有对象的对应方法。</p>
</li>
<li><p>c、默认适配器：（为了后来做准备）<br><img src="http://i1.piimg.com/567571/6bdaa625e79af855.png" alt=""><br><img src="http://i2.muimg.com/567571/0d525673562314e6.png" alt=""></p>
</li>
<li><p>d、动态代理：（很重要 AOP–Aspect-Oriented Programming 核心技术）<br>    基于接口的动态代理：Proxy<br>如果一个类没有实现任何的接口，此种代理就不能使用了。<br>    基于子类的动态代理：CGLIB<br>前提：被代理类的要求<br>1、不能是final的<br>2、必须是public的<br>比如普通的JavaBean就可能没有实现任何的接口。代理类是被代理类的子类。<br><img src="http://i2.muimg.com/567571/fb6e253d772a61c1.png" alt=""></p>
</li>
</ul>
<h3 id="七、数据库操作框架"><a href="#七、数据库操作框架" class="headerlink" title="七、数据库操作框架"></a>七、数据库操作框架</h3><ul>
<li>1、ORM：Object Relation Mapping<br>Hibernate：非常流行<br>JPA：Java Persistent API.ORM标准<br>MyBatis：2010年开始。之前叫做iBatis（重视）</li>
<li>2、JDBC封装框架<br>DBUtils<br>Spring JDBC Template</li>
</ul>
<h3 id="八、实际开发中事务如何管理-非常好"><a href="#八、实际开发中事务如何管理-非常好" class="headerlink" title="八、实际开发中事务如何管理(非常好)"></a>八、实际开发中事务如何管理(非常好)</h3><ul>
<li>1、写4个版本的代码：AOP</li>
<li>2、ThreadLocal（很重要）<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//特点：一个线程存的东西，只有该线程才能取出来。线程局部变量。</span></div><div class="line"><span class="comment">//模拟</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span></span>&#123;</div><div class="line">	<span class="comment">//类似Map的结构</span></div><div class="line">	<span class="keyword">private</span> Map&lt;Runnable,Object&gt; map = <span class="keyword">new</span> HashMap&lt;Runnable,Object&gt;();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">		map.put(Thread.currentThread(),obj);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</div><div class="line">		map.remove(Thread.currentThread());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">		map.get(Thread.currentThread());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;内心存在的东西，就是“因”，外界给予的东西，就是“缘”。&lt;br&gt;因上努力，果上随缘。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、JDBC简介&quot;&gt;&lt;a href=&quot;#一、JDBC简介&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>人生所有的路，都是必经之路</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/04/30/%E4%BA%BA%E7%94%9F%E6%89%80%E6%9C%89%E7%9A%84%E8%B7%AF%EF%BC%8C%E9%83%BD%E6%98%AF%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/04/30/人生所有的路，都是必经之路/</id>
    <published>2017-04-30T07:05:15.000Z</published>
    <updated>2017-04-30T16:14:06.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这段时间在缘分之下，得到了鬼脚七的这本《人生所有的路，都是必经之路》。然后通过观看书籍以及自己生活中的所遇内心有比较多复杂、自认为比较有意义的想法吧。我也怕自己会在随后的生活中淡忘，因为普通人是没办法一开始就从想法到行动吧，至少现如今我还处于这个状态吧。本来我也打算分篇去记录我的那些感悟，但是想着我的那些逻辑想法可能也比较随性，所以就统一在着在这一篇博客下持续更新吧。</p>
</blockquote>
<h3 id="（一）2017-04-02-15-05"><a href="#（一）2017-04-02-15-05" class="headerlink" title="（一）2017-04-02 15:05"></a>（一）2017-04-02 15:05</h3><p>好不易盼来了一个假期吧，开始是兴奋，兴奋过后是烦恼，烦恼这几天的假期如何度过，心中的第一想法就是不想和放假之前一样的度过。因为觉得自己放假前过的这日子还是太单调了，三点一线想来点不一样的元素，其实更直白贴近内心的原因或许就是放假了大家应该都去玩，自己不想一个人显的太孤单吧。是我害怕别人发现我那种状态吧，毕竟以前的假期是繁忙的希望有分身之术吧，既要想着陪女朋友，又要计划陪兄弟哥们。所以我在当晚就赶到我星沙那边的朋友那边去了，但是当我坐在过那边的车上我又是感觉对学校是那样的不舍，我又开始怀念学校这种固定的生活吧，我估计是被这个套子给套住了。总结：我以后做事情应该干脆果断点，在做一方面的事情，别在枯燥难受的时候又想着原先的快乐，出发点应该想清楚是不是自己真的喜欢，如果喜欢这一路都痛快的去追逐，过往不恋，记住第一性初衷。</p>
<h3 id="（二）2017-04-19-22-31"><a href="#（二）2017-04-19-22-31" class="headerlink" title="（二）2017-04-19 22:31"></a>（二）2017-04-19 22:31</h3><p>这段时间是真的比较急躁吧，越想做好一些事情越不知道如何下手，越想安静下来越浮动，每天极像充实又感觉什么没做，感觉不会在乎的事情又老是在眼前浮现，我似乎在等待着什么蓄势待发，可是现在流失的还比较多吧。讲真我也不懂对错，但是我也不会走退路的吧。有太多的未知就让他未来慢慢来吧。我近期也是用鬼脚七那句话反复对自己说，不知道不能解决的就交给佛陀吧，佛会解决的。其实是吧，不管你们质疑的佛陀是否存在，但我是有了寄托，让我内心没那么沉重，佛陀就帮我渡了些苦，何必又去为佛陀的是否存在平添苦恼呢，而且我也相信又佛陀菩萨，我们每个人都是佛陀吧，只是你没有去发现。我也真的得自律自己，一味的想着去模范佛陀做过的事，却忘却了心境的同步。从身边开始吧，做自己的佛陀。</p>
<h3 id="（三）2017-04-30-22-16"><a href="#（三）2017-04-30-22-16" class="headerlink" title="（三）2017-04-30 22:16"></a>（三）2017-04-30 22:16</h3><p>时间真是让人触不及防的东西吧。一转眼一个月的赛前培训结束，比赛也比完了。先不管收获或者留下多少遗憾，还是理性的分析总结和纪念下这段时光吧，也如标题所说。人生所有的路都是必经之路。</p>
<p>环顾着一个月其实可能最紧张的可能就是比赛的前一天了，比赛前一天把能想到能顾及的知识点都过了一遍，甚至挑了一些选择性背下来，但这样并不是想说我准备的多么充分，而是到了那个时候才感觉自己浪费了太多的时间，当然我转念一想其实这一辈子做的所有事其实在时间的资源上大家都是公平的，但是每个人能抓住的时间却出入特别大，大多比赛都会喜欢说“赛出风格，赛出水平”我觉得我们这次也赛出了风格、赛出了我们的水平吧，平时我们付出了多少，在比赛上就回馈了多少。赛后也一直在幻想如果侥幸进了国赛那应该多美好。。。。但转念一想也不好吧，如果真的让我们这样侥幸进了国赛，我们心里也只会觉得对手太垃圾，而不是我们有多么厉害，哈哈 ，大实话。这样也挺好，不及第一名的一半，这个现实真的很残酷好嘛，但没错这也告诫我们，在同龄同一件事上有人比我们做的更加的优秀这么多。这次要好好接受这个教训吧，也留下了遗憾，其实我还是感觉我们其实挺棒的，但还需要更加努力，一起更精进点。其实这个地方上次我也留了个遗憾在这里，上次坐了几个小时车跑到望城为了去靖港古镇，结果住了一天，靖港古镇没有去成。后面回到这个地方就有点物是人非的感觉，而且可能永远也不会去完成这个事情了。但也有感动的，上次去莫名的巧，除了在那学校的小贵，老熊和发卵在，小文和火鸟也在那里，上次热热闹闹的喝了一场（我被套路灌醉。。。），这次去小贵还是赛场负责人，俩人比完赛叫上老熊又去喝了一场。老感觉。大家这么就没见面都没变。哈哈戒了这么久的烟，我知道他们这要破了，我当时也担心估计到学校也会忍不住继续抽起来吧，但是是我多虑了，人还是该随性点的时候久随性点。其实也真的在我不同的时期能交到这些朋友，每个时期的朋友都像我人生的一次还原点，为什么这么说呢，和真正的朋友吧。我希望以前怎么玩怎么开心的过，当我们见面时，就像曾经一样的过。谁也不要让大家感觉自己变了。老铁们，我们一起记住我们的这段回忆，记住我们这些简单的快乐，我希望不管过去多久，以后再次见面我多么沧桑，记住你陪我走过那段时光，当我们再次见面时我依旧会那么年轻。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这段时间在缘分之下，得到了鬼脚七的这本《人生所有的路，都是必经之路》。然后通过观看书籍以及自己生活中的所遇内心有比较多复杂、自认为比较有意义的想法吧。我也怕自己会在随后的生活中淡忘，因为普通人是没办法一开始就从想法到行动吧，至少现如今我还处于这个状
    
    </summary>
    
    
      <category term="观看与感悟" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/%E8%A7%82%E7%9C%8B%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>AChartEngine绘画框架</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/28/AChartEngine%E7%BB%98%E7%94%BB%E6%A1%86%E6%9E%B6/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/28/AChartEngine绘画框架/</id>
    <published>2017-03-28T13:47:00.000Z</published>
    <updated>2017-03-28T14:30:05.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天是比赛准备的第二天，这几天主要在学习绘图方面的知识，今天学习了一个框架。这个是Android系统上用于绘图的框架，支持绘制折线图、面积图、散点图、时间图、进度表、条状图、饼图、圆环图等等。不过这个框架现在不在更新了，但比赛用到的还是这个框架，在学习过程中也发现了一个更好绘图框架MPAndroidChart，后续找时间学习并更新资料到博客。</p>
</blockquote>
<h3 id="AChartEngine的概述与分析"><a href="#AChartEngine的概述与分析" class="headerlink" title="AChartEngine的概述与分析"></a>AChartEngine的概述与分析</h3><p><strong>类之间的关系</strong><br><img src="http://i.imgur.com/oNSMJNx.jpg" alt=""></p>
<ul>
<li><p><strong>1. ChartDemo这个类是整个应用程序的入口,运行之后的效果显示一个list.</strong></p>
</li>
<li><p><strong>2. IDemoChart接口,这个接口定义了三个方法。</strong></p>
<ul>
<li><p>getName()返回值是listitem上显示的标题;</p>
</li>
<li><p>getDesc()返回值是listitem上显示的描述内容.</p>
</li>
<li><p>excute(context)返回值是一个Intent,当点击listitem后跳转到此Intent.</p>
</li>
</ul>
</li>
<li><p><strong>3. AbstractDemoChart类是一个抽象类,实现接口IDemoChart接口,这个类中封装了构建DataSet和renderer的方法,目的快速构建我们的dataset和renderer.这个类具体提供了哪些方法呢?见下图.至于为什么要进行这样的封装看完4中ChartFactory.get…Intent()方法的参数类型后您就明白了.</strong><br><img src="http://i.imgur.com/wCEAM0Z.jpg" alt=""></p>
</li>
<li><p><strong>4.  其他的以*Chat结尾的类大都继承自AbstractDemoChart这个类实现了接口IDemoChart.我们可以重点看一下execute(context)方法,分析之后发现这个方法中构建Intent的步骤大同小异,第一步构建dataset,第二步构建renderer,第三步调用ChartFactory.get…Intent()方法或ChartFactory.get…View()方法,二者的区别在于一个返回Intent,这个intent可以启动一个特定的activity,另一个返回GraphicalView,对这个GraphicalView可以灵活设置也可以仅作为一部分显示在任何activity上.对于ChartFactory.get…Intent()上的参数activityTitle是指设置显示在activity上的标题.</strong></p>
</li>
</ul>
<h3 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h3><pre><code>private void showChart(Context context,LinearLayout layout) {
    XYMultipleSeriesDataset mDataset = getDataset();
    XYMultipleSeriesRenderer mRenderer = getRenderer();
    GraphicalView view = ChartFactory.getLineChartView(context, mDataset, mRenderer);
    layout.addView(view);
}

public XYMultipleSeriesDataset getDataset() {
    XYMultipleSeriesDataset seriesDataset = new XYMultipleSeriesDataset();
    XYSeries xySeries = new XYSeries(&quot;&quot;);
    xySeries.add(1, 36);
    xySeries.add(2, 30);
    xySeries.add(3, 27);
    xySeries.add(4, 29);
    xySeries.add(5, 34);
    xySeries.add(6, 28);
    xySeries.add(7, 33);
    seriesDataset.addSeries(xySeries);
    return seriesDataset;
}

public XYMultipleSeriesRenderer getRenderer() {
    /*描绘器，设置图表整体效果，比如x,y轴效果，缩放比例，颜色设置*/
    XYMultipleSeriesRenderer seriesRenderer = new XYMultipleSeriesRenderer();

    seriesRenderer.setMargins(new int[]{100,100,marginBottom,0});//设置外边距，顺序为：上左下右
    //坐标轴设置
    seriesRenderer.setAxisTitleTextSize(16);
    seriesRenderer.setXAxisMax(8);
    seriesRenderer.setXAxisMin(0);
    seriesRenderer.setYAxisMax(800);
    seriesRenderer.setYAxisMin(0);
    seriesRenderer.setAxesColor(Color.BLACK);
    //颜色设置
    seriesRenderer.setMarginsColor(Color.argb(0x00,0x01,0x01,0x01));
    //缩放设置
    seriesRenderer.setZoomButtonsVisible(true);//设置缩放按钮是否可见
    seriesRenderer.setZoomEnabled(true); //图表是否可以缩放设置
    seriesRenderer.setZoomInLimitX(7);
    seriesRenderer.setZoomRate(1);
    //图表移动设置
    seriesRenderer.setPanEnabled(false);
    //坐标轴标签设置
    seriesRenderer.setLabelsTextSize(44);//设置标签字体大小
    seriesRenderer.setXLabelsAlign(Paint.Align.CENTER);
    seriesRenderer.setYLabelsAlign(Paint.Align.LEFT);
    seriesRenderer.setXLabels(0);//显示的x轴标签的个数
    seriesRenderer.addXTextLabel(1,&quot;2&quot;);
    seriesRenderer.addXTextLabel(2,&quot;4&quot;);
    seriesRenderer.addXTextLabel(3,&quot;6&quot;);
    seriesRenderer.addXTextLabel(4,&quot;8&quot;);
    seriesRenderer.setPointSize(13);//设置坐标点大小

    /*某一组数据的描绘器，描绘该组数据的个性化显示效果，主要是字体跟颜色的效果*/
    XYSeriesRenderer xySeriesRenderer = new XYSeriesRenderer();
    xySeriesRenderer.setPointStrokeWidth(40);
    xySeriesRenderer.setColor(Color.GREEN);
    xySeriesRenderer.setDisplayChartValues(true);
    xySeriesRenderer.setChartValuesTextSize(42);

    seriesRenderer.addSeriesRenderer(xySeriesRenderer);
    return seriesRenderer;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天是比赛准备的第二天，这几天主要在学习绘图方面的知识，今天学习了一个框架。这个是Android系统上用于绘图的框架，支持绘制折线图、面积图、散点图、时间图、进度表、条状图、饼图、圆环图等等。不过这个框架现在不在更新了，但比赛用到的还是这个框架，在
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>canvas绘图</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/27/canvas%E7%BB%98%E5%9B%BE/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/27/canvas绘图/</id>
    <published>2017-03-27T13:55:50.000Z</published>
    <updated>2017-04-12T07:33:37.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天是赛前培训的第一天，也是大学以来第一次上课迟到，可能是因为比赛多了几项特权，所以就特别迫切的想使用一下吧。但是过后心里更多的是负罪感而不是新鲜的快感吧。这次比赛应该会是场很棒的经历吧，不管是为了虚荣还使命感，我都应该好好的完成 它吧。</p>
</blockquote>
<h3 id="如何得到1个Canvas对象"><a href="#如何得到1个Canvas对象" class="headerlink" title="如何得到1个Canvas对象"></a>如何得到1个Canvas对象</h3><ul>
<li>之前提到的onDraw方法的入口参数就是Canvas，我们用变量承载它，就可以使用，而我们操作这个Canvas最终的效果会直接反应在这个View上。</li>
<li>SurfaceView是View的继承了，其内部有专门的线程来完成画图的工作，而不用像View一样需要等待刷新，主要用在游戏和高品质动画方面。既然是View的继承类，SurfaceView自然可以获取到Canvas的对象，方式是通过调用SurfaceView的好基友SurfaceHolder的lockCanvas()方法。</li>
<li>当然，除了获取View或SurfaceView自带的现成的Canvas对象，我们还可以自己创建。从4大基本要素我们就可以知道，1个Canvas对象一定要结合1个Bitmap对象。所以一定要为新建的Canvas对象设置1个Bitmap对象。</li>
</ul>
<h3 id="Canvas能画些什么"><a href="#Canvas能画些什么" class="headerlink" title="Canvas能画些什么"></a>Canvas能画些什么</h3><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>Canvas内部维持了一个mutable Bitmap，所以我们可以用颜色来填充整个Bitmap。而填充的范围受限于clip的范围。</p>
<ul>
<li>drawRGB(int r, int g, int b) ： r-红色要素（0~255），g-绿色要素（0~255），b-蓝色要素（0~255）。</li>
<li>drawARGB(int a, int r, int g, int b)：a-透明度（0~255），r-红色要素（0~255），g-绿色要素（0~255），b-蓝色要素（0~255）。</li>
<li>drawColor(int color)：这里的color要为16进制的颜色号，例如：0xFF000000，共8位，两位一组从左到右分别为ARGB，具体含义同上。若要使用“#FF000000”这样的色号，可以调用Color.parseColor(String colorString)方法来进行转换。</li>
<li>drawColor(int color, PorterDuff.Mode mode)：color同上，PorterDuff.Mode比较有意思，有很多种模式，每一种模式都会有特定的效果，感兴趣的朋友可以自行了解一下。</li>
<li>drawPaint(Paint paint)：Canvas同样可以用画笔来填充Bitmap，当然也受限于clip的范围。<h4 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h4><code>canvas.drawArc</code>（扇形）<br><code>canvas.drawCircle</code>（圆）<br><code>canvas.drawOval</code>（椭圆）<br><code>canvas.drawLine</code>（线）<br><code>canvas.drawPoint</code>（点）<br><code>canvas.drawRect</code>（矩形）<br><code>canvas.drawRoundRect</code>（圆角矩形）<br><code>canvas.drawVertices</code>（顶点）<br><code>cnavas.drawPath</code>（路径）<h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><code>canvas.drawBitmap</code>（位图）<br><code>canvas.drawPicture</code>（图片）<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><code>canvas.drawText</code><h4 id="小案例（折线图）"><a href="#小案例（折线图）" class="headerlink" title="小案例（折线图）"></a>小案例（折线图）</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//主曲线图的名称</span></div><div class="line">	<span class="keyword">private</span> String majorName;</div><div class="line">	<span class="comment">//主曲线图的点集合</span></div><div class="line">	<span class="keyword">private</span> LinkedList&lt;Integer&gt; majorValueList;</div><div class="line">	<span class="comment">//主曲线图y轴最小值</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> majorMin;</div><div class="line">	<span class="comment">//主曲线图y轴最大值</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> majorMax;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> marginBottom;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> marginLeft;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context,ChartPagerBean chartPagerBean)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context);</div><div class="line">		<span class="keyword">this</span>.majorName = chartPagerBean.majorName;</div><div class="line">		<span class="keyword">this</span>.majorValueList = chartPagerBean.majorValueList;</div><div class="line">		<span class="keyword">this</span>.majorMin = chartPagerBean.majorMin;</div><div class="line">		<span class="keyword">this</span>.majorMax = chartPagerBean.majorMax;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">		majorValueList.add(<span class="number">37</span>);</div><div class="line">		majorValueList.add(<span class="number">84</span>);</div><div class="line">		majorValueList.add(<span class="number">94</span>);</div><div class="line">		majorValueList.add(<span class="number">6</span>);</div><div class="line">		majorValueList.add(<span class="number">64</span>);</div><div class="line">		majorValueList.add(<span class="number">74</span>);</div><div class="line">		majorValueList.add(<span class="number">85</span>);</div><div class="line">		majorValueList.add(<span class="number">95</span>);</div><div class="line">		majorValueList.add(<span class="number">59</span>);</div><div class="line"></div><div class="line">		marginBottom = <span class="keyword">this</span>.getBottom() - <span class="number">100</span>;</div><div class="line">		marginLeft = <span class="number">100</span>;</div><div class="line"></div><div class="line">		Paint mPaint = <span class="keyword">new</span> Paint();</div><div class="line">		<span class="comment">//初始化y轴</span></div><div class="line">		mPaint.setColor(Color.BLACK);</div><div class="line">		mPaint.setStrokeWidth(<span class="number">6</span>);</div><div class="line">		canvas.drawLine(marginLeft, marginLeft, marginLeft, marginBottom,mPaint);</div><div class="line">		<span class="comment">//初始化x轴</span></div><div class="line">		canvas.drawLine(marginLeft, marginBottom, <span class="keyword">this</span>.getRight() - <span class="number">20</span>, marginBottom, mPaint);</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">			mPaint.setTextSize(<span class="number">40</span>);</div><div class="line">			mPaint.setColor(Color.WHITE);</div><div class="line">			String[] y=&#123;<span class="string">"800"</span>,<span class="string">"600"</span>,<span class="string">"400"</span>,<span class="string">"200"</span>,<span class="string">"0"</span>&#125;;</div><div class="line">			canvas.drawText(y[i], marginLeft -<span class="number">30</span>, marginLeft +(<span class="number">200</span>*i),mPaint);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">			mPaint.setTextSize(<span class="number">40</span>);</div><div class="line">			mPaint.setColor(Color.WHITE);</div><div class="line">			String[] y=&#123;<span class="string">""</span>,<span class="string">"2"</span>,<span class="string">"4"</span>,<span class="string">"6"</span>,<span class="string">"8"</span>&#125;;</div><div class="line">			canvas.drawText(y[i],marginLeft+(i*<span class="number">400</span>), marginBottom +<span class="number">40</span>,mPaint);</div><div class="line">		&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">		drawPint(mPaint,canvas,majorValueList);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPint</span><span class="params">(Paint mPaint, Canvas canvas, LinkedList&lt;Integer&gt; majorValueList)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;majorValueList.size();i++)&#123;</div><div class="line">			<span class="keyword">int</span> value = majorValueList.get(i);</div><div class="line">			<span class="comment">//majorMin=10;</span></div><div class="line">			mPaint.setColor(Color.RED);</div><div class="line">			<span class="keyword">if</span> (value&lt;majorMin)&#123;</div><div class="line">				mPaint.setColor(Color.GREEN);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			canvas.drawCircle(marginLeft+(i*<span class="number">200</span>), marginLeft+<span class="number">800</span>-value, <span class="number">18</span>,mPaint);<span class="comment">// 小圆</span></div><div class="line">			canvas.drawText(value+<span class="string">""</span>,marginLeft+(i*<span class="number">200</span>),marginLeft+<span class="number">800</span>-value-<span class="number">40</span>,mPaint);</div><div class="line">			<span class="keyword">if</span> (i&gt;<span class="number">0</span>)&#123;</div><div class="line">				mPaint.setColor(Color.BLUE);</div><div class="line">				<span class="keyword">int</span> lastValue = majorValueList.get(i-<span class="number">1</span>);</div><div class="line">				canvas.drawLine(marginLeft+((i-<span class="number">1</span>)*<span class="number">200</span>), marginLeft+<span class="number">800</span>-lastValue,marginLeft+(i*<span class="number">200</span>), marginLeft+<span class="number">800</span>-value,mPaint);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Canvas的保存和回滚"><a href="#Canvas的保存和回滚" class="headerlink" title="Canvas的保存和回滚"></a>Canvas的保存和回滚</h3><p>为了配合Canvas本身的变换操作，Canvas提供了保持当前状态和回滚的方法。来个小例子。<br>我们准备画一个表盘，那么我们就有两种实现的思路：</p>
<ul>
<li><p>表盘上有60个刻度，每个刻度之间间隔6°，这是有规律的，那么我们就可以利用三角函数的知识来把刻度的两个坐标求出来，再利用drawLine画到Canvas上。考验你逻辑思维和数学功底的时候到了，不用仔细想就能知道这个方法有点麻烦。</p>
</li>
<li><p>如果不喜欢第一种方法，那么我们可以尝试一下这一种。Canvas提供了旋转操作的方法，也提供了保存和回复状态的方法，那么我们就用这些搭配起来。首先我在（100，0）和（100，10）两个坐标之间画一条竖线，很简单，整点的刻度就出来了。之后先将Canvas的状态保存起来，在（100，0）和（100，10）两个坐标之间画一条竖线，回复Canvas的状态，一分钟的刻度就出来了。以此类推，思路是不是很简单。</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
     super.onDraw(canvas);

     for (int i = 0; i &lt; 360; i = i + 6) {
        canvas.save();
         canvas.rotate(i, 100, 100);
         canvas.drawLine(100, 0, 100, 10, new Paint());
         canvas.restore();
     }
}
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天是赛前培训的第一天，也是大学以来第一次上课迟到，可能是因为比赛多了几项特权，所以就特别迫切的想使用一下吧。但是过后心里更多的是负罪感而不是新鲜的快感吧。这次比赛应该会是场很棒的经历吧，不管是为了虚荣还使命感，我都应该好好的完成 它吧。&lt;/p&gt;

    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JSP的学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/16/JSP%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/16/JSP的学习笔记/</id>
    <published>2017-03-16T13:02:00.000Z</published>
    <updated>2017-03-20T03:47:33.758Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、JSP简介"><a href="#一、JSP简介" class="headerlink" title="一、JSP简介"></a>一、JSP简介</h3><blockquote>
<p>也是SUN公司推出的开发动态web资源的技术，属于JavaEE技术之一。由于原理上是Servlet， 所以JSP/Servlet在一起。</p>
</blockquote>
<h3 id="二、HTML、Servlet和JSP"><a href="#二、HTML、Servlet和JSP" class="headerlink" title="二、HTML、Servlet和JSP"></a>二、HTML、Servlet和JSP</h3><ul>
<li>1、HTML：静态页面，不能包含java代码，只能有HTML有关的标记</li>
<li>2、Servlet：写java代码，做页面的输出，不是很方便（开发效率很低）</li>
<li>3、JSP：HTML+java</li>
</ul>
<h3 id="三、JSP的原理及生命周期"><a href="#三、JSP的原理及生命周期" class="headerlink" title="三、JSP的原理及生命周期"></a>三、JSP的原理及生命周期</h3><ul>
<li>1、JSP就是Servlet，学习好JSP的关键（语法），时刻想到他对应的Servlet。<br><img src="http://i1.piimg.com/4851/538d9bbbb73148d7.png" alt=""></li>
<li>时常翻阅JSP对应的Servlet源码<h3 id="四、JSP的语法"><a href="#四、JSP的语法" class="headerlink" title="四、JSP的语法"></a>四、JSP的语法</h3></li>
</ul>
<h4 id="4-1模板元素"><a href="#4-1模板元素" class="headerlink" title="4.1模板元素"></a>4.1模板元素</h4><ul>
<li>指JSP中的那些HTML。开发时先编写模板元素，因为他们决定页面的外观。</li>
</ul>
<h4 id="4-2Java程序片段"><a href="#4-2Java程序片段" class="headerlink" title="4.2Java程序片段"></a>4.2Java程序片段</h4><p>语法：&lt;%java程序%&gt;<br>出现在JSP对应Servlet的service方法中。<br>&lt;%声明的变量：局部%&gt;</p>
<h4 id="4-3Java表达式"><a href="#4-3Java表达式" class="headerlink" title="4.3Java表达式"></a>4.3Java表达式</h4><p>语法：&lt;%=表达式%&gt;</p>
<h4 id="4-4JSP声明"><a href="#4-4JSP声明" class="headerlink" title="4.4JSP声明"></a>4.4JSP声明</h4><p>语法：&lt;%!</p>
<p>%&gt;<br>作用：定义JSP对应Serlvet的成员（变量和方法、静态方法）</p>
<p>注意：开发中很少用。面试和考试经常考。</p>
<h4 id="4-5JSP注释"><a href="#4-5JSP注释" class="headerlink" title="4.5JSP注释"></a>4.5JSP注释</h4><p>语法：&lt;%–这是注释–%&gt;</p>
<p>作用：注释掉的代码，JSP引擎不会翻译到Servlet源码中。要注意和HTML注释的区别。</p>
<h4 id="4-6JSP指令："><a href="#4-6JSP指令：" class="headerlink" title="4.6JSP指令："></a>4.6JSP指令：</h4><ul>
<li><strong>简介：</strong><br>指令是为JSP引擎设计的。而只是告诉引擎如何处理JSP页面中的其余部分（非指令部分）；<br>基本语法格式：&lt;%@指令 属性1=”值1” ….%&gt;.<br>一般把指令放在JSP页面的顶部（不是必须的）<br>指令的属性可以写在一个指令的中，也可以分开写：比如：<br>&lt;%@指令 属性1=”值1” 属性2=”值2”%&gt;.<br>等价于：<br>&lt;%@指令 属性1=”值1” %&gt;.<br>&lt;%@指令 属性2=”值2”%&gt;</li>
<li><strong>page：</strong></li>
<li>属性：<br><code>language：</code>告知引擎，脚本用的是java。默认java，支持java。不写也行。<br><code>extends：</code>告知引擎，JSP对应的Servlet的父类是哪个。不需要写，也不要改。<br><code>*import：</code>告知引擎，导入哪些包。<br>注意：引擎自动导入：java.lang.<em>;javax.servlet.</em>;javax.servlet.http.<em>;javax.servlet.jsp.</em>;</li>
</ul>
<p>导入的形式：<br>&lt;%@page import=”java.util.Date,java.util.UUID”%&gt;或者：<br>&lt;%@page import=”java.util.Date”%&gt;<br>&lt;%@page import=”java.util.UUID”%&gt;  用Eclipse：Alt+/ 自动导入<br><code>*session:</code>告知引擎是否产生HttpSession对象，即是否在代码中调用request.getSession()。默认值true。<br>buffer：JspWriter用于输出JSP的内容到页面上。告知引擎，设定他的缓存大小。默认8Kb。<br><code>*errorPage：</code>告知引擎，当前页面出现了异常，应该转发到哪个页面上（路径写法：/代表着当前应用）<br>配置全局错误页面：web.xml<br><img src="http://i1.piimg.com/4851/b62efc127800cb3b.png" alt=""><br><code>*isErrorPage:</code>告知引擎，是否抓住异常。如果该属性为true，页面中就可以使用exception隐含对象，打印异常的详细信息。<br><code>*contentType：</code>告知引擎，响应正文的MIME类型。<br>contentType=”text/html;charset=UTF-8”<br>相当于response.setContentType(“&lt;%=exception.getMessage() %&gt;”);<br><code>*pageEncoding:</code>告知引擎，翻译JSP时（要从磁盘上读JSP文件）所用的码表。<br><img src="http://i1.piimg.com/4851/a6c6554e67d40bff.png" alt=""><br>pageEncoding=”UTF-8”:相当于，告知了引擎用UTF-8读jsp，还response.setContentType(“text/html;charset=UTF-8”);<br><code>*isELIgnored:</code>告知引擎，是否忽略EL表达式。默认值是false，不忽略。</p>
<p>总结：属性众多。一般都用的默认值。用起来很简单，最简单的形式：<br><code>&lt;%@ page  pageEncoding=&quot;UTF-8&quot;%&gt;</code></p>
<ul>
<li><p><strong>include：</strong><br>包含<br>属性：file，以”/”开头，就代表着当前应用。</p>
</li>
<li><p><strong>taglib:</strong><br>引入外部的标签。<br>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core" target="_blank" rel="external">http://java.sun.com/jsp/jstl/core</a>“ prefix=”c”%&gt;</p>
</li>
</ul>
<p>uri：外部的标签的uri地址，好比名称空间<br>prefix:前缀。</p>
<h3 id="五、JSP中的转发和包含"><a href="#五、JSP中的转发和包含" class="headerlink" title="五、JSP中的转发和包含"></a>五、JSP中的转发和包含</h3><ul>
<li>1、转发：<br><code>&lt;jsp:forward page=&quot;/10forward.jsp&quot;&gt;&lt;/jsp:forward&gt;</code><br>JSP的内置标签。</li>
<li>2、参数：不能单独使用<br>向目标传递请求参数</li>
<li>3、包含：（面试题）<br>静态包含：<a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x25;&#64;&#105;&#110;&#99;&#108;&#x75;&#100;&#101;&#37;">&#x25;&#64;&#105;&#110;&#99;&#108;&#x75;&#100;&#101;&#37;</a><br>动态包含：其余的<br><code>&lt;jsp:include page=””/&gt;</code></li>
</ul>
<p><strong>总结：用标签可以少些java脚本。</strong></p>
<h3 id="六、JSP的九个隐含对象：（面试题）"><a href="#六、JSP的九个隐含对象：（面试题）" class="headerlink" title="六、JSP的九个隐含对象：（面试题）"></a>六、JSP的九个隐含对象：（面试题）</h3><p>JSP对应的Servlet的service方法中的局部变量</p>
<table>
<thead>
<tr>
<th>JSP隐含对象名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td style="text-align:center">javax.servlet.http.HttpServletRequest</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>response</td>
<td style="text-align:center">javax.servlet.http.HttpServletResponse</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>session</td>
<td style="text-align:center">javax.servlet.http.HttpSession</td>
<td style="text-align:center">page指令有开关</td>
</tr>
<tr>
<td>application</td>
<td style="text-align:center">javax.servlet.ServletContext</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>config</td>
<td style="text-align:center">javax.servlet.ServletConfig</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>page</td>
<td style="text-align:center">javax.servlet.http.HttpServlet</td>
<td style="text-align:center">当前jsp对应Servlet的实例引用</td>
</tr>
<tr>
<td>exception</td>
<td style="text-align:center">java.lang.Throwable</td>
<td style="text-align:center">page指令有开关</td>
</tr>
<tr>
<td>out</td>
<td style="text-align:center">javax.servlet.jsp.JspWriter</td>
<td style="text-align:center">字符输出流。相当于PrintWriter</td>
</tr>
<tr>
<td>pageContext</td>
<td style="text-align:center">javax.servlet.jsp.PageContext</td>
<td style="text-align:center">很重要</td>
</tr>
</tbody>
</table>
<h3 id="七、PageContext抽象类（很重要）"><a href="#七、PageContext抽象类（很重要）" class="headerlink" title="七、PageContext抽象类（很重要）"></a>七、PageContext抽象类（很重要）</h3><ul>
<li><p>本身是一个域（范围）对象，还能操作其他3个域对象中的属性</p>
<ul>
<li>页面范围：<br><code>void setAttribute(String name,Object value);</code><br><code>void removeAttribute(String name);</code><br><code>Object getAttribute(String name);</code></li>
<li>操作其他域对象中的属性：<br><code>void setAttribute(String name,Object value,int scope);</code><br><code>void removeAttribute(String name,int scope);</code><br><code>Object getAttribute(String name,int scope);</code><br><code>int scope:</code>常量，<code>PageContext</code>     <code>PAGE_SCOPE(页面)</code>  <code>REQUEST_SCOPE（请求）</code> <code>SESSION_SCOPE（会话）</code> <code>APPLICATION_SCOPE（应用）</code></li>
<li>在四个范围中依次查找指定名称对象的方法：<br><code>PAGE(页面)</code>  <code>REQUEST（请求）</code> <code>SESSION（会话）</code> <code>APPLICATION（应用）</code><br><code>Object findAttribute(String name);</code></li>
</ul>
</li>
<li><p>获取其他八个JSP隐含对象(自定义标签时用)<br><code>PageContext.getRequest();</code><br><code>getServletContext();</code><br><code>getServletConfig();</code><br><code>getException();</code><br><code>get...</code></p>
</li>
<li>提供转发和包含的简易方法<br><code>pageContext.include(String url);</code></li>
</ul>
<h3 id="八、四大域对象"><a href="#八、四大域对象" class="headerlink" title="八、四大域对象"></a>八、四大域对象</h3><p><strong>实际开发中：存放数据的。</strong></p>
<p><code>PageContext:</code>页面范围。最小。开发中很少用。演示代码。<br><code>ServletRequest:</code>请求范围。不同的资源，只有用转发。<br><code>HttpSession:</code>会话范围。多次请求共享数据，但不同的客户端不能共享。<br><code>ServletContext:</code>应用范围。最大。尽量少用。用时要做同步处理。</p>
<h3 id="九、JSP开发的最佳实践"><a href="#九、JSP开发的最佳实践" class="headerlink" title="九、JSP开发的最佳实践"></a>九、JSP开发的最佳实践</h3><ul>
<li>Servlet：擅长写Java代码逻辑，不擅长输出html的内容。<br>开发中作为：控制器。</li>
<li>JSP：不擅长写Java代码逻辑，擅长显示结果。<br>开发中作为：视图（显示结果）<br><img src="http://i1.piimg.com/4851/7319051e910de6ff.png" alt=""></li>
</ul>
<h3 id="十、JavaBean的概念"><a href="#十、JavaBean的概念" class="headerlink" title="十、JavaBean的概念"></a>十、JavaBean的概念</h3><ul>
<li>1、JavaBean又称之为POJO（Plain Old Java Object）、VO（Value Object）、DO（Data Object）</li>
<li><strong>2、JavaBean的书写规范</strong><br>a、必须是public的<br>b、提供默认的构造方法<br>c、字段都是私有的： private String username;<br>d、提供公有的getter或setter方法：属性。<br>getUsername():读属性，属性名：username.<br>setUsername(String username):写属性，属性名：username。<br>e、一般需要实现java.io.Serializable接口。</li>
</ul>
<p><strong>注意：</strong> private boolean married;   getMarried()===isMarried()</p>
<p><strong>结论：</strong> JavaBean在JavaEE开发中，主要担当封装数据用的。</p>
<h3 id="十一、JSP中使用JavaBean"><a href="#十一、JSP中使用JavaBean" class="headerlink" title="十一、JSP中使用JavaBean"></a>十一、JSP中使用JavaBean</h3><ul>
<li>1、导入JavaBean：用page指令的import</li>
<li>2、声明JavaBean：<br><img src="http://i1.piimg.com/4851/853084b703212266.png" alt=""></li>
<li>3、获取属性：<br><img src="http://i1.piimg.com/4851/0fed44f6eeabb820.png" alt=""><br>如果属性是null，那么界面就显示null。</li>
<li>4、设置属性：<br>注意：类型的转换问题<br><img src="http://i1.piimg.com/4851/b62efc127800cb3b.png" alt=""><br>可以使用请求参数设置JavaBean的属性。<br><img src="http://i1.piimg.com/4851/476cb28dd59eeec9.png" alt=""></li>
<li>5、JavaBean的存活范围：<br>声明JavaBean时，指定scope属性。默认值page，当前页面范围。<br>可选值：page|request|session|application</li>
</ul>
<p>总结：JSP+JavaBean，开发模型，Model1（模型1）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、JSP简介&quot;&gt;&lt;a href=&quot;#一、JSP简介&quot; class=&quot;headerlink&quot; title=&quot;一、JSP简介&quot;&gt;&lt;/a&gt;一、JSP简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;也是SUN公司推出的开发动态web资源的技术，属于JavaEE技术之一。由
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>速读：从0到1</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/15/%E9%80%9F%E8%AF%BB%EF%BC%9A%E4%BB%8E0%E5%88%B01/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/15/速读：从0到1/</id>
    <published>2017-03-15T13:19:30.000Z</published>
    <updated>2017-03-27T13:56:36.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="速读：从0到1"><a href="#速读：从0到1" class="headerlink" title="速读：从0到1"></a>速读：从0到1</h2><h3 id="本书和作者"><a href="#本书和作者" class="headerlink" title="本书和作者"></a>本书和作者</h3><p>这本书是2015年最成功的商业畅销书。不仅因为它的作者是硅谷投资界的思想家，成功创办了PayPal、投资了Facebook的彼得·蒂尔，更因为这本书揭示了心怀梦想的创业者所需要知道的哲学层面的思想准备。当你知道了这些哲学思考，你才能明白为什么彼得能够继续成功创办了Founders Fund，投资了Linkedin、SpaceX、Yelp，甚至他投资的Palantir软件公司帮助美国政府对抗恐怖分子。</p>
<h3 id="什么是“从0到1”？"><a href="#什么是“从0到1”？" class="headerlink" title="什么是“从0到1”？"></a>什么是“从0到1”？</h3><p>进步可以呈两种形式：水平进步和垂直进步。水平进步也称广泛进步，就是从1到N。比如全球化和中国的山寨式创新。垂直进步也称深入进步，是从0到1的进步，比如真正的科技创新。用一个词概括水平进步就是全球化，中国是最好的范例。因为中国的理想未来就是现在的美国。垂直进步也可以用一个词来概括，那就是科技。1815到1914年间，科技迅速发展，全球化也快速蔓延。第一次世界大战到1971年基辛格访华，科技发展快，全球化缓慢。1971年开始，全球化加快，科技发展只局限于信息技术领域。</p>
<p>全球化会造成污染和能源危机，如果全世界都用同一种旧方法去创造财富，那就会成为灾难。丢掉科技创新的全球化不会长久。</p>
<h3 id="从网络泡沫的破灭中学到什么？"><a href="#从网络泡沫的破灭中学到什么？" class="headerlink" title="从网络泡沫的破灭中学到什么？"></a>从网络泡沫的破灭中学到什么？</h3><p>1998年9月到2000年3月，这段短命的网络热潮的背景就是一个溃败无序的世界。旧经济无法应对全球化带来的挑战。如果想要未来更好，就一定要找到处处行得通的方法。间接证据显示，互联网新经济是唯一可以前进的道路。</p>
<p>遭受硅谷劫难的企业家学到4点经验： </p>
<ol>
<li><p>循序渐进。不能沉溺在宏大的愿景中，小幅地循序渐进成长是安全前进的唯一道路；</p>
</li>
<li><p>保持精简和灵活性。事先规划死板又不现实，你应该做些尝试，反复实践，把创业当成未知的实验；</p>
</li>
<li><p>在改进中竞争。不要贸然创造新市场，在已有的客户群上拓展；</p>
</li>
<li><p>专注于产品，而非营销。如果你的产品需要广告或营销人员，就说明你的产品还不够好。</p>
</li>
</ol>
<p>虽然大家普遍信奉这4条，但我认为它们的对立面可能更正确：</p>
<ol>
<li><p>大胆尝试胜过平庸保守；</p>
</li>
<li><p>坏计划也好过没有计划；</p>
</li>
<li><p>竞争性市场很难赚到钱；</p>
</li>
<li><p>营销和产品同样重要。</p>
</li>
</ol>
<p>记住，最反主流的行动不是抵制潮流，而是在潮流中不丢弃自己的独立思考。</p>
<h3 id="垄断企业的谎言"><a href="#垄断企业的谎言" class="headerlink" title="垄断企业的谎言"></a>垄断企业的谎言</h3><p>美国航空公司每年要创造数千亿美元的价值，但每次飞行航空公司只能从每位乘客身上赚到37美分。而谷歌2012年只创造了500亿美元的价值，却从中获利21%，利润率是航空业的100多倍。原因是航空公司竞争太激烈了，而谷歌是垄断的。</p>
<p>别听到垄断就害怕，觉得消费者要受到欺压了。那是在静态的世界中，资源有限，手段单一。在动态世界中，富有创意的垄断者创造出更多的选择，它们是使社会更美好的推动力。经济学家痴迷于竞争是因为他们的想法来自物理学家，把个人和企业都看做可互换的原子，而不是独特的创造者。静态对企业来讲意味着死亡。</p>
<h3 id="要摆脱竞争意识"><a href="#要摆脱竞争意识" class="headerlink" title="要摆脱竞争意识"></a>要摆脱竞争意识</h3><p>竞争意味着大家都没有利润，产品没有实质差异，而且还要挣扎求生。竞争使我们过分重视过去的机会，一味重复过去的模式。也会使人产生幻觉去抓住一些并不存在的“机会”。竞争还会让人分心，受情绪控制去做一些不理智的事情。</p>
<p>我的经验是当你不能打败对手时可以选择联合。1999年末，PayPal和X.com陷入了全面竞争，我们当时关注的不是客观效率而是如何打败它。2000年3月，我和埃隆·马斯克决定合并，作为一个整体，我们熬过了网络泡沫。</p>
<h3 id="垄断企业的特征"><a href="#垄断企业的特征" class="headerlink" title="垄断企业的特征"></a>垄断企业的特征</h3><p>垄断企业通常会综合以下几个特点：专利技术、网络效应、规模经济和品牌优势。</p>
<ol>
<li><p>一般而言，专利技术在某些方面必须比最接近的替代品好10倍才能拥有真正的垄断优势。要做出10倍改进，最明确的方法就是创造全新的事物。PayPal让支付好了10倍以上，iPad比之前的平板电脑好用10倍。 </p>
</li>
<li><p>网络效应使一项产品随着越来越多的人使用变得更加有用。矛盾的是，享有网络效应的企业必须从非常小的市场做起。Facebook最初的使用者只是哈佛一个班的学生。PayPal的第一批用户只有24个人。</p>
</li>
<li><p>垄断企业越大越强，边际成本趋近于零。 </p>
</li>
<li><p>品牌的背后是实力，没有科技公司可以只靠品牌发展。苹果在超级触屏材料、触屏界面上都有复杂的专利技术，生产规模大到可以主导原料的价格。之后才是无处不在的广告和粉丝。</p>
</li>
</ol>
<h3 id="如何打造垄断企业？"><a href="#如何打造垄断企业？" class="headerlink" title="如何打造垄断企业？"></a>如何打造垄断企业？</h3><ol>
<li><p>占领小市场。在一个小市场里占主导地位比在大市场里要容易得多。当PayPal把目光锁定在eBay的数千个超级卖家上时，我们就找对了路子。</p>
</li>
<li><p>扩大规模。一旦你成功创造了或是主导了一个利基市场，就要逐步打入稍大些的相关市场。比如亚马逊从图书到音像制品和软件，最后才到跑车和工业品。 </p>
</li>
<li><p>破坏性创新。“破坏”是指一家公司可以用科技创新低价推出一种低端产品，然后逐步对产品做出改进，最终取代现存公司用旧科技生产的优质产品。但别为了破坏而破坏，如果你认为自己是对抗黑暗势力的起义者，就很容易过分专注于道路上的障碍。如果你真想创造新的事物，就去创造。PayPal给了visa更多的商业机会，整个产业得到了正面的回馈。如果你准备扩张到相邻市场，不要破坏，要尽可能地躲开竞争。</p>
</li>
</ol>
<h3 id="成功不是靠运气"><a href="#成功不是靠运气" class="headerlink" title="成功不是靠运气"></a>成功不是靠运气</h3><p>爱默生说：浅薄的人才会相信运气和境遇，强者只相信因果。根据对未来的确定性和乐观程度，人可以分为四种：</p>
<ol>
<li><p>对未来不明确的悲观主义：比如现在的欧洲。</p>
</li>
<li><p>对未来明确的悲观主义：比如现在的中国，中国人太喜欢提前做好准备了。从中国的角度看，经济增长还不够快。其他国家都害怕中国将要统治世界，而中国是唯一一个认为自己不会统治世界的国家。</p>
</li>
<li><p>对未来明确的乐观主义：1950-1970年的美国。大量大胆的计划被重视和实施，不断地尝试改变世界。 </p>
</li>
<li><p>对未来不明确的乐观主义：1982年以后的美国。金融取代建筑成为主导，不去制定具体计划，却都想在未来获利。银行家和律师盛行。</p>
</li>
</ol>
<p>当今的世界的主流思想就是对未来不明确却很乐观。不明确的金融、不明确的政治、不明确的哲学、不明确的人生。没有计划的进步就叫做“演化”。依靠演化来尝试成功的企业是不靠谱的，所以，长期规划仍是最重要的。乔布斯对苹果的设计绝不是产品，而是整个生态结构。初创企业是你可以明确掌握尽最大努力的机会，因为你不是一张被概率决定命运的彩票。</p>
<h3 id="风险投资应该给什么样的公司？"><a href="#风险投资应该给什么样的公司？" class="headerlink" title="风险投资应该给什么样的公司？"></a>风险投资应该给什么样的公司？</h3><p>我们所在的世界不是正常的世界，而是处在幂次法则之下。风险投资就是为了找到可以指数级增长的公司。撒网式投资然后祈祷的方法通常会全盘皆输，因为风险投资的回报并不遵循正态分布，而是遵循幂次法则：一小部分公司完胜其他所有公司。 </p>
<p>风险投资家总结了两个规则：</p>
<ol>
<li><p>只投资给获利可达整个投资基金总值的有潜力的公司。 </p>
</li>
<li><p>因为第一条太严苛，所以不需要其他规则。不管何时，如果你不关注事业本质，而是关注其是否适合多元化避险策略的财务问题，那么投资就像是在买彩票。一旦你认为自己在抽奖，就已经做好了亏损的心理准备。 </p>
</li>
</ol>
<p>幂次法则不仅对投资者重要，对每个人都重要。创业者最大的投资是花时间成立新公司；每个人选择一份工作也是一项投资，因为你相信自己选择的工作在今后的几十年里会变得很有价值。人生对于创业者和任何人来说都不能“多元化”，你应该把全部注意力放在你擅长的事情上，而且在这之前要先仔细想想未来这件事情是否会变得很有价值。</p>
<h3 id="要始终相信秘密的存在"><a href="#要始终相信秘密的存在" class="headerlink" title="要始终相信秘密的存在"></a>要始终相信秘密的存在</h3><p>秘密分两种：自然的秘密和人的秘密。探索秘密的最佳处所就是无人关注的地方。大多数人只以学校教授给他们的方式思考，而学校本身的目标就在于传授常规知识。那些没有被标准化和制度化的领域都是值得研究的。</p>
<p>当你找到了秘密，不要闷在心里，也不要见谁都说。所有成功的企业都是基于鲜为人知的秘密创立的。好企业是改变世界的密谋者。当你与人分享秘密时，听众就成为了你的谋士。</p>
<p>有些事起步时就要做好：</p>
<ol>
<li><p>首先至关重要的决定是：和谁一起做？有些一拍即合的合伙就像在拉斯维加斯的老虎机前遇到的婚姻一样糟糕。技术能力和才华固然重要，但创始人之间的了解程度和默契程度也同样重要。最好有深厚的交情，否则就是碰运气。</p>
</li>
<li><p>分清楚所有权、经营权和控制权。董事会越小越好，董事们容易沟通，并进行有效监督。除非你上市了，否则董事会不要超过5个人。 </p>
</li>
<li><p>尽量雇佣全职员工。某些岗位可以兼职，但重要岗位一定要全职。</p>
</li>
<li><p>现金奖励不如股权奖励。愿意拿股权奖励的人才是对公司未来有信心的人。股票报酬才能让员工全力以赴。 </p>
</li>
<li><p>只要公司创新，创业就还没结束，一旦创新停止，创业就结束了。你甚至可以使创业无限延伸下去。</p>
</li>
</ol>
<h3 id="打造帮派文化"><a href="#打造帮派文化" class="headerlink" title="打造帮派文化"></a>打造帮派文化</h3><ol>
<li><p>初创公司是肩负统一使命的一个团队，企业文化的好坏取决于内涵而不是公司福利或者涂鸦墙。</p>
</li>
<li><p>时间是最宝贵的资产，将时间浪费在不能长久合作的人身上得不偿失。从一开始我就让员工紧密团结，而不是出于事务关系待在一起。要招聘认同公司使命的人，并且愿意和已有的这些人共事。</p>
</li>
<li><p>要给大家统一的文化衫和卫衣，上面有公司logo，这让大家看起来与众不同。</p>
</li>
<li><p>每名员工只专注一件事情，这样可以避免不必要的竞争和推诿，也让大家更有成就感。</p>
</li>
<li><p>有时被外人成为邪教或者黑帮，也不是件坏事。</p>
</li>
</ol>
<h3 id="三种销售策略"><a href="#三种销售策略" class="headerlink" title="三种销售策略"></a>三种销售策略</h3><ol>
<li><p>如果你的平均销售额在七位数以上，一两年才达成一笔交易，这就是复杂销售。比如太空探索公司。这种销售中CEO最重要。</p>
</li>
<li><p>平均交易额1万到10万美元的销售叫做人员销售。这需要招聘和培训大量专业销售人员。</p>
</li>
<li><p>如果产品的核心功能可以鼓励用户邀请其他朋友成为用户，那么这个产品才能进行病毒式营销。每次只要有人与朋友分享，就自然而然地邀请更多的人加入。</p>
</li>
</ol>
<p>销售策略并不是越多越好，同样有幂次法则在起作用。只要有一条有效的销售途径，你就能成功。需要推销的不仅仅是你的产品，还有你的公司。要把公司推荐给媒体和投资人，以及员工。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;速读：从0到1&quot;&gt;&lt;a href=&quot;#速读：从0到1&quot; class=&quot;headerlink&quot; title=&quot;速读：从0到1&quot;&gt;&lt;/a&gt;速读：从0到1&lt;/h2&gt;&lt;h3 id=&quot;本书和作者&quot;&gt;&lt;a href=&quot;#本书和作者&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
    
      <category term="观看与感悟" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/%E8%A7%82%E7%9C%8B%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Cookie和HttpSession的学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/15/Cookie%E5%92%8CHttpSession%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/15/Cookie和HttpSession的学习笔记/</id>
    <published>2017-03-15T12:05:15.000Z</published>
    <updated>2017-03-17T12:24:57.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</p>
</blockquote>
<h2 id="客户端技术：Cookie"><a href="#客户端技术：Cookie" class="headerlink" title="客户端技术：Cookie"></a>客户端技术：Cookie</h2><blockquote>
<p>回顾HTTP协议的消息头<br>请求消息头：Cookie 客户端向服务器端传递信息<br>响应消息头：Set-Cookie 服务器端向客户端传递信息</p>
</blockquote>
<h3 id="1、Cookie详解："><a href="#1、Cookie详解：" class="headerlink" title="1、Cookie详解："></a>1、Cookie详解：</h3><h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><ul>
<li>name：Cookie的名称，必要的属性</li>
<li>value：Cookie的取值（不能为中文），必要的属性<br>——————-以下为可选属性</li>
<li><p><strong>path：Cookie的路径</strong><br>默认值就是写cookie的那个资源的访问路径<br>比如：<a href="http://localhost:8080/day09_00_cookie/servlet/CookieDemo1" target="_blank" rel="external">http://localhost:8080/day09_00_cookie/servlet/CookieDemo1</a> path就是/day09_00_cookie/servlet/</p>
</li>
<li><p><strong>注意：</strong><br>如果一个存在浏览器缓存中的cookie的路径是/day09/servlet/<br>当访问<a href="http://localhost:8080/day09/CookiePathDemo1时，浏览器根本不带Cookie给服务器。浏览器比对的是cookie的路径和当前访问的资源的路径。" target="_blank" rel="external">http://localhost:8080/day09/CookiePathDemo1时，浏览器根本不带Cookie给服务器。浏览器比对的是cookie的路径和当前访问的资源的路径。</a></p>
</li>
<li><p><strong>浏览器满足一下条件就会带cookie给服务器：</strong><br>当前访问的地址的路径.startWith(已存cookie的路径)。<br>即：如果一个Cookie的路径设置为了当前应用，说明访问该网站的任何资源时浏览器都带该cookie给服务器。（开发中经常做的）</p>
</li>
<li><p>maxAge：Cookie的最大生存时间。默认是在浏览器的内存中。</p>
</li>
<li><p>domain：Cookie的域名（网站）。默认就是写cookie的那个资源所属的网站。<br><a href="http://localhost:8080/day09_00_cookie/servlet/CookieDemo1域名就是localhost" target="_blank" rel="external">http://localhost:8080/day09_00_cookie/servlet/CookieDemo1域名就是localhost</a></p>
</li>
<li><p>version：版本号</p>
</li>
<li>comment:注释</li>
</ul>
<h4 id="把Cookie写给客户端"><a href="#把Cookie写给客户端" class="headerlink" title="把Cookie写给客户端"></a>把Cookie写给客户端</h4><ul>
<li>HttpServletResponse.addCookie(Cookie c):实际上就是向客户端发送了一个响应消息头。</li>
<li><code>注意：客户端只能保存一个网站最多20个Cookie数据，总共最多300个。每个Cookie的大小不能超过4kb。</code><h4 id="服务器端获取客户端带来的Cookie："><a href="#服务器端获取客户端带来的Cookie：" class="headerlink" title="服务器端获取客户端带来的Cookie："></a>服务器端获取客户端带来的Cookie：</h4>Cookie [] HttpServletRequest.getCookies();</li>
</ul>
<p><code>注意：domain+path+name唯一确定一个Cookie。</code></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><pre><code>import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class LoginServlet extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response) 
        throws ServletException, IOException {
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        //验证用户名和密码是否正确：此处输什么都正确
        String usename = request.getParameter(&quot;usename&quot;);
        String password = request.getParameter(&quot;password&quot;);
        String remember = request.getParameter(&quot;remember&quot;);//没有选中就是null

        Cookie c = new Cookie(&quot;loginInfo&quot;,usename);
        c.setPath(request.getContextPath());
        if(remember==null){
            //没有选中，删除cookie
            c.setMaxAge(0);
        }else{
            //用户记住用户名：存cookie
            c.setMaxAge(Integer.MAX_VALUE);
        }
        response.addCookie(c);
        out.write(&quot;登录成功&quot;);

    }

    public void doPost(HttpServletRequest request, HttpServletResponse response) 
        throws ServletException, IOException {
        doGet(request,response);
    }

}

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class LoginUIServlet extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response) 
        throws ServletException, IOException {
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        String username = &quot;&quot;;
        String checked = &quot;&quot;;
        //得到指定的cookie
        Cookie cs[] = request.getCookies();
        for(int i=0;cs!=null&amp;&amp;i&lt;cs.length;i++){
            if(&quot;loginInfo&quot;.equals(cs[i].getName())){
                username = cs[i].getValue();
                checked=&quot;checked=&apos;checked&apos;&quot;;
                break;
            }
        }

        out.write(&quot;&lt;form action=&apos;&quot;+request.getContextPath()+&quot;/servlet/LoginServlet&apos; method=&apos;post&apos;&gt;&quot;);
        out.write(&quot;账号：&lt;input type=&apos;text&apos; name=&apos;usename&apos; value=&apos;&quot;+username+&quot;&apos; /&gt;&lt;br/&gt;&quot;);
        out.write(&quot;密码：&lt;input type=&apos;password&apos; name=&apos;password&apos; value=&apos;&apos; /&gt;&lt;br/&gt;&quot;);
        out.write(&quot;记住账号：&lt;input type=&apos;checkbox&apos; name=&apos;remember&apos; &quot;+checked+&quot;/&gt;&lt;br/&gt;&quot;);
        out.write(&quot;&lt;input type=&apos;submit&apos; value=&apos;登录&apos;/&gt;&quot;);
        out.write(&quot;&lt;/form&gt;&quot;);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response) 
        throws ServletException, IOException {
        doGet(request,response);
    }

}
</code></pre><h2 id="服务器端技术：HttpSession"><a href="#服务器端技术：HttpSession" class="headerlink" title="服务器端技术：HttpSession"></a>服务器端技术：HttpSession</h2><h3 id="HttpSession-用途"><a href="#HttpSession-用途" class="headerlink" title="HttpSession 用途"></a>HttpSession 用途</h3><ul>
<li>它也是一个域对象：session servletContext request</li>
<li>同一个会话下，可以使一个应用的多个资源共享数据</li>
<li>cookie 客户端技术，只能存字符串。HttpSession服务器端的技术，它可以存对象</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><strong>把数据保存在HttpSession对象中，该对象也是一个域对象</strong></p>
<ul>
<li><code>setAttribute(String name,Object value)</code> 存对象</li>
<li><code>getAttribute(String name)</code>    取对象</li>
<li><code>remvoeArrtibute(String name)</code></li>
<li><code>getId()</code></li>
<li><code>setMaxInactiveInterval(int interval)</code> 设置session的存活时间 单位秒</li>
<li><code>invalidate()</code> 销毁session</li>
</ul>
<h3 id="getSession-内部执行原理"><a href="#getSession-内部执行原理" class="headerlink" title="getSession() 内部执行原理"></a>getSession() 内部执行原理</h3><ul>
<li>1,获取名称为JSESSIONID的cookie的值</li>
<li>2，没有这样的cookie，创建一个新的HttpSession对象，分配一个唯一的SessionId,并且向客户端写了一个名为JSESSIONID=sessionId的cookie</li>
<li>3,有这样的Cookie，获取cookie的值（即HttpSession对象的值），从服务器的内存中根据Id找那个HttpSession对象<br>找到了：取出继续为你服务<br>找不到：从2开始<br><img src="http://i1.piimg.com/4851/c6ef3c69c9d9ffc7.png" alt=""><br>HttpSession request.getSession(boolean b):<br>b如果为true，和getSession()完全一样的<br>b为false，服务器只是查找，找不到不会创建新的，返回null。<br>HttpSession.invalidate();使HttpSession对象立即失效。</li>
</ul>
<h3 id="客户端禁用Cookie后的会话数据的保持"><a href="#客户端禁用Cookie后的会话数据的保持" class="headerlink" title="客户端禁用Cookie后的会话数据的保持"></a>客户端禁用Cookie后的会话数据的保持</h3><p>客户端永远不会向服务器端带任何cookie。<br>解决办法：<br>方式一：（乌龙）文字提示：请不要禁用您的Cookie<br>方式二：在访问的地址后面加上JSESSIONID=session的id。<br><a href="http://localhost:8080/servlet/ServletDemo1" target="_blank" rel="external">http://localhost:8080/servlet/ServletDemo1</a>   URL重写，必须对网站的所有地址都重写<br><a href="http://localhost:8080/servlet/ServletDemo1;JSESSIONID=123" target="_blank" rel="external">http://localhost:8080/servlet/ServletDemo1;JSESSIONID=123</a></p>
<p>response.encodeUrl(String url);自动重写。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>Request和Response的学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/14/Request%E5%92%8CResponse%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/14/Request和Response的学习笔记/</id>
    <published>2017-03-14T11:29:30.000Z</published>
    <updated>2017-03-14T14:13:19.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天写博客比以往都要早一点，从图书馆一回寝室就开始把今天学的凭记忆先记录下来，（其实主要还是怕贪玩又忘记写。）这是我写的第5篇博客，从上月22号坚持每天去图书馆刚好三周21天，是我戒烟的第25天。讲实话这些坚持真的让自己很难受，但当我看到这些统计出的文字时又是满满的感动。</p>
</blockquote>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul>
<li>web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象和代表响应的request对象。</li>
<li>request和response对象既然代表请求和响应，那我们要获取客户端（浏览器）提交过来的数据，只需要找request对象就行了。要客户端输出数据，只需要找response对象就行了。<br><strong>注意：</strong> request中封装的是浏览器的信息和请求参数，即浏览器的请求；response中封装的是服务器向浏览器发送的数据、响应头和编码格式等，即服务器的响应。</li>
</ul>
<h2 id="二、HttpServletResponse-响应对象"><a href="#二、HttpServletResponse-响应对象" class="headerlink" title="二、HttpServletResponse 响应对象"></a>二、HttpServletResponse 响应对象</h2><h3 id="1、字节流向客户端输出中文数据"><a href="#1、字节流向客户端输出中文数据" class="headerlink" title="1、字节流向客户端输出中文数据"></a>1、字节流向客户端输出中文数据</h3><ul>
<li>默认情况下：浏览器是乱码的（他默认查GBK）<ol>
<li>解决方案一：更改浏览器的码表（不建议）</li>
<li>解决方案二(不建议)：向客户端输出一个<meta>标签,模拟了响应消息头：<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"></li>
<li>解决方案三（建议）:向客户端输出响应消息头：response.setHeader(“Content-Type”, “text/html;charset=UTF-8”);</li>
<li>解决方案四（建议）：向客户端输出响应消息头response.setContentType(“text/html;charset=UTF-8”);</li>
</ol>
</li>
</ul>
<p>案例代码：</p>
<pre><code>import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//字节流向客户端输出中文数据
public class ResponseDemo1 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
        test2(response);
    }

    //字节流输出数据查UTF-8
    private void test2(HttpServletResponse response) throws IOException {
        String data = &quot;不见了远处的青山&quot;;

        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        ServletOutputStream out = response.getOutputStream();
        out.write(data.getBytes(&quot;UTF-8&quot;));//默认情况下：浏览器是乱码的（他默认查GBK）
    }
    //字节流输出数据查本地码表
    private void test1(HttpServletResponse response) throws IOException {
        String data = &quot;不见了远处的青山&quot;;
        ServletOutputStream out = response.getOutputStream();
        out.write(data.getBytes());//String:  getBytes()查本地默认的码表GBK getBytes(String charset)查指定码表
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="2、字符流输出中文数据"><a href="#2、字符流输出中文数据" class="headerlink" title="2、字符流输出中文数据"></a>2、字符流输出中文数据</h3><ul>
<li>HttpServletResponse的实例由Tomcat服务器提供，默认查ISO-8859-1的。</li>
<li>Tomcat8.X ,默认编码就变为了UTF-8</li>
</ul>
<p>案例源码：</p>
<pre><code>import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//字符流输出中文数据
public class ResponseDemo2 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String data = &quot;幸福是什么呢&quot;;
        //改变字符流查的码表，还能告知客户端用UTF-8进行解码
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        out.write(data);
    }

    private void test1(HttpServletResponse response) throws IOException {
        String data = &quot;幸福是什么&quot;;
        //改变字符流查的码表
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        //告知客户端用UTF-8进行解码
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        out.write(data);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><p><strong>注意：</strong> 在开发中尽量使用字节流，因为字节流可以处理任何数据，而字符流只能用来处理文本。</p>
<h3 id="3、输出随机验证码图片：CAPTCHA图像"><a href="#3、输出随机验证码图片：CAPTCHA图像" class="headerlink" title="3、输出随机验证码图片：CAPTCHA图像"></a>3、输出随机验证码图片：CAPTCHA图像</h3><p>案例源码：</p>
<pre><code>import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//输出随机验证码图片：CAPTCHA图像
public class ResponseDemo3 extends HttpServlet {
    public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
        int width = 120;
        int height = 25;
        //创建一副内存图像
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        //得到画笔
        Graphics g = image.getGraphics();
        //开始画
        //边线
        g.setColor(Color.BLUE);
        g.drawRect(0, 0, width, height);
        //填充背景色
        g.setColor(Color.YELLOW);
        g.fillRect(1, 1, width-2, height-2);
        //话干扰线
        g.setColor(Color.GRAY);

        Random r = new Random();
        for(int i=0;i&lt;9;i++)
            g.drawLine(r.nextInt(width), r.nextInt(height), r.nextInt(width), r.nextInt(height));
        //验证码
        g.setColor(Color.RED);
        g.setFont(new Font(&quot;宋体&quot;, Font.ITALIC|Font.BOLD, 19));
        int x = 20;
        for(int i=0;i&lt;4;i++){
            g.drawString(r.nextInt(10)+&quot;&quot;, x,20 );
            //g.drawString(base.charAt(r.nextInt(base.length()))+&quot;&quot;, x, 20);
            x+=18;
        }
        //输出
        response.setHeader(&quot;Expires&quot;, &quot;-1&quot;);
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
        ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream());
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="4、控制客户端定时刷新"><a href="#4、控制客户端定时刷新" class="headerlink" title="4、控制客户端定时刷新"></a>4、控制客户端定时刷新</h3><pre><code>import java.io.IOException;
import java.util.Random;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//控制客户端定时刷新
public class ResponseDemo4 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        test2(response);
    }
    //定时刷新到别处
    private void test2(HttpServletResponse response) throws IOException {
        response.setContentType(&quot;text/htm;charset=UTF-8&quot;);
        response.setHeader(&quot;Refresh&quot;, &quot;2;URL=http://www.itheima.com&quot;);
        response.getWriter().write(&quot;登录成功，2秒后跳转到主页&quot;);
    }
    //定时刷新自己
    private void test1(HttpServletResponse response) throws IOException {
        Random r = new Random();
        //response.setHeader(&quot;Refresh&quot;, &quot;1&quot;);
        response.setIntHeader(&quot;Refresh&quot;, 1);
        response.getWriter().write(r.nextInt()+&quot;&quot;);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="5、控制缓存的时间"><a href="#5、控制缓存的时间" class="headerlink" title="5、控制缓存的时间"></a>5、控制缓存的时间</h3><ul>
<li>静态资源需要控制缓存时间</li>
<li>动态资源一般不要缓存</li>
</ul>
<p>案例源码：</p>
<pre><code>import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ResponseDemo5 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String data = &quot;不见了远处的青山&quot;;
        //让他缓存1个小时
        response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis()+1*60*60*1000);
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        response.getWriter().write(data);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="6、请求重定向"><a href="#6、请求重定向" class="headerlink" title="6、请求重定向"></a>6、请求重定向</h3><ul>
<li>演示请求重定向:可以重定向到任何地址上</li>
<li>发出2次请求</li>
<li>地址栏会发生变化</li>
</ul>
<p>案例源码：</p>
<pre><code>import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ResponseDemo6 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        response.sendRedirect(&quot;http://www.itheima.com&quot;);
    }
    //重定向到应用内的资源
    private void test1(HttpServletResponse response) throws IOException {
        //response.setStatus(302);
        //response.setHeader(&quot;Location&quot;, &quot;/day08_00_response/servlet/ResponseDemo7&quot;);
        response.sendRedirect(&quot;/day08_00_response/servlet/    ResponseDemo7&quot;);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="7、response细节"><a href="#7、response细节" class="headerlink" title="7、response细节"></a>7、response细节</h3><ul>
<li>getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOutputStream、PrintWriter对象。</li>
<li>getOutputStream和getWriter这两个方法互相排斥，调用其中的任何一个方法后，就不能再调用另一个方法。</li>
<li>servlet程序向ServletOutputStream和PrintWriter对象中写入的数据将被servlet引擎从response里面获取，servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。</li>
<li>servlet的service方法结束后，servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，servlet引擎将调用close方法关闭该输出对象。</li>
</ul>
<h2 id="三、HttpServletRequest-请求对象"><a href="#三、HttpServletRequest-请求对象" class="headerlink" title="三、HttpServletRequest 请求对象"></a>三、HttpServletRequest 请求对象</h2><blockquote>
<p>HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头的所有信息都封装在这个对象中，开发人员通过这个对象的方法，可以获得客户这些信息。</p>
</blockquote>
<h3 id="3-1常用方法"><a href="#3-1常用方法" class="headerlink" title="3.1常用方法"></a>3.1常用方法</h3><h4 id="3-1-1获得浏览器的信息"><a href="#3-1-1获得浏览器的信息" class="headerlink" title="3.1.1获得浏览器的信息"></a>3.1.1获得浏览器的信息</h4><blockquote>
<p>getRequestURL()方法返回客户端发出请求时完整的URL<br>getRequestURI()方法返回请求行中的资源名部分<br>getQueryString()方法返回请求行中的参数部分<br>getRemoteAddr()方法返回请求的客户机的完整IP地址<br>getRemoteHost()方法返回发出请求的客户机的完整主机名<br>getRemotePort()方法返回客户机所使用的网络端口号<br>getLocalAddr()方法返回Web服务器的IP地址<br>getLocalName()方法返回Web服务器的主机名<br>getMethod()得到客户机的请求方式</p>
</blockquote>
<h4 id="3-1-2获得浏览器的请求头"><a href="#3-1-2获得浏览器的请求头" class="headerlink" title="3.1.2获得浏览器的请求头"></a>3.1.2获得浏览器的请求头</h4><blockquote>
<p>getHeader(String name)方法<br>getHeaders(String name)方法<br>getHeaderNames方法</p>
</blockquote>
<p><strong>例1.获取请求头</strong></p>
<pre><code>import java.io.IOException;
import java.util.Enumeration;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class RequestDemo2 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //获取请求头，但是这个头可能出现多次，此时我们可以使用getHeaders方法
        String head = request.getHeader(&quot;Accept-Encoding&quot;);

            System.out.println(head);
        if(head.contains(&quot;gzip&quot;)){
            //看是否包含gzip头，若存在，再向其输出压缩数据
        }else{
            //不存在则输出没有压缩的数据
        }

        //当一个头出现多次
        Enumeration e = request.getHeaders(&quot;Accept-Encoding&quot;);
        while(e.hasMoreElements()){
            String value = (String) e.nextElement();
            System.out.println(value);
        }

        //获得所有的头和对应的值
           e = request.getHeaderNames();
        while(e.hasMoreElements()){
            String name = (String) e.nextElement();
            String value = request.getHeader(name);
            System.out.println(value);
        }
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre><h4 id="3-1-3获得浏览器请求参数（即浏览器提交的数据）"><a href="#3-1-3获得浏览器请求参数（即浏览器提交的数据）" class="headerlink" title="3.1.3获得浏览器请求参数（即浏览器提交的数据）"></a>3.1.3获得浏览器请求参数（即浏览器提交的数据）</h4><pre><code>import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.beanutils.BeanUtils;

import com.itheima.domain.User;
//获取请求参数
public class RequestDemo3 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        test8(request, response);
    }
    //终极解决方案：借助BeanUtil框架
    private void test8(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        User user = new User();
        System.out.println(&quot;封装前：&quot;+user);
        try {
            BeanUtils.populate(user, request.getParameterMap());
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(&quot;封装后：&quot;+user);
    }
    //getParameterMap获取参数:封装到JavaBean中
    private void test7(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //key:请求参数名 value:请求参数值数组
        Map&lt;String,String[]&gt; map = request.getParameterMap();
        User user = new User();
        System.out.println(&quot;封装前：&quot;+user);
        for(Map.Entry&lt;String, String[]&gt; me:map.entrySet()){
            String paramName = me.getKey();//参数名称
            String paramValues[] = me.getValue();//参数值
            try {
                PropertyDescriptor pd = new PropertyDescriptor(paramName, User.class);
                Method m = pd.getWriteMethod();//setter方法
                if(paramValues.length&gt;1){
                m.invoke(user, (Object)paramValues);//参考补充视频：反射main方法
                }else{
                    m.invoke(user, paramValues);
                }
            } catch (Exception e1) {
                e1.printStackTrace();
            }
        }
        System.out.println(&quot;封装后：&quot;+user);
    }
    //getParameterMap获取参数
    private void test6(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //key:请求参数名 value:请求参数值数组
        Map&lt;String,String[]&gt; map = request.getParameterMap();
        for(Map.Entry&lt;String, String[]&gt; me:map.entrySet()){
            System.out.println(me.getKey()+&quot;=&quot;+Arrays.asList(me.getValue()));
        }
    }

    //把请求参数的值封装到JavaBean中
    //约定优于编码：表单的输入域的name取值和JavaBean中的属性（getter和setter方法）保持一致
    private void test5(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {


        Enumeration&lt;String&gt; e = request.getParameterNames();//参数名
        User user = new User();
        System.out.println(&quot;封装前：&quot;+user);
        while(e.hasMoreElements()){
            String paramName = e.nextElement();//即是JavaBean中的属性名称
            String paramValue = request.getParameter(paramName);
            //setUsername(paramValue); setPassword(paramValue);
            //JavaBean的内省
        try {
            PropertyDescriptor pd = new PropertyDescriptor(paramName, User.class);
            Method m = pd.getWriteMethod();//setter方法
            m.invoke(user, paramValue);
            } catch (Exception e1) {
            e1.printStackTrace();
            }
        }
        System.out.println(&quot;封装后：&quot;+user);
    }    
//private void test4(HttpServletRequest request, HttpServletResponse response)
//            throws ServletException, IOException {
//        User user = new User();
//        System.out.println(&quot;封装前：&quot;+user);
//        String username = request.getParameter(&quot;username&quot;);
//        String password = request.getParameter(&quot;password&quot;);
//        String gender = request.getParameter(&quot;gender&quot;);
//        user.setUsername(username);
//        user.setPassword(password);
//        user.setGender(gender);
//        System.out.println(&quot;封装后：&quot;+user);
//    }    
    //以下内容只用简单的程序开发

    //获取所有的请求参数名和值
    private void test3(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        Enumeration&lt;String&gt; e = request.getParameterNames();//参数名
        while(e.hasMoreElements()){
            String paramName = e.nextElement();
            String values [] = request.getParameterValues(paramName);
            System.out.println(paramName+&quot;=&quot;+Arrays.asList(values));
        }
    }
    //获取重名请求参数的值
    private void test2(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String username = request.getParameter(&quot;username&quot;);//不区分get还是post的
        String passwords[] = request.getParameterValues(&quot;password&quot;);//获取重名的请求参数值
        System.out.println(username+&quot;:&quot;+Arrays.asList(passwords));
    }
    //获取单一的请求参数的值(用户所有的输入都是String)
    private void test1(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String username = request.getParameter(&quot;username&quot;);//不区分get还是post的
        String password = request.getParameter(&quot;password&quot;);
        System.out.println(username+&quot;:&quot;+password);
    }
    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h4 id="3-1-4请求参数的中文乱码问题"><a href="#3-1-4请求参数的中文乱码问题" class="headerlink" title="3.1.4请求参数的中文乱码问题"></a>3.1.4请求参数的中文乱码问题</h4><pre><code>import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//中文乱码问题
public class RequestDemo4 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //post提交时乱码解决方式：设置服务器打开请求数据时用的码表，即request使用的码表
        //request.setCharacterEncoding(&quot;UTF-8&quot;);

        String username = request.getParameter(&quot;username&quot;);
        System.out.println(username);

        //get提交时乱码解决方式：先使用iso8859-1得到数据，然后再使用正确的编码转换过来
        byte[] source = username.getBytes(&quot;iso8859-1&quot;);
        username = new String(source, &quot;UTF-8&quot;);
        System.out.println(username);

    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>使用post方式提交表单数据时需要注意几点：<ul>
<li>在html中我们使用<meta name="content-type" content="text/html; charset=UTF-8">规定保存此文件的格式，我们可以选中文件右键àProperties可以在下面的Default处看到文件的编码格式，是和我们设置的编码一致的。</li>
<li>表单在提交的时候我们需要查看浏览器使用哪张码表打开此表单，如果使用GBK打开此表单，那么填写在此表单中提交的数据也将使用GBK编码，提交到服务器之后request.getParameter默认会使用iso8859-1码表将获得的数据转换成字符串，此时会出现乱码。我们可以使用request.setCharacterEncoding(“GBK”);将Request使用的码表换成GBK，这样和浏览器使用的编码就一致了。</li>
</ul>
</li>
</ul>
<ul>
<li>使用get方式提交表单数据时需要注意：<ul>
<li>当使用get方式提交表单数据时，设置Request编码是无效的，于是我们需要先使用iso8859码表得到乱码数据，然后再使用何时的码表将乱码转换成正确的文本数据。这是看视频教程中是这样解决的，但是在自己本地却不好使，当我的网页使用UTF-8打开时提交的数据能正确显示，但是如果使用GBK打开则不能正确显示。也就是网页使用UTF-8编码的数据提交才能正确显示，不是默认去查iso8859-1吗，这难道是tomcat的原因？？？？</li>
<li>还有个问题没有解决：就是当直接使用地址<a href="http://localhost:8080/ResAndReq/servlet/RequestDemo4?username=&#39;中国" target="_blank" rel="external">http://localhost:8080/ResAndReq/servlet/RequestDemo4?username=&#39;中国</a>‘ 访问服务器时，不需要设置任何编码就可以显示正确的文本。而且不管浏览器使用什么编码我们在地址栏中都可以看到正确的文本。URL其实对于汉字是直接使用的ASCII码，只是每个字的编码前加上一个%号？？？？</li>
<li>最后还可以更改服务器配置文件，在server.xml中的<connector>标签的最后加上一个属性：URIEncoding=”UTF-8”即可。这时什么都不需要设置了直接使用String username = request.getParameter(“username”);这种方式一般不适用.这里我们还有一种灵活的方式,在<connector>标签添加下面这个属性将useBodyEncodingForURI属性设置为true，那么如果我们request.setCharacterEncoding(“UTF-8”);之后连接器就使用什么编码。不管是什么方式，但是更改服务器的配置文件一般不推荐。</connector></connector></li>
</ul>
</li>
</ul>
<h3 id="请求重定向和请求转发的区别："><a href="#请求重定向和请求转发的区别：" class="headerlink" title="请求重定向和请求转发的区别："></a>请求重定向和请求转发的区别：</h3><p><img src="http://i.imgur.com/RwfiPOf.png" alt=""></p>
<p>（1）一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发。这里的两个servlet共享一个request和response对象。同时地址栏不会发生变化。<br>（2）一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源，称之为请求重定向。地址栏会发生变化。<br>（3）RequestDispatcher.forward方法只能将请求转发给同一个web应用中的组件（即多个servlet）；而HttpServletResponse.sendRedirect方法可以重定向到同一个站点上的其他应用程序中的资源（多个web应用），甚至是使用绝对URL重定向到其他站点的资源。<br>（4）调用HttpServletResponse.sendRedirect方法重定向的访问过程结束后，浏览器地址栏中显示的URL地址会发生变化，由初始的URL地址变成重定向的目标URL；调用RequestDispatcher.forward方法的请求转发过程结束后，浏览器地址栏保持初始的URL地址。<br>（5）HttpServletResponse.sendRedirect方法对浏览器的请求直接做出响应，响应的结果就是告诉浏览器去重新发出对另外一个URL的访问请求；RequestDispatcher.forward方法在服务器端内部将请求转发给另外一个资源（servlet），浏览器只知道发出了请求并得到了响应结果，并不知道在服务器内部发生了转发行为。<br>（6）RequestDispatcher.forward方法调用者与被调用者之间共享相同的request和response对象，它们属于同一个访问请求和响应过程；而HttpServletResponse.sendRedirect方法调用者与被调用者使用各自的request和response对象，它们属于两个独立的访问请求和响应过程。<br>（7）include方法<br>RequestDispatcher.include方法用于将RequestDispatcher对象封装的资源内容作为当前响应内容的一部分包含进来，从而实现可编程的服务器包含功能。被包含的servlet程序不能改变响应消息的状态码和响应头，如果它里面存在这样的语句，这些语句的执行结果将被忽略。</p>
<h3 id="转发和包含的小细节："><a href="#转发和包含的小细节：" class="headerlink" title="转发和包含的小细节："></a>转发和包含的小细节：</h3><p>转发：</p>
<ul>
<li>转发前后，源输出的任何响应正文无效</li>
<li>转发前会清空响应对象中的正文内容</li>
</ul>
<p>包含：</p>
<ul>
<li>只会包含目标的正文，头部信息包含前清空</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天写博客比以往都要早一点，从图书馆一回寝室就开始把今天学的凭记忆先记录下来，（其实主要还是怕贪玩又忘记写。）这是我写的第5篇博客，从上月22号坚持每天去图书馆刚好三周21天，是我戒烟的第25天。讲实话这些坚持真的让自己很难受，但当我看到这些统计出
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
</feed>
