<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>knight</title>
  <subtitle>knight</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/lgrknight/lgrknight.github.io/"/>
  <updated>2017-03-14T14:13:19.631Z</updated>
  <id>https://github.com/lgrknight/lgrknight.github.io/</id>
  
  <author>
    <name>knight</name>
    <email>lgrknight@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Request和Response的学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/14/Request%E5%92%8CResponse%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/14/Request和Response的学习笔记/</id>
    <published>2017-03-14T11:29:30.000Z</published>
    <updated>2017-03-14T14:13:19.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天写博客比以往都要早一点，从图书馆一回寝室就开始把今天学的凭记忆先记录下来，（其实主要还是怕贪玩又忘记写。）这是我写的第5篇博客，从上月22号坚持每天去图书馆刚好三周21天，是我戒烟的第25天。讲实话这些坚持真的让自己很难受，但当我看到这些统计出的文字时又是满满的感动。</p>
</blockquote>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul>
<li>web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象和代表响应的request对象。</li>
<li>request和response对象既然代表请求和响应，那我们要获取客户端（浏览器）提交过来的数据，只需要找request对象就行了。要客户端输出数据，只需要找response对象就行了。<br><strong>注意：</strong> request中封装的是浏览器的信息和请求参数，即浏览器的请求；response中封装的是服务器向浏览器发送的数据、响应头和编码格式等，即服务器的响应。</li>
</ul>
<h2 id="二、HttpServletResponse-响应对象"><a href="#二、HttpServletResponse-响应对象" class="headerlink" title="二、HttpServletResponse 响应对象"></a>二、HttpServletResponse 响应对象</h2><h3 id="1、字节流向客户端输出中文数据"><a href="#1、字节流向客户端输出中文数据" class="headerlink" title="1、字节流向客户端输出中文数据"></a>1、字节流向客户端输出中文数据</h3><ul>
<li>默认情况下：浏览器是乱码的（他默认查GBK）<ol>
<li>解决方案一：更改浏览器的码表（不建议）</li>
<li>解决方案二(不建议)：向客户端输出一个<meta>标签,模拟了响应消息头：<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"></li>
<li>解决方案三（建议）:向客户端输出响应消息头：response.setHeader(“Content-Type”, “text/html;charset=UTF-8”);</li>
<li>解决方案四（建议）：向客户端输出响应消息头response.setContentType(“text/html;charset=UTF-8”);</li>
</ol>
</li>
</ul>
<p>案例代码：</p>
<pre><code>import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//字节流向客户端输出中文数据
public class ResponseDemo1 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
        test2(response);
    }

    //字节流输出数据查UTF-8
    private void test2(HttpServletResponse response) throws IOException {
        String data = &quot;不见了远处的青山&quot;;

        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        ServletOutputStream out = response.getOutputStream();
        out.write(data.getBytes(&quot;UTF-8&quot;));//默认情况下：浏览器是乱码的（他默认查GBK）
    }
    //字节流输出数据查本地码表
    private void test1(HttpServletResponse response) throws IOException {
        String data = &quot;不见了远处的青山&quot;;
        ServletOutputStream out = response.getOutputStream();
        out.write(data.getBytes());//String:  getBytes()查本地默认的码表GBK getBytes(String charset)查指定码表
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="2、字符流输出中文数据"><a href="#2、字符流输出中文数据" class="headerlink" title="2、字符流输出中文数据"></a>2、字符流输出中文数据</h3><ul>
<li>HttpServletResponse的实例由Tomcat服务器提供，默认查ISO-8859-1的。</li>
<li>Tomcat8.X ,默认编码就变为了UTF-8</li>
</ul>
<p>案例源码：</p>
<pre><code>import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//字符流输出中文数据
public class ResponseDemo2 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String data = &quot;幸福是什么呢&quot;;
        //改变字符流查的码表，还能告知客户端用UTF-8进行解码
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        out.write(data);
    }

    private void test1(HttpServletResponse response) throws IOException {
        String data = &quot;幸福是什么&quot;;
        //改变字符流查的码表
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        //告知客户端用UTF-8进行解码
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        out.write(data);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><p><strong>注意：</strong> 在开发中尽量使用字节流，因为字节流可以处理任何数据，而字符流只能用来处理文本。</p>
<h3 id="3、输出随机验证码图片：CAPTCHA图像"><a href="#3、输出随机验证码图片：CAPTCHA图像" class="headerlink" title="3、输出随机验证码图片：CAPTCHA图像"></a>3、输出随机验证码图片：CAPTCHA图像</h3><p>案例源码：</p>
<pre><code>import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//输出随机验证码图片：CAPTCHA图像
public class ResponseDemo3 extends HttpServlet {
    public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
        int width = 120;
        int height = 25;
        //创建一副内存图像
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        //得到画笔
        Graphics g = image.getGraphics();
        //开始画
        //边线
        g.setColor(Color.BLUE);
        g.drawRect(0, 0, width, height);
        //填充背景色
        g.setColor(Color.YELLOW);
        g.fillRect(1, 1, width-2, height-2);
        //话干扰线
        g.setColor(Color.GRAY);

        Random r = new Random();
        for(int i=0;i&lt;9;i++)
            g.drawLine(r.nextInt(width), r.nextInt(height), r.nextInt(width), r.nextInt(height));
        //验证码
        g.setColor(Color.RED);
        g.setFont(new Font(&quot;宋体&quot;, Font.ITALIC|Font.BOLD, 19));
        int x = 20;
        for(int i=0;i&lt;4;i++){
            g.drawString(r.nextInt(10)+&quot;&quot;, x,20 );
            //g.drawString(base.charAt(r.nextInt(base.length()))+&quot;&quot;, x, 20);
            x+=18;
        }
        //输出
        response.setHeader(&quot;Expires&quot;, &quot;-1&quot;);
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
        ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream());
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="4、控制客户端定时刷新"><a href="#4、控制客户端定时刷新" class="headerlink" title="4、控制客户端定时刷新"></a>4、控制客户端定时刷新</h3><pre><code>import java.io.IOException;
import java.util.Random;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//控制客户端定时刷新
public class ResponseDemo4 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        test2(response);
    }
    //定时刷新到别处
    private void test2(HttpServletResponse response) throws IOException {
        response.setContentType(&quot;text/htm;charset=UTF-8&quot;);
        response.setHeader(&quot;Refresh&quot;, &quot;2;URL=http://www.itheima.com&quot;);
        response.getWriter().write(&quot;登录成功，2秒后跳转到主页&quot;);
    }
    //定时刷新自己
    private void test1(HttpServletResponse response) throws IOException {
        Random r = new Random();
        //response.setHeader(&quot;Refresh&quot;, &quot;1&quot;);
        response.setIntHeader(&quot;Refresh&quot;, 1);
        response.getWriter().write(r.nextInt()+&quot;&quot;);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="5、控制缓存的时间"><a href="#5、控制缓存的时间" class="headerlink" title="5、控制缓存的时间"></a>5、控制缓存的时间</h3><ul>
<li>静态资源需要控制缓存时间</li>
<li>动态资源一般不要缓存</li>
</ul>
<p>案例源码：</p>
<pre><code>import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ResponseDemo5 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String data = &quot;不见了远处的青山&quot;;
        //让他缓存1个小时
        response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis()+1*60*60*1000);
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        response.getWriter().write(data);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="6、请求重定向"><a href="#6、请求重定向" class="headerlink" title="6、请求重定向"></a>6、请求重定向</h3><ul>
<li>演示请求重定向:可以重定向到任何地址上</li>
<li>发出2次请求</li>
<li>地址栏会发生变化</li>
</ul>
<p>案例源码：</p>
<pre><code>import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ResponseDemo6 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        response.sendRedirect(&quot;http://www.itheima.com&quot;);
    }
    //重定向到应用内的资源
    private void test1(HttpServletResponse response) throws IOException {
        //response.setStatus(302);
        //response.setHeader(&quot;Location&quot;, &quot;/day08_00_response/servlet/ResponseDemo7&quot;);
        response.sendRedirect(&quot;/day08_00_response/servlet/    ResponseDemo7&quot;);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="7、response细节"><a href="#7、response细节" class="headerlink" title="7、response细节"></a>7、response细节</h3><ul>
<li>getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOutputStream、PrintWriter对象。</li>
<li>getOutputStream和getWriter这两个方法互相排斥，调用其中的任何一个方法后，就不能再调用另一个方法。</li>
<li>servlet程序向ServletOutputStream和PrintWriter对象中写入的数据将被servlet引擎从response里面获取，servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。</li>
<li>servlet的service方法结束后，servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，servlet引擎将调用close方法关闭该输出对象。</li>
</ul>
<h2 id="三、HttpServletRequest-请求对象"><a href="#三、HttpServletRequest-请求对象" class="headerlink" title="三、HttpServletRequest 请求对象"></a>三、HttpServletRequest 请求对象</h2><blockquote>
<p>HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头的所有信息都封装在这个对象中，开发人员通过这个对象的方法，可以获得客户这些信息。</p>
</blockquote>
<h3 id="3-1常用方法"><a href="#3-1常用方法" class="headerlink" title="3.1常用方法"></a>3.1常用方法</h3><h4 id="3-1-1获得浏览器的信息"><a href="#3-1-1获得浏览器的信息" class="headerlink" title="3.1.1获得浏览器的信息"></a>3.1.1获得浏览器的信息</h4><blockquote>
<p>getRequestURL()方法返回客户端发出请求时完整的URL<br>getRequestURI()方法返回请求行中的资源名部分<br>getQueryString()方法返回请求行中的参数部分<br>getRemoteAddr()方法返回请求的客户机的完整IP地址<br>getRemoteHost()方法返回发出请求的客户机的完整主机名<br>getRemotePort()方法返回客户机所使用的网络端口号<br>getLocalAddr()方法返回Web服务器的IP地址<br>getLocalName()方法返回Web服务器的主机名<br>getMethod()得到客户机的请求方式</p>
</blockquote>
<h4 id="3-1-2获得浏览器的请求头"><a href="#3-1-2获得浏览器的请求头" class="headerlink" title="3.1.2获得浏览器的请求头"></a>3.1.2获得浏览器的请求头</h4><blockquote>
<p>getHeader(String name)方法<br>getHeaders(String name)方法<br>getHeaderNames方法</p>
</blockquote>
<p><strong>例1.获取请求头</strong></p>
<pre><code>import java.io.IOException;
import java.util.Enumeration;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class RequestDemo2 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //获取请求头，但是这个头可能出现多次，此时我们可以使用getHeaders方法
        String head = request.getHeader(&quot;Accept-Encoding&quot;);

            System.out.println(head);
        if(head.contains(&quot;gzip&quot;)){
            //看是否包含gzip头，若存在，再向其输出压缩数据
        }else{
            //不存在则输出没有压缩的数据
        }

        //当一个头出现多次
        Enumeration e = request.getHeaders(&quot;Accept-Encoding&quot;);
        while(e.hasMoreElements()){
            String value = (String) e.nextElement();
            System.out.println(value);
        }

        //获得所有的头和对应的值
           e = request.getHeaderNames();
        while(e.hasMoreElements()){
            String name = (String) e.nextElement();
            String value = request.getHeader(name);
            System.out.println(value);
        }
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre><h4 id="3-1-3获得浏览器请求参数（即浏览器提交的数据）"><a href="#3-1-3获得浏览器请求参数（即浏览器提交的数据）" class="headerlink" title="3.1.3获得浏览器请求参数（即浏览器提交的数据）"></a>3.1.3获得浏览器请求参数（即浏览器提交的数据）</h4><pre><code>import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.beanutils.BeanUtils;

import com.itheima.domain.User;
//获取请求参数
public class RequestDemo3 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        test8(request, response);
    }
    //终极解决方案：借助BeanUtil框架
    private void test8(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        User user = new User();
        System.out.println(&quot;封装前：&quot;+user);
        try {
            BeanUtils.populate(user, request.getParameterMap());
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(&quot;封装后：&quot;+user);
    }
    //getParameterMap获取参数:封装到JavaBean中
    private void test7(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //key:请求参数名 value:请求参数值数组
        Map&lt;String,String[]&gt; map = request.getParameterMap();
        User user = new User();
        System.out.println(&quot;封装前：&quot;+user);
        for(Map.Entry&lt;String, String[]&gt; me:map.entrySet()){
            String paramName = me.getKey();//参数名称
            String paramValues[] = me.getValue();//参数值
            try {
                PropertyDescriptor pd = new PropertyDescriptor(paramName, User.class);
                Method m = pd.getWriteMethod();//setter方法
                if(paramValues.length&gt;1){
                m.invoke(user, (Object)paramValues);//参考补充视频：反射main方法
                }else{
                    m.invoke(user, paramValues);
                }
            } catch (Exception e1) {
                e1.printStackTrace();
            }
        }
        System.out.println(&quot;封装后：&quot;+user);
    }
    //getParameterMap获取参数
    private void test6(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //key:请求参数名 value:请求参数值数组
        Map&lt;String,String[]&gt; map = request.getParameterMap();
        for(Map.Entry&lt;String, String[]&gt; me:map.entrySet()){
            System.out.println(me.getKey()+&quot;=&quot;+Arrays.asList(me.getValue()));
        }
    }

    //把请求参数的值封装到JavaBean中
    //约定优于编码：表单的输入域的name取值和JavaBean中的属性（getter和setter方法）保持一致
    private void test5(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {


        Enumeration&lt;String&gt; e = request.getParameterNames();//参数名
        User user = new User();
        System.out.println(&quot;封装前：&quot;+user);
        while(e.hasMoreElements()){
            String paramName = e.nextElement();//即是JavaBean中的属性名称
            String paramValue = request.getParameter(paramName);
            //setUsername(paramValue); setPassword(paramValue);
            //JavaBean的内省
        try {
            PropertyDescriptor pd = new PropertyDescriptor(paramName, User.class);
            Method m = pd.getWriteMethod();//setter方法
            m.invoke(user, paramValue);
            } catch (Exception e1) {
            e1.printStackTrace();
            }
        }
        System.out.println(&quot;封装后：&quot;+user);
    }    
//private void test4(HttpServletRequest request, HttpServletResponse response)
//            throws ServletException, IOException {
//        User user = new User();
//        System.out.println(&quot;封装前：&quot;+user);
//        String username = request.getParameter(&quot;username&quot;);
//        String password = request.getParameter(&quot;password&quot;);
//        String gender = request.getParameter(&quot;gender&quot;);
//        user.setUsername(username);
//        user.setPassword(password);
//        user.setGender(gender);
//        System.out.println(&quot;封装后：&quot;+user);
//    }    
    //以下内容只用简单的程序开发

    //获取所有的请求参数名和值
    private void test3(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        Enumeration&lt;String&gt; e = request.getParameterNames();//参数名
        while(e.hasMoreElements()){
            String paramName = e.nextElement();
            String values [] = request.getParameterValues(paramName);
            System.out.println(paramName+&quot;=&quot;+Arrays.asList(values));
        }
    }
    //获取重名请求参数的值
    private void test2(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String username = request.getParameter(&quot;username&quot;);//不区分get还是post的
        String passwords[] = request.getParameterValues(&quot;password&quot;);//获取重名的请求参数值
        System.out.println(username+&quot;:&quot;+Arrays.asList(passwords));
    }
    //获取单一的请求参数的值(用户所有的输入都是String)
    private void test1(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String username = request.getParameter(&quot;username&quot;);//不区分get还是post的
        String password = request.getParameter(&quot;password&quot;);
        System.out.println(username+&quot;:&quot;+password);
    }
    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h4 id="3-1-4请求参数的中文乱码问题"><a href="#3-1-4请求参数的中文乱码问题" class="headerlink" title="3.1.4请求参数的中文乱码问题"></a>3.1.4请求参数的中文乱码问题</h4><pre><code>import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//中文乱码问题
public class RequestDemo4 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //post提交时乱码解决方式：设置服务器打开请求数据时用的码表，即request使用的码表
        //request.setCharacterEncoding(&quot;UTF-8&quot;);

        String username = request.getParameter(&quot;username&quot;);
        System.out.println(username);

        //get提交时乱码解决方式：先使用iso8859-1得到数据，然后再使用正确的编码转换过来
        byte[] source = username.getBytes(&quot;iso8859-1&quot;);
        username = new String(source, &quot;UTF-8&quot;);
        System.out.println(username);

    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>使用post方式提交表单数据时需要注意几点：<ul>
<li>在html中我们使用<meta name="content-type" content="text/html; charset=UTF-8">规定保存此文件的格式，我们可以选中文件右键àProperties可以在下面的Default处看到文件的编码格式，是和我们设置的编码一致的。</li>
<li>表单在提交的时候我们需要查看浏览器使用哪张码表打开此表单，如果使用GBK打开此表单，那么填写在此表单中提交的数据也将使用GBK编码，提交到服务器之后request.getParameter默认会使用iso8859-1码表将获得的数据转换成字符串，此时会出现乱码。我们可以使用request.setCharacterEncoding(“GBK”);将Request使用的码表换成GBK，这样和浏览器使用的编码就一致了。</li>
</ul>
</li>
</ul>
<ul>
<li>使用get方式提交表单数据时需要注意：<ul>
<li>当使用get方式提交表单数据时，设置Request编码是无效的，于是我们需要先使用iso8859码表得到乱码数据，然后再使用何时的码表将乱码转换成正确的文本数据。这是看视频教程中是这样解决的，但是在自己本地却不好使，当我的网页使用UTF-8打开时提交的数据能正确显示，但是如果使用GBK打开则不能正确显示。也就是网页使用UTF-8编码的数据提交才能正确显示，不是默认去查iso8859-1吗，这难道是tomcat的原因？？？？</li>
<li>还有个问题没有解决：就是当直接使用地址<a href="http://localhost:8080/ResAndReq/servlet/RequestDemo4?username=&#39;中国" target="_blank" rel="external">http://localhost:8080/ResAndReq/servlet/RequestDemo4?username=&#39;中国</a>‘ 访问服务器时，不需要设置任何编码就可以显示正确的文本。而且不管浏览器使用什么编码我们在地址栏中都可以看到正确的文本。URL其实对于汉字是直接使用的ASCII码，只是每个字的编码前加上一个%号？？？？</li>
<li>最后还可以更改服务器配置文件，在server.xml中的<connector>标签的最后加上一个属性：URIEncoding=”UTF-8”即可。这时什么都不需要设置了直接使用String username = request.getParameter(“username”);这种方式一般不适用.这里我们还有一种灵活的方式,在<connector>标签添加下面这个属性将useBodyEncodingForURI属性设置为true，那么如果我们request.setCharacterEncoding(“UTF-8”);之后连接器就使用什么编码。不管是什么方式，但是更改服务器的配置文件一般不推荐。</connector></connector></li>
</ul>
</li>
</ul>
<h3 id="请求重定向和请求转发的区别："><a href="#请求重定向和请求转发的区别：" class="headerlink" title="请求重定向和请求转发的区别："></a>请求重定向和请求转发的区别：</h3><p><img src="http://i.imgur.com/RwfiPOf.png" alt=""></p>
<p>（1）一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发。这里的两个servlet共享一个request和response对象。同时地址栏不会发生变化。<br>（2）一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源，称之为请求重定向。地址栏会发生变化。<br>（3）RequestDispatcher.forward方法只能将请求转发给同一个web应用中的组件（即多个servlet）；而HttpServletResponse.sendRedirect方法可以重定向到同一个站点上的其他应用程序中的资源（多个web应用），甚至是使用绝对URL重定向到其他站点的资源。<br>（4）调用HttpServletResponse.sendRedirect方法重定向的访问过程结束后，浏览器地址栏中显示的URL地址会发生变化，由初始的URL地址变成重定向的目标URL；调用RequestDispatcher.forward方法的请求转发过程结束后，浏览器地址栏保持初始的URL地址。<br>（5）HttpServletResponse.sendRedirect方法对浏览器的请求直接做出响应，响应的结果就是告诉浏览器去重新发出对另外一个URL的访问请求；RequestDispatcher.forward方法在服务器端内部将请求转发给另外一个资源（servlet），浏览器只知道发出了请求并得到了响应结果，并不知道在服务器内部发生了转发行为。<br>（6）RequestDispatcher.forward方法调用者与被调用者之间共享相同的request和response对象，它们属于同一个访问请求和响应过程；而HttpServletResponse.sendRedirect方法调用者与被调用者使用各自的request和response对象，它们属于两个独立的访问请求和响应过程。<br>（7）include方法<br>RequestDispatcher.include方法用于将RequestDispatcher对象封装的资源内容作为当前响应内容的一部分包含进来，从而实现可编程的服务器包含功能。被包含的servlet程序不能改变响应消息的状态码和响应头，如果它里面存在这样的语句，这些语句的执行结果将被忽略。</p>
<h3 id="转发和包含的小细节："><a href="#转发和包含的小细节：" class="headerlink" title="转发和包含的小细节："></a>转发和包含的小细节：</h3><p>转发：</p>
<ul>
<li>转发前后，源输出的任何响应正文无效</li>
<li>转发前会清空响应对象中的正文内容</li>
</ul>
<p>包含：</p>
<ul>
<li>只会包含目标的正文，头部信息包含前清空</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天写博客比以往都要早一点，从图书馆一回寝室就开始把今天学的凭记忆先记录下来，（其实主要还是怕贪玩又忘记写。）这是我写的第5篇博客，从上月22号坚持每天去图书馆刚好三周21天，是我戒烟的第25天。讲实话这些坚持真的让自己很难受，但当我看到这些统计出
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>Servlet学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/13/Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/13/Servlet学习笔记/</id>
    <published>2017-03-13T12:43:20.000Z</published>
    <updated>2017-03-14T00:09:03.338Z</updated>
    
    <content type="html"><![CDATA[<p>这本是昨晚应该发的博客，但昨晚玩“阴阳师”去了，拖延了一天，今天重新整理复习把servlet的知识在罗列整理一下。把阴阳师卸了。。。</p>
<h2 id="1、Servlet简介"><a href="#1、Servlet简介" class="headerlink" title="1、Servlet简介"></a>1、Servlet简介</h2><ul>
<li>Servlet技术基于Request-Response编程模型 —- HTTP协议也是基于此模型（请求-响应模型） </li>
<li>Servlet中的方法<br><code>public void service(ServletRequest req,ServletResponse res)
throws ServletException,java.io.IOException</code><br><code>ServletRequest req:</code>代表着请求对象，该对象中有HTTP协议的请求部分的所有内容。它的实现类由服务器提供的，封装数据也是服务器来做的。<br><code>ServletResponse res：</code>代表着响应对象，该对象中由我们写数据（HTTP协议的响应部分）进去。它的实现类也是由服务器提供的。</li>
<li>执行过程<br><img src="http://i.imgur.com/7aMDTvN.png" alt=""></li>
</ul>
<h2 id="2、关于Servlet的一些类"><a href="#2、关于Servlet的一些类" class="headerlink" title="2、关于Servlet的一些类"></a>2、关于Servlet的一些类</h2><ul>
<li><p>Servlet接口</p>
<ul>
<li>定义了所有Servlet需要实现的方法</li>
<li>它定义了init destory service等方法</li>
<li>为了解决基于请求-响应模型的数据处理（没有涉及与HTTP协议相关的API）</li>
</ul>
</li>
<li><p>GenericServlet抽象类</p>
<ul>
<li>它是Servlet接口的实现类</li>
<li>它扩展了一些方法</li>
<li>也没有涉及与HTTP协议相关的API</li>
</ul>
</li>
<li><p>HttpServlet抽象类</p>
<ul>
<li>它继承于GenericServlet</li>
<li>它新增了一些与HTTP协议相关的方法，如doGet，doPost等等</li>
<li>HttpServlet在实现Servlet接口时，覆写了service方法，该方法内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，程序员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。<br><img src="http://i.imgur.com/5Dy9rMH.png" alt=""></li>
</ul>
</li>
<li>HttpServlet比Servlet更为强大，也可以保护Servlet接口不被轻易改动，所以程序员自己创建的Servlet都是继承于HttpServlet，从而间接地实现了Servlet接口。</li>
</ul>
<h2 id="3、Servlet生命周期"><a href="#3、Servlet生命周期" class="headerlink" title="3、Servlet生命周期"></a>3、Servlet生命周期</h2><ul>
<li>生命周期<ol>
<li>实例化：Servlet 容器创建 Servlet 的实例</li>
<li>初始化 ：该容器调用 init 方法</li>
<li>请求处理：如果请求 Servlet，则容器调用 service 方法</li>
<li>服务终止：销毁实例之前调用 destroy 方法</li>
</ol>
</li>
</ul>
<blockquote>
<p>其中，init方法只有在Servlet第一次被请求加载时被调用一次，当有客户再请求Servlet服务时，web服务器将启动一个新的线程，在该线程中，调用service方法响应客户的请求。<br><strong>一个Servlet可以配置多个url-pattern</strong></p>
<ul>
<li>URL 配置格式 三种：<ol>
<li>完全路径匹配 (以/开始 ) 例如：/hello/init </li>
<li>目录匹配 (以/开始) 例如：/<em> 、 /abc/</em><br><code>/</code> 代表网站根目录<br><code>/*</code>表示任何路径都可以匹配到这个Servlet<br><code>/abc/*</code>表示abc目录下的任何路径都可以匹配到这个Servlet</li>
<li>扩展名 (不能以/开始) 例如：<em>.do、 </em>.action</li>
</ol>
</li>
</ul>
</blockquote>
<ul>
<li>优先级：完全匹配&gt;目录匹配 &gt; 扩展名匹配 </li>
</ul>
<h2 id="4、ServletConfig获得初始化参数"><a href="#4、ServletConfig获得初始化参数" class="headerlink" title="4、ServletConfig获得初始化参数"></a>4、ServletConfig获得初始化参数</h2><ul>
<li>init方法中的ServletConfig对象<ul>
<li>getInitParameter（String)—— 通过name获得value</li>
<li>getInitParameterNames() —– 获得所有name </li>
</ul>
</li>
<li>结论：子类Servlet不需要覆写init(ServletConfig), 只需要通过GenericServlet中 getServletConfig()方法来获得ServletConfig对象。<blockquote>
<p>ServletConfig 配置初始化数据，只能在配置Servlet获得，其它Servlet无法获得 —– 每个Servlet程序都对应一个ServletConfig对象 </p>
</blockquote>
</li>
</ul>
<h2 id="5、web引用对象——ServletContext"><a href="#5、web引用对象——ServletContext" class="headerlink" title="5、web引用对象——ServletContext"></a>5、web引用对象——ServletContext</h2><ul>
<li>web容器在启动时，它会为每一个web应用创建一个ServletContext对象，这个对象代表当前web应用。</li>
<li>操作ServletContext必须通过ServletConfig获得对象。可以通过ServletConfig.getServletContext方法来获得ServletContext对象。</li>
<li><p>由于一个web应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。<br><strong>应用：</strong></p>
<ol>
<li>获得整个web应用初始化参数</li>
</ol>
<ul>
<li>和ServletConfig对象有什么不同？<br>如果用ServletConfig对象配置参数，只对配置的Servlet有效，如果通过ServletContext对象配置参数，所有的Servlet都可以访问。</li>
<li>配置方法，在web.xml中添加如下格式的代码：</li>
<li>获得 hobby 全局参数：<br>  // 通过ServletConfig 获得 ServletContext<pre><code>`ServletContext context = getServletConfig().getServletContext();`
// 上面写法可以简化一下
`ServletContext context = getServletContext();`
// 读取全局初始化参数
`System.out.println(context.getInitParameter(&quot;hobby&quot;));`
</code></pre></li>
</ul>
<ol>
<li>实现全局数据共享</li>
</ol>
<ul>
<li>预期效果：在ServletContext中 保存站点访问次数 ，每当一个用户访问站点，将访问次数+1。所有Servlet都可以获得该数据</li>
<li>在CountServlet 初始化过程中，向ServletContext 保存访问次数为0。<br>利用<code>ServletContext.setAttribute(&quot;KEY&quot;,&quot;VALUE&quot;);</code></li>
<li><p>代码实现(只显示init方法和doGet方法：</p>
<pre><code>public void init() throws ServletException {
    // 向ServletContext 保存访问次数 0
    // 获得ServletContext对象
    ServletContext context = getServletContext();
    // 保存数据 setAttribute
    context.setAttribute(&quot;visittimes&quot;, 0);

}

public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
    // 每次访问 执行 doGet --- 将visittimes 次数 +1

    // 1、从ServletContext中获得 访问次数
    ServletContext context = getServletContext();
    int times = (Integer) context.getAttribute(&quot;visittimes&quot;);

    // 2、访问次数 +1
    times++;

    // 3、将访问次数更新回去 ServletContext
    context.setAttribute(&quot;visittimes&quot;, times);

    System.out.println(&quot;网站被访问了一次！&quot;);
}
</code></pre></li>
</ul>
<ol>
<li>实现服务器端转发功能（少见，现在多用request、response）</li>
<li>读取web工程资源文件（必须使用绝对磁盘路径）<ul>
<li>使用java application 读取文件，读取当前工程下所有文件 —– 使用相对路径读取文件。</li>
<li>使用Servlet读取文件只能读取WebRoot下所有文件(注意Servlet是运行在tomcat中的） —- 必须使用绝对磁盘路径读取文件。</li>
<li>如何获得绝对磁盘路径？<ul>
<li>通过站点根目录绝对路径获得磁盘绝对路径 —— <code>getServletContext().getRealPath(&quot;/WEB-INF/XXX.txt&quot;)</code></li>
<li>因为 WEB-INF/classes 非常特殊 （存放.class文件目录），被类加载器加载，可以通过Class类对象读取该目录下文件（假设该Servlet名字叫做ReadFileServlet）。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="6、缺省Servlet"><a href="#6、缺省Servlet" class="headerlink" title="6、缺省Servlet"></a>6、缺省Servlet</h2><ul>
<li>如果某个Servlet的映射路径仅仅为一个正斜杠“/”，那么这个Servlet就成为当前web应用的缺省Servlet。</li>
<li>凡是在web.xml文件中找不到匹配的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理其他Servlet都不处理的访问请求。</li>
<li>在<tomcat的安装目录>\conf\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。</tomcat的安装目录></li>
<li>当访问tomcat服务器中的某个静态HTML和图片时，实际上是在访问这个缺省的Servlet。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本是昨晚应该发的博客，但昨晚玩“阴阳师”去了，拖延了一天，今天重新整理复习把servlet的知识在罗列整理一下。把阴阳师卸了。。。&lt;/p&gt;
&lt;h2 id=&quot;1、Servlet简介&quot;&gt;&lt;a href=&quot;#1、Servlet简介&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/11/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/11/HTTP协议/</id>
    <published>2017-03-11T10:37:39.000Z</published>
    <updated>2017-03-14T00:11:01.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、HTTP协议概述"><a href="#1、HTTP协议概述" class="headerlink" title="1、HTTP协议概述"></a>1、HTTP协议概述</h2><ul>
<li>HTTP是什么？超文本传输协议。<br>描述客户端和服务器端的数据标准，该协议由W3C维护和管理。<br>版本：</li>
<li>HTTP1.0:每次发出请求都需要建立网络连接</li>
<li>HTTP1.1:(主流)在一次网络连接上发出多次请求和得到多次响应。多了一些头。</li>
<li>明确：<br>浏览器遇到以下标记时，会自动发出请求<br><img src="http://i.imgur.com/dhiU7TO.jpg" alt=""></li>
</ul>
<h2 id="2、HTTP协议的组成"><a href="#2、HTTP协议的组成" class="headerlink" title="2、HTTP协议的组成"></a>2、HTTP协议的组成</h2><ul>
<li>2.1请求部分<br><img src="http://i.imgur.com/1YIseVf.jpg" alt=""></li>
<li>2.2响应部分<br><img src="http://i.imgur.com/77vLg7f.jpg" alt=""></li>
</ul>
<h2 id="3、请求部分详解"><a href="#3、请求部分详解" class="headerlink" title="3、请求部分详解"></a>3、请求部分详解</h2><ul>
<li><p>3.1请求行：<br><code>GET /app1/1.html HTTP/1.1</code><br>GET：请求方式。<br>常用的请求方式：GET(默认的)、POST、HEAD、OPTIONS等<br>GET：默认的<br><a href="http://localhost:8080/app1/1.html?username=abc&amp;password=123" target="_blank" rel="external">http://localhost:8080/app1/1.html?username=abc&amp;password=123</a><br>提交的数据显示出来了，相对不安全，协议的第一行有长度限制，<1kb. (有请求数据时推荐)post：可以通过<form="" method="”post”/"></1kb.></p>
<pre><code>      username=abc&amp;password=123
         提交的数据在请求正文中的，相对安全，长度没有限制。

/app1/1.html ：请求的资源地址。（URI）
       URL：协议+主机：端口+资源地址
              http://localhost:8080/app1/1.html
</code></pre><p>HTTP/1.1:客户端浏览器使用的协议的版本。</p>
</li>
</ul>
<ul>
<li>3.2请求消息头：（做好笔记，记住常用的头）<ul>
<li>作用：向服务器端传递附加信息（暗号指令）</li>
<li>Accept:告知服务器，客户端可以接受的数据类型（MIME类型）</li>
<li>文件系统：通过文件的扩展名区分不同的文件的。txt jpeg</li>
<li>MIME类型：大类型/小类型。  txt—&gt;text/plain   html—-&gt;text/html js—-&gt;text/javascript (具体对应关系：Tomcat\conf\web.xml) </li>
<li>Accept-Encoding：告知服务器，客户端可以接受的压缩编码。比如gzip</li>
<li>Accept-Language：告知服务器，客户端支持的语言</li>
<li>Referer：告知服务器，从哪个页面过来的。<ul>
<li>作用：统计广告的投放效果；防止盗链。</li>
</ul>
</li>
<li>Content-Type：告知服务器，请求正文的MIME类型<ul>
<li>默认类型：application/x-www-form-urlencoded(表单enctype属性的默认取值)</li>
<li>具体体现：username=abc&amp;password=123</li>
<li>其他类型：multipart/form-data(文件上传时用的)</li>
</ul>
</li>
<li>If-Modified-Since：告知服务器，当前访问的资源，缓存中的文件的最后修改时间。</li>
<li>User-Agent:告知服务器，浏览器的类型</li>
<li>Content-Length：请求正文的数据长度</li>
<li>Cookie：（<strong>*</strong>重要）会话管理有关</li>
</ul>
</li>
</ul>
<ul>
<li>3.3请求正文：<br>数据能提交到服务器，表单中的输入域必须有name属性值<br>POST请求是才有正文<br>username=abc&amp;password=123</li>
</ul>
<h2 id="4、响应部分详解"><a href="#4、响应部分详解" class="headerlink" title="4、响应部分详解"></a>4、响应部分详解</h2><ul>
<li><p>4.1响应行：<br><code>HTTP/1.1 200 OK</code></p>
<ul>
<li>HTTP/1.1 ：说明服务器端用的协议版本</li>
<li>200 ：响应状态码</li>
<li>1XX 2XX 3XX 4XX 5XX</li>
<li>2XX:处理完毕</li>
<li>4XX：请求有误</li>
<li>5XX：服务器有误</li>
<li>记住常用的响应码：<ul>
<li>200：一切正常</li>
<li>302/307:请求重定向</li>
<li>304：服务器上的资源没有发生改变</li>
<li>404：访问的地址不存在</li>
<li>500：服务器端错误</li>
<li>OK：响应吗描述</li>
</ul>
</li>
</ul>
</li>
<li><p>4.2响应消息头：</p>
<ul>
<li>作用：服务器端向客户端传递的附加信息（暗号指令）</li>
<li>Location：告知客户端，你去访问的地址。<br>和302/307实现请求重定向</li>
<li>Content-Encoding：告知客户端，响应正文使用的压缩编码（gzip）</li>
<li>Content-Length:告知客户端，响应正文的长度</li>
<li>Content-Type：告知客户端，响应文正的MIME类型。默认text/html</li>
<li>Refresh:告知客户端，定时刷新</li>
<li>Content-Disposition：告知客户端，用下载的方式打开<br>attachment;filename=23.jpg</li>
<li><p>Set-Cookie:(<strong>*</strong>)会话有关</p>
</li>
<li><p>Expires: -1 控制时间的</p>
</li>
<li>Cache-Control: no-cache (1.1) </li>
<li>Pragma: no-cache   (1.0)<br>三头一块用，用于告知浏览器，不要缓存。</li>
</ul>
</li>
<li><p>4.3响应正文：<br>浏览器解析的正文内容，右键查看源码一样的</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、HTTP协议概述&quot;&gt;&lt;a href=&quot;#1、HTTP协议概述&quot; class=&quot;headerlink&quot; title=&quot;1、HTTP协议概述&quot;&gt;&lt;/a&gt;1、HTTP协议概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTTP是什么？超文本传输协议。&lt;br&gt;描述客户端和服务器端的数
    
    </summary>
    
    
      <category term="http" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>利用JAXP进行SAX解析</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/11/%E5%88%A9%E7%94%A8JAXP%E8%BF%9B%E8%A1%8CSAX%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/11/利用JAXP进行SAX解析/</id>
    <published>2017-03-10T16:03:44.000Z</published>
    <updated>2017-03-12T10:36:03.332Z</updated>
    
    <content type="html"><![CDATA[<p>昨天学习了JAXP的DOM解析，今天有学了一下JAXP的SAX解析。相对于DOM解析，SAX解析是针对DOM解析需要读取整个xml才能构建DOM树。对于比较大的xml，容易导致内存溢出的缺点而诞生的。（不耗费很多的内存）；缺点是只适合查询。</p>
<ul>
<li>SAX：Simple API for XML。来自开源社区。</li>
<li>原理：<br><img src="http://i.imgur.com/MzzYlaV.png" alt=""><br>SAX解析是读到XML文档的每一部分，就立刻进行解析。调用对应处理器的响应方法。</li>
</ul>
<p><strong>//理解SAX解析的原理</strong></p>
<ul>
<li>// 得到创建解析器的工厂<br><code>SAXParserFactory spf = SAXParserFactory.newInstance();</code></li>
<li>// 得到解析器<br><code>SAXParser parser = spf.newSAXParser();</code></li>
<li>// 得到读取器<br><code>XMLReader reader = parser.getXMLReader();</code></li>
<li>// 给读取器注册内容处理器（ContentHandler）<br><code>reader.setContentHandler(new MyContentHandler());</code></li>
<li><p>// 解析文档<br><code>reader.parse(&quot;src/book.xml&quot;);</code></p>
</li>
<li><p>内容处理器</p>
<pre><code>class MyContentHandler implements ContentHandler {

    public void startDocument() throws SAXException {
        System.out.println(&quot;读到了文档的开始&quot;);
    }

    public void endDocument() throws SAXException {
        System.out.println(&quot;读到了文档的结束&quot;);
    }

    public void startElement(String uri, String localName, String qName,
    Attributes atts) throws SAXException {
        System.out.println(&quot;读到了元素的开始：&quot;+qName);
    }

    public void endElement(String uri, String localName, String qName)
            throws SAXException {
        System.out.println(&quot;读到了元素的结束：&quot;+qName);
    }

    public void characters(char[] ch, int start, int length)throws SAXException {
        System.out.println(&quot;读到了文本内容：&quot;+new String(ch,start,length));
    }

    public void setDocumentLocator(Locator locator) {

    }

    public void startPrefixMapping(String prefix, String uri)
        throws SAXException {

    }

    public void endPrefixMapping(String prefix) throws SAXException {

    }

    public void ignorableWhitespace(char[] ch, int start, int length)
        throws SAXException {

    }

    public void processingInstruction(String target, String data)
        throws SAXException {

    }

    public void skippedEntity(String name) throws SAXException {

    }
</code></pre><p>  }</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天学习了JAXP的DOM解析，今天有学了一下JAXP的SAX解析。相对于DOM解析，SAX解析是针对DOM解析需要读取整个xml才能构建DOM树。对于比较大的xml，容易导致内存溢出的缺点而诞生的。（不耗费很多的内存）；缺点是只适合查询。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SAX
    
    </summary>
    
    
      <category term="xml" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>利用JAXP开发包：DOM解析</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/09/%E5%88%A9%E7%94%A8JAXP%E5%BC%80%E5%8F%91%E5%8C%85%EF%BC%9ADOM%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/09/利用JAXP开发包：DOM解析/</id>
    <published>2017-03-09T14:31:47.000Z</published>
    <updated>2017-03-12T10:35:58.110Z</updated>
    
    <content type="html"><![CDATA[<p><strong>解析方式：（W3C</strong></p>
<ul>
<li>DOM：Document Object Model文档对象模型<ul>
<li>Node：节点<ul>
<li>Document：代表整棵树</li>
<li>Element:元素</li>
<li>Attr：属性（只有元素才有属性）</li>
<li>Text：文本</li>
</ul>
</li>
<li>有点：增删改查方便，简单</li>
<li>缺点：需要读取整个xml才能构建DOM树。对于比较大的xml，容易导致内存溢出。</li>
</ul>
</li>
<li>SAX：Simpl API for Xml</li>
</ul>
<p><strong>常用的XML解析器：</strong><br> <code>JAXP</code>、<code>Dom4J</code>、<code>JDom</code></p>
<p><strong>JAXP:</strong></p>
<ul>
<li>存在JDK中，SUN公司提供。</li>
<li>Java API for XML Processing=JAXP</li>
<li>由以下包：</li>
<li>org.w3c.dom:标准和规范（学习规范）</li>
<li>javax.xml:具体的实现</li>
</ul>
<p><strong>演示：JAXP对LocList进行DOM方式的解析</strong></p>
<ul>
<li><p>//得到解析器，通过解析器加载XML文件，得到代表这个xml的Document对象<br>  //具体做法</p>
<ul>
<li>//得到创建解析器的工厂：DocumentBuilderFactory<br><code>DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</code></li>
<li>//通过工厂得到解析器：DocumentBuilder<br><code>DocumentBuilder builder = factory.newDocumentBuilder();</code></li>
<li>//加载xml文件：得到了Document对象<br><code>Document document = builder.parse(&quot;src/LocList.xml&quot;);</code> //向上转型</li>
</ul>
</li>
<li><p>进行一些元素操作之后，会有把内存中的Document写入xml文件的需求<br>//具体做法<br><code>TransformerFactory tf = TransformerFactory.newInstance();</code><br><code>Transformer ts = tf.newTransformer();</code><br><code>ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;解析方式：（W3C&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM：Document Object Model文档对象模型&lt;ul&gt;
&lt;li&gt;Node：节点&lt;ul&gt;
&lt;li&gt;Document：代表整棵树&lt;/li&gt;
&lt;li&gt;Element:元素&lt;/li&gt;
&lt;
    
    </summary>
    
    
      <category term="xml" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/xml/"/>
    
  </entry>
  
</feed>
