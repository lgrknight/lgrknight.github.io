<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>knight</title>
  <subtitle>knight</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/lgrknight/lgrknight.github.io/"/>
  <updated>2017-03-11T05:53:29.149Z</updated>
  <id>https://github.com/lgrknight/lgrknight.github.io/</id>
  
  <author>
    <name>knight</name>
    <email>lgrknight@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用JAXP进行SAX解析</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/11/%E5%88%A9%E7%94%A8JAXP%E8%BF%9B%E8%A1%8CSAX%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/11/利用JAXP进行SAX解析/</id>
    <published>2017-03-10T16:03:44.000Z</published>
    <updated>2017-03-11T05:53:29.149Z</updated>
    
    <content type="html"><![CDATA[<p>昨天学习了JAXP的DOM解析，今天有学了一下JAXP的SAX解析。相对于DOM解析，SAX解析是针对DOM解析需要读取整个xml才能构建DOM树。对于比较大的xml，容易导致内存溢出的缺点而诞生的。（不耗费很多的内存）；缺点是只适合查询。</p>
<ul>
<li>SAX：Simple API for XML。来自开源社区。</li>
<li>原理：<br><img src="http://i.imgur.com/MzzYlaV.png" alt=""><br>SAX解析是读到XML文档的每一部分，就立刻进行解析。调用对应处理器的响应方法。</li>
</ul>
<p><strong>//理解SAX解析的原理</strong></p>
<ul>
<li>// 得到创建解析器的工厂<br><code>SAXParserFactory spf = SAXParserFactory.newInstance();</code></li>
<li>// 得到解析器<br><code>SAXParser parser = spf.newSAXParser();</code></li>
<li>// 得到读取器<br><code>XMLReader reader = parser.getXMLReader();</code></li>
<li>// 给读取器注册内容处理器（ContentHandler）<br><code>reader.setContentHandler(new MyContentHandler());</code></li>
<li><p>// 解析文档<br><code>reader.parse(&quot;src/book.xml&quot;);</code></p>
</li>
<li><p>内容处理器</p>
<p>  class MyContentHandler implements ContentHandler {</p>
<pre><code>public void startDocument() throws SAXException {
System.out.println(&quot;读到了文档的开始&quot;);
}

public void endDocument() throws SAXException {
System.out.println(&quot;读到了文档的结束&quot;);
}

public void startElement(String uri, String localName, String qName,
    Attributes atts) throws SAXException {
System.out.println(&quot;读到了元素的开始：&quot;+qName);
}

public void endElement(String uri, String localName, String qName)
    throws SAXException {
System.out.println(&quot;读到了元素的结束：&quot;+qName);
}

public void characters(char[] ch, int start, int length)
    throws SAXException {
System.out.println(&quot;读到了文本内容：&quot;+new String(ch,start,length));
}

public void setDocumentLocator(Locator locator) {

}

public void startPrefixMapping(String prefix, String uri)
    throws SAXException {

}

public void endPrefixMapping(String prefix) throws SAXException {

}

public void ignorableWhitespace(char[] ch, int start, int length)
    throws SAXException {

}

public void processingInstruction(String target, String data)
    throws SAXException {

}

public void skippedEntity(String name) throws SAXException {

}
</code></pre><p>  }</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天学习了JAXP的DOM解析，今天有学了一下JAXP的SAX解析。相对于DOM解析，SAX解析是针对DOM解析需要读取整个xml才能构建DOM树。对于比较大的xml，容易导致内存溢出的缺点而诞生的。（不耗费很多的内存）；缺点是只适合查询。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SAX
    
    </summary>
    
    
      <category term="xml" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>利用JAXP开发包：DOM解析</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/09/%E5%88%A9%E7%94%A8JAXP%E5%BC%80%E5%8F%91%E5%8C%85%EF%BC%9ADOM%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/09/利用JAXP开发包：DOM解析/</id>
    <published>2017-03-09T14:31:47.000Z</published>
    <updated>2017-03-11T05:58:13.597Z</updated>
    
    <content type="html"><![CDATA[<p><strong>解析方式：（W3C</strong></p>
<ul>
<li>DOM：Document Object Model文档对象模型<ul>
<li>Node：节点<ul>
<li>Document：代表整棵树</li>
<li>Element:元素</li>
<li>Attr：属性（只有元素才有属性）</li>
<li>Text：文本</li>
</ul>
</li>
<li>有点：增删改查方便，简单</li>
<li>缺点：需要读取整个xml才能构建DOM树。对于比较大的xml，容易导致内存溢出。</li>
</ul>
</li>
<li>SAX：Simpl API for Xml</li>
</ul>
<p><strong>常用的XML解析器：</strong><br> <code>JAXP</code>、<code>Dom4J</code>、<code>JDom</code></p>
<p><strong>JAXP:</strong></p>
<ul>
<li>存在JDK中，SUN公司提供。</li>
<li>Java API for XML Processing=JAXP</li>
<li>由以下包：</li>
<li>org.w3c.dom:标准和规范（学习规范）</li>
<li>javax.xml:具体的实现</li>
</ul>
<p><strong>演示：JAXP对LocList进行DOM方式的解析</strong></p>
<ul>
<li><p>//得到解析器，通过解析器加载XML文件，得到代表这个xml的Document对象<br>  //具体做法</p>
<ul>
<li>//得到创建解析器的工厂：DocumentBuilderFactory<br><code>DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</code></li>
<li>//通过工厂得到解析器：DocumentBuilder<br><code>DocumentBuilder builder = factory.newDocumentBuilder();</code></li>
<li>//加载xml文件：得到了Document对象<br><code>Document document = builder.parse(&quot;src/LocList.xml&quot;);</code> //向上转型</li>
</ul>
</li>
<li><p>进行一些元素操作之后，会有把内存中的Document写入xml文件的需求<br>//具体做法<br><code>TransformerFactory tf = TransformerFactory.newInstance();</code><br><code>Transformer ts = tf.newTransformer();</code><br><code>ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;解析方式：（W3C&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM：Document Object Model文档对象模型&lt;ul&gt;
&lt;li&gt;Node：节点&lt;ul&gt;
&lt;li&gt;Document：代表整棵树&lt;/li&gt;
&lt;li&gt;Element:元素&lt;/li&gt;
&lt;
    
    </summary>
    
    
      <category term="xml" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/xml/"/>
    
  </entry>
  
</feed>
