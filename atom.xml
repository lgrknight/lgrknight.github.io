<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>knight</title>
  <subtitle>knight</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/lgrknight/lgrknight.github.io/"/>
  <updated>2017-09-23T15:43:53.171Z</updated>
  <id>https://github.com/lgrknight/lgrknight.github.io/</id>
  
  <author>
    <name>knight</name>
    <email>lgrknight@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>struts2_day01</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/09/23/struts2-day01/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/09/23/struts2-day01/</id>
    <published>2017-09-23T14:39:53.000Z</published>
    <updated>2017-09-23T15:43:53.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>博客很久没有更新了，也并不是段时间停止了学习，只是自己在生活中扮演了其他的角色，在其他方面学习。今天重新拾起博客，因为写博客是个好习惯，不管是记录学习内容还是记录生活其他经历经验，这份坚持都应该持续下去，但是放弃以前在写博客的一些不必要的执念，这个平台内容不需要多华丽的用词，不需要多精湛的技术分享记录，需要的是我一直坚持的真实表达。</p>
</blockquote>
<h3 id="什么是struts2"><a href="#什么是struts2" class="headerlink" title="什么是struts2"></a>什么是struts2</h3><ol>
<li>运行在web层，负责处理请求的。</li>
<li>struts2已经封装了很多web中常用的功能（拦截器）。</li>
<li>struts2与struts1没有什么关系，struts2主要是基于webwoke框架。</li>
</ol>
<h3 id="struts2框架搭建"><a href="#struts2框架搭建" class="headerlink" title="struts2框架搭建"></a>struts2框架搭建</h3><h4 id="1、导包"><a href="#1、导包" class="headerlink" title="1、导包"></a>1、导包</h4><pre><code>|-struts2/apps/struts-blank.war/WEB-INF/lib
</code></pre><h4 id="2、书写Action"><a href="#2、书写Action" class="headerlink" title="2、书写Action"></a>2、书写Action</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">Customer</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">private</span> CustomerService cs = <span class="keyword">new</span> CustomerServiceImpl();</div><div class="line">	<span class="keyword">private</span> Customer customer = <span class="keyword">new</span> Customer();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">//1 接受参数</span></div><div class="line">		String cust_name = ServletActionContext.getRequest().getParameter(<span class="string">"cust_name"</span>);</div><div class="line">		<span class="comment">//2 创建离线查询对象</span></div><div class="line">		DetachedCriteria dc =DetachedCriteria.forClass(Customer.class);</div><div class="line">		<span class="comment">//3 判断参数拼装条件</span></div><div class="line">		<span class="keyword">if</span>(StringUtils.isNotBlank(cust_name))&#123;</div><div class="line">			dc.add(Restrictions.like(<span class="string">"cust_name"</span>, <span class="string">"%"</span>+cust_name+<span class="string">"%"</span>));</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//4 调用Service将离线对象传递</span></div><div class="line">		List&lt;Customer&gt; list = cs.getAll(dc);</div><div class="line">		<span class="comment">//5 将返回的list放入request域.转发到list.jsp显示</span></div><div class="line">		ServletActionContext.getRequest().setAttribute(<span class="string">"list"</span>, list);</div><div class="line">		<span class="keyword">return</span> <span class="string">"list"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//添加客户</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		<span class="comment">//1 调用Service</span></div><div class="line">		cs.save(customer);</div><div class="line">		<span class="comment">//2 重定向到列表action方法</span></div><div class="line">		<span class="keyword">return</span> <span class="string">"toList"</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Customer <span class="title">getModel</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> customer;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、书写主配置文件-src-struts-xml"><a href="#3、书写主配置文件-src-struts-xml" class="headerlink" title="3、书写主配置文件 src/struts.xml"></a>3、书写主配置文件 src/struts.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></div><div class="line">	"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</div><div class="line">	"http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!-- i18n:国际化. 解决post提交乱码 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.i18n.encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">constant</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 指定反问action时的后缀名 </span></div><div class="line">		http://localhost:8080/struts2_day01/hello/HelloAction.do</div><div class="line">	--&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action"</span>&gt;</span><span class="tag">&lt;/<span class="name">constant</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 指定struts2是否以开发模式运行</span></div><div class="line">			1.热加载主配置.(不需要重启即可生效)</div><div class="line">			2.提供更多错误信息输出,方便开发时的调试</div><div class="line">	 --&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">constant</span>&gt;</span></div><div class="line">	</div><div class="line">	</div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- package:将Action配置封装.就是可以在Package中配置很多action.</span></div><div class="line">			name属性: 给包起个名字,起到标识作用.随便起.不能其他包名重复.</div><div class="line">			namespace属性:给action的访问路径中定义一个命名空间</div><div class="line">			extends属性: 继承一个 指定包</div><div class="line">			abstract属性:包是否为抽象的; 标识性属性.标识该包不能独立运行.专门被继承</div><div class="line">	  --&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">namespace</span>=<span class="string">"/hello"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> &gt;</span></div><div class="line">		<span class="comment">&lt;!-- action元素:配置action类</span></div><div class="line">				name属性: 决定了Action访问资源名.</div><div class="line">				class属性: action的完整类名</div><div class="line">				method属性: 指定调用Action中的哪个方法来处理请求</div><div class="line">		 --&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"HelloAction"</span> <span class="attr">class</span>=<span class="string">"cn.itheima.a_hello.HelloAction"</span> <span class="attr">method</span>=<span class="string">"hello"</span> &gt;</span></div><div class="line">			<span class="comment">&lt;!-- result元素:结果配置 </span></div><div class="line">					name属性: 标识结果处理的名称.与action方法的返回值对应.</div><div class="line">					type属性: 指定调用哪一个result类来处理结果,默认使用转发.</div><div class="line">					标签体:填写页面的相对路径</div><div class="line">			--&gt;</div><div class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"dispatcher"</span> &gt;</span>/hello.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">action</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">package</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 引入其他struts配置文件 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"cn/itheima/b_dynamic/struts.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"cn/itheima/c_default/struts.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="4、在web-xml配置过滤器"><a href="#4、在web-xml配置过滤器" class="headerlink" title="4、在web.xml配置过滤器"></a>4、在web.xml配置过滤器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- struts2的核心过滤器 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="struts2架构"><a href="#struts2架构" class="headerlink" title="struts2架构"></a>struts2架构</h3><p><img src="http://www.blogjava.net/images/blogjava_net/lzhidj/15.PNG" alt=""></p>
<p><strong>一个请求在Struts2框架中的处理大概分为以下几个步骤：</strong></p>
<ol>
<li><p>客户端初始化一个指向Servlet容器（例如Tomcat）的请求；</p>
</li>
<li><p>这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh Plugin）；</p>
</li>
<li><p>接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请求是否需要调用某个Action；</p>
</li>
<li><p>如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy；</p>
</li>
<li><p>ActionProxy通过Configuration Manager询问框架的配置文件，找到需要调用的Action类；</p>
</li>
<li><p>ActionProxy创建一个ActionInvocation的实例。</p>
</li>
<li><p>ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。</p>
</li>
<li><p>一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2框架中继承的标签。在这个过程中需要涉及到ActionMapper。</p>
</li>
</ol>
<p>FilterDispatcher是控制器的核心，就是mvc中c控制层的核心。下面粗略的分析下我理解的FilterDispatcher工作流程和原理：FilterDispatcher进行初始化并启用核心doFilter</p>
<h3 id="Action创建"><a href="#Action创建" class="headerlink" title="Action创建"></a>Action创建</h3><ol>
<li>POJO普通java类，不需要继承，不需要实现</li>
<li>实现Action接口</li>
<li>继承ActionSupport</li>
</ol>
<p>Action方法<br>    <code>public String XX() throws Exception{}</code><br>action方法返回String类型，不带参数，可抛异常。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;博客很久没有更新了，也并不是段时间停止了学习，只是自己在生活中扮演了其他的角色，在其他方面学习。今天重新拾起博客，因为写博客是个好习惯，不管是记录学习内容还是记录生活其他经历经验，这份坚持都应该持续下去，但是放弃以前在写博客的一些不必要的执念，这个
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>hibernate（一篇）</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/06/14/hibernate%EF%BC%88%E4%B8%80%E7%AF%87%EF%BC%89/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/06/14/hibernate（一篇）/</id>
    <published>2017-06-14T14:59:22.000Z</published>
    <updated>2017-06-14T15:23:47.716Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>我知道很多人的欲望很难突破，我也不赞成用压抑的方式去对待欲望。欲望事需要被穿越的，而穿越的方法有时候就是追逐、满足它。到了一定时候，你会像我一样精疲力竭，坐会到自己的位子上，才发现，原来我想要的一切，都已经在我出发地方等着我了。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我知道很多人的欲望很难突破，我也不赞成用压抑的方式去对待欲望。欲望事需要被穿越的，而穿越的方法有时候就是追逐、满足它。到了一定时候，你会像我一样精疲力竭，坐会到自己的位子上，才发现，原来我想要的一切，都已经在我出发地方等着我了。&lt;/p&gt;
&lt;/blo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/05/17/%E6%B3%A8%E8%A7%A3/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/05/17/注解/</id>
    <published>2017-05-17T15:40:31.000Z</published>
    <updated>2017-05-17T15:44:44.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解：（重点）"><a href="#注解：（重点）" class="headerlink" title="注解：（重点）"></a>注解：（重点）</h2><h3 id="1使用三个基本的注解"><a href="#1使用三个基本的注解" class="headerlink" title="1使用三个基本的注解"></a>1使用三个基本的注解</h3><p><code>@Deprecated</code><br><code>@SuppressWarnings</code><br><code>@Override</code></p>
<h3 id="2自定义注解：外形"><a href="#2自定义注解：外形" class="headerlink" title="2自定义注解：外形"></a>2自定义注解：外形</h3><p>a、定义注解的语法：<br><code>public @interface MyAnn{}</code>   父类：<code>Annotation</code><br>b、定义注解的属性<br>属性的类型 属性名() [default 默认值];（默认为public）</p>
<p><strong>属性的类型必须是：基本类型、String、Class、注解、枚举及以上类型的一维数组。</strong></p>
<p>注：value是一个特殊属性，赋值时不必给定属性名称。<br>注：给数组类型的属性，可以指定一个值。</p>
<p>不仅要会定义，而且还得会用。</p>
<h3 id="3注解的反射：注入了灵魂"><a href="#3注解的反射：注入了灵魂" class="headerlink" title="3注解的反射：注入了灵魂"></a>3注解的反射：注入了灵魂</h3><h4 id="a、反射注解"><a href="#a、反射注解" class="headerlink" title="a、反射注解"></a>a、反射注解</h4><p>java.lang.reflect.AnnotatedElement:<br><code>&lt;t extends Annotation&gt; getAnnotation(Class&lt;T&gt; annotation):</code>得到指定的注解<br><code>Annotation[] getAnnotations():</code>得到所有的注解<br><code>Annotation[] getDeclareAnnotations():</code>得到直接存在上面的注解<br><code>boolean isAnnotationPresent(Class&lt;T&gt; annotation):</code>判断有没有指定的注解<br>没有指定主语：<br>Class、Method、Field、Constructor、Package实现了该接口。</p>
<h4 id="b、元注解"><a href="#b、元注解" class="headerlink" title="b、元注解"></a>b、元注解</h4><p>元注解：服务于注解的注解。<br><code>@Retention：</code>用于改变注解的生命周期。<br><code>RetentionPolicy：</code><br><code>SOURCE:</code>源代码级别<br><code>CLASS：</code>字节码级别（磁盘上的）<br><code>RUNTIME：</code>字节码级别（运行时，虚拟机内存中的）<br><code>@Target：</code>用于给定注解使用的位置。<br><code>ElementType：</code><br><code>TYPE\METHOD等</code><br><code>@Documented：</code>用于标识使用了注解的类的javadoc文档中出现注解的身影。<br><code>@Inherited：</code>使用了注解的类的子类是否可以继承父类使用的注解。</p>
<p>今后：XML——————&gt;注解</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注解：（重点）&quot;&gt;&lt;a href=&quot;#注解：（重点）&quot; class=&quot;headerlink&quot; title=&quot;注解：（重点）&quot;&gt;&lt;/a&gt;注解：（重点）&lt;/h2&gt;&lt;h3 id=&quot;1使用三个基本的注解&quot;&gt;&lt;a href=&quot;#1使用三个基本的注解&quot; class=&quot;head
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>AJAX和国际化</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/05/16/AJAX%E5%92%8C%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/05/16/AJAX和国际化/</id>
    <published>2017-05-16T08:45:00.000Z</published>
    <updated>2017-05-16T09:18:02.564Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、AJAX简介"><a href="#一、AJAX简介" class="headerlink" title="一、AJAX简介"></a>一、AJAX简介</h3><p>1、Asynchronous JavaScript And XML指异步 JavaScript 及 XML<br>2、老技术新用法。是基于JavaScript、XML、HTML、CSS新用法</p>
<h3 id="二、同步和异步（理解）"><a href="#二、同步和异步（理解）" class="headerlink" title="二、同步和异步（理解）"></a>二、同步和异步（理解）</h3><h3 id="三、第一个异步请求案例（熟悉编码步骤）"><a href="#三、第一个异步请求案例（熟悉编码步骤）" class="headerlink" title="三、第一个异步请求案例（熟悉编码步骤）"></a>三、第一个异步请求案例（熟悉编码步骤）</h3><p><img src="http://i.imgur.com/XnjqLJY.png" alt=""></p>
<h3 id="四、XmlHttpRequest（JS）对象详解（重点）"><a href="#四、XmlHttpRequest（JS）对象详解（重点）" class="headerlink" title="四、XmlHttpRequest（JS）对象详解（重点）"></a>四、XmlHttpRequest（JS）对象详解（重点）</h3><ul>
<li>1、创建XmlHttpRequest对象<br>不同浏览器，设置相同浏览器的版本，创建该对象的方式是不同的。<br>解决办法：<ul>
<li>a、从w3cshool的文档中拷贝。</li>
<li>b、将来：用jQuery等框架</li>
</ul>
</li>
<li><p>2、XmlHttpRequest对象的属性</p>
<ul>
<li>a、readyState：short只读<br>标识着当前的请求状态<br><img src="http://i.imgur.com/Ta2HBk1.png" alt=""><br>0：XmlHttpRequest对象被创建了。此时为0<br>1：建立与服务器的链接，但是请求还没有发出去。此时为1。open(),send()还没有执行。<br>2：发出了请求，但是服务器没有任何响应。此时为2<br>3：接收到了服务器的响应，接收到了服务器发出的响应消息头时，此时3.<br>4：接收到了服务器发送的响应正文，响应结束。此时为4<br><img src="http://i.imgur.com/20dCrmp.png" alt=""><br>b、status：代表着响应状态码<br>c、statusText：响应码描述<br>d、responseText：字符串类型。代表着响应正文内容，把他当做文本对待<br>e、responseXML：Document。代表着响应正文内容，把他当做一个Document对象。（DOM）</li>
</ul>
</li>
<li><p>3、XmlHttpRequest的方法</p>
<ul>
<li>a、getAllResponseHeaders():返回的是所有的响应消息头。是一个字符串。</li>
<li>b、getResponseHeader(var headerName):返回指定响应消息头的值。是一个字符串。</li>
<li>c、open(var method,var url,boolean isAnsy):建立连接。<br>method，请求方式<br>url，请求的地址<br>isAnsy，同步还是异步。默认是true，就是异步。</li>
<li>d、send(var data):向服务器发送请求正文。如果是get请求，请求传入null.<br>如果是post请求：data =”username=abc&amp;password=123”</li>
<li>e、setRequestHeader(var headerName,var headerValue):向服务器发送请求消息头。</li>
</ul>
</li>
</ul>
<ul>
<li>4、XmlHttpRequest的状态监听器<br>onreadystatechange，指向是一个函数。回调函数。<br>何时触发执行，每次XHR对象的readyState发生变化都会触发。</li>
</ul>
<p>一般写法：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">xhr.onreadystatechange=function()&#123;</div><div class="line">	<span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(xhr.status==<span class="number">200</span>)&#123;</div><div class="line">			<span class="comment">//JS之DOM、BOM编程</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="五、案例"><a href="#五、案例" class="headerlink" title="五、案例"></a>五、案例</h3><h3 id="六、JSON-lib、Xstream简介"><a href="#六、JSON-lib、Xstream简介" class="headerlink" title="六、JSON-lib、Xstream简介"></a>六、JSON-lib、Xstream简介</h3><h3 id="七、二级联动（异步请求）"><a href="#七、二级联动（异步请求）" class="headerlink" title="七、二级联动（异步请求）"></a>七、二级联动（异步请求）</h3><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><h3 id="一、固定文本的国际化"><a href="#一、固定文本的国际化" class="headerlink" title="一、固定文本的国际化:"></a>一、固定文本的国际化:</h3><p><strong>一个消息资源包，由多个properties文件组成的(基名和扩展名一致的)。</strong></p>
<p>这些文件有着以下特点：</p>
<ul>
<li><p><code>基名_语言代码(ISO)_国家区域代码(ISO).properties</code></p>
</li>
<li><p><code>message_zh_CN.properties</code></p>
</li>
<li><code>message_en_US.properties</code></li>
<li><code>message.properties(默认的)</code><ul>
<li><code>ResourceBundle</code></li>
<li><code>Locale</code></li>
</ul>
</li>
</ul>
<h3 id="二、日期时间的格式化："><a href="#二、日期时间的格式化：" class="headerlink" title="二、日期时间的格式化："></a>二、日期时间的格式化：</h3><ul>
<li><p><code>DateFormat: SimpleDateFormat</code></p>
</li>
<li><p>用户输入：String————-&gt;java.util.Date<br><code>Date parse(String)</code></p>
</li>
<li><p>显示数据：java.util.Date————-&gt;String<br><code>String format(Date)</code></p>
</li>
</ul>
<h3 id="三、数字的格式化（货币）："><a href="#三、数字的格式化（货币）：" class="headerlink" title="三、数字的格式化（货币）："></a>三、数字的格式化（货币）：</h3><ul>
<li><p><code>NumberFormat:</code></p>
</li>
<li><p>用户输入：String————-&gt;java.lang.Number<br><code>Number parse(String)</code></p>
</li>
<li><p>显示数据：java.util.Number————-&gt;String<br><code>String format(Number)</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、AJAX简介&quot;&gt;&lt;a href=&quot;#一、AJAX简介&quot; class=&quot;headerlink&quot; title=&quot;一、AJAX简介&quot;&gt;&lt;/a&gt;一、AJAX简介&lt;/h3&gt;&lt;p&gt;1、Asynchronous JavaScript And XML指异步 JavaScrip
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>文件上传下载和监听器</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/05/10/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/05/10/文件上传下载和监听器/</id>
    <published>2017-05-10T12:56:05.000Z</published>
    <updated>2017-05-10T13:29:15.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>真正让你失望和绝望的，并不是你的希望，而是你对希望的执着。<br>有了希望，你会产生拒绝；没有希望，你才会接受一切。</p>
</blockquote>
<h3 id="一、文件上传"><a href="#一、文件上传" class="headerlink" title="一、文件上传"></a>一、文件上传</h3><h4 id="1、文件上传的原理分析"><a href="#1、文件上传的原理分析" class="headerlink" title="1、文件上传的原理分析"></a>1、文件上传的原理分析</h4><ul>
<li><p>1.1文件上传的必要前提：</p>
<ul>
<li>a、表单的method必须是post</li>
<li><p>b、表单的enctype属性必须是multipart/form-data类型的。<br>enctype默认值：application/x-www-form-urlencoded<br>作用：告知服务器，请求正文的MIME类型</p>
</li>
<li><p>application/x-www-form-urlencoded   ：   username=abc&amp;password=123</p>
</li>
</ul>
</li>
</ul>
<p>ServletRequest.getParameter(String name);该方法是专门读取该类型的方法</p>
<pre><code>* multipart/form-data:
</code></pre><p><img src="http://i.imgur.com/8NiPrmo.png" alt=""></p>
<ul>
<li>1.2文件上传<br>原理：解析请求正文中的内容。</li>
</ul>
<h4 id="2、借助第三方组件实现文件上传"><a href="#2、借助第三方组件实现文件上传" class="headerlink" title="2、借助第三方组件实现文件上传"></a>2、借助第三方组件实现文件上传</h4><ul>
<li>2.1、commons-fileupload组件：<br>拷贝jar包：commons-fileupload.jar   commons-io.jar 具体参考<br><a href="http://commons.apache.org/proper/commons-fileupload/using.html" target="_blank" rel="external">http://commons.apache.org/proper/commons-fileupload/using.html</a></li>
<li>2.2How it works<br><img src="http://i.imgur.com/SHkRomC.png" alt=""></li>
</ul>
<h4 id="3、文件上传详解"><a href="#3、文件上传详解" class="headerlink" title="3、文件上传详解"></a>3、文件上传详解</h4><ul>
<li><p>3.1DiskFileItemFactory<br><img src="http://i.imgur.com/gtqxJTE.png" alt=""><br>public void setRepository(File repository)：设置临时文件的存放目录<br>public void setSizeThreshold(int sizeThreshold)：设置缓存的大小</p>
</li>
<li><p><strong>专题：关于临时文件</strong><br><img src="http://i.imgur.com/g2bN00i.png" alt=""><br>文件上传时，自己用IO流处理，一定要在流关闭后删除临时文件。FileItem.delete()<br>建议使用：FileItem.writer(File f).会自动删除临时文件。</p>
</li>
<li><p>3.2乱码问题</p>
<ul>
<li>a、普通字段的乱码<br>FileItem.getString(String charset);编码要和客户端一致。</li>
<li>b、上传的中文文件名乱码<br>解决办法：request.setCharacterEncoding(“UTF-8”);编码要和客户端一致。</li>
</ul>
</li>
<li>3.3文件重名问题<br>解决办法：a.txt 多次上传会被覆盖<br>UUID_a.txt<br><img src="http://i.imgur.com/cq2pcw7.png" alt=""></li>
<li><p>3.4保证服务器的安全<br>把存放文件的目录，放到用户直接访问不到的地方。</p>
</li>
<li><p>3.5避免一个文件夹中的文件过多<br>解决方案：分目录存储<br>参考实现：</p>
<ul>
<li>按照日期分目录存储</li>
<li>按照文件名的hashCode计算存储目录</li>
</ul>
</li>
</ul>
<p><img src="http://i.imgur.com/hzUHfuZ.png" alt=""></p>
<ul>
<li><p>3.6限制上传文件的大小，并给出友好提示<br>web方式下不适合传输较大的文件。</p>
<ul>
<li><p>单文件大小：<br><code>ServletFileUpload.setFileSizeMax(3*1024*1024);</code>//设置单个文件上传的大小</p>
</li>
<li><p>总文件大小：（多文件上传）<br><code>ServletFileUpload.setSizeMax(6*1024*1024);</code>//多文件上传时总大小限制</p>
</li>
</ul>
</li>
<li>3.7限制上传文件的类型<br>扩展名+文件的MIME类型：<br>100%防止住：图片的。判断字节的前几位。</li>
</ul>
<h4 id="4、文件的下载"><a href="#4、文件的下载" class="headerlink" title="4、文件的下载"></a>4、文件的下载</h4><p>代码实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String uuidfilename = request.getParameter(<span class="string">"filename"</span>);<span class="comment">//get方式提交的</span></div><div class="line">uuidfilename = <span class="keyword">new</span> String(uuidfilename.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"UTF-8"</span>);<span class="comment">//UUID的文件名</span></div><div class="line">		</div><div class="line">String storeDirectory = getServletContext().getRealPath(<span class="string">"/WEB-INF/files"</span>);</div><div class="line"><span class="comment">//得到存放的子目录</span></div><div class="line">String childDirecotry = makeChildDirectory(storeDirectory, uuidfilename);</div><div class="line">		</div><div class="line"><span class="comment">//构建输入流</span></div><div class="line">InputStream in = <span class="keyword">new</span> FileInputStream(storeDirectory+File.separator+childDirecotry+File.separator+uuidfilename);</div><div class="line"><span class="comment">//下载</span></div><div class="line">String oldfilename = uuidfilename.substring(uuidfilename.indexOf(<span class="string">"_"</span>)+<span class="number">1</span>);</div><div class="line"><span class="comment">//通知客户端以下载的方式打开</span></div><div class="line">response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span>+URLEncoder.encode(oldfilename, <span class="string">"UTF-8"</span>));</div><div class="line">		</div><div class="line">OutputStream out = response.getOutputStream();</div><div class="line">		</div><div class="line"><span class="keyword">int</span> len = -<span class="number">1</span>;</div><div class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">while</span>((len=in.read(b))!=-<span class="number">1</span>)&#123;</div><div class="line">	out.write(b,<span class="number">0</span>,len);</div><div class="line">&#125;</div><div class="line">in.close();</div><div class="line">out.close();</div><div class="line"></div><div class="line"><span class="comment">//计算存放的子目录</span></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">makeChildDirectory</span><span class="params">(String realPath, String fileName)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> hashCode = fileName.hashCode();</div><div class="line">	<span class="keyword">int</span> dir1 = hashCode&amp;<span class="number">0xf</span>;<span class="comment">// 取1~4位</span></div><div class="line">	<span class="keyword">int</span> dir2 = (hashCode&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>;<span class="comment">//取5~8位</span></div><div class="line">	</div><div class="line">	String directory = <span class="string">""</span>+dir1+File.separator+dir2;</div><div class="line">	File file = <span class="keyword">new</span> File(realPath,directory);</div><div class="line">	<span class="keyword">if</span>(!file.exists())</div><div class="line">		file.mkdirs();</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> directory;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="二、Servlet规范中的监听器（回顾）"><a href="#二、Servlet规范中的监听器（回顾）" class="headerlink" title="二、Servlet规范中的监听器（回顾）"></a>二、Servlet规范中的监听器（回顾）</h3><h4 id="1、观察者设计模式："><a href="#1、观察者设计模式：" class="headerlink" title="1、观察者设计模式："></a>1、观察者设计模式：</h4><p>事件源：出发事件的对象。<br>事件：封装了事件源。<br>监听器：一般是一个接口，由使用者来实现。</p>
<h4 id="2、Servlet规范中提供的八个监听器"><a href="#2、Servlet规范中提供的八个监听器" class="headerlink" title="2、Servlet规范中提供的八个监听器"></a>2、Servlet规范中提供的八个监听器</h4><ul>
<li>a、监听ServletContext、HttpSession、ServletRequest创建和销毁的监听器<br><code>ServletContextListener:</code><br><code>HttpSessionListener:</code><br><code>ServletRequestListener:</code></li>
<li>b、监听ServletContext、HttpSession、ServletRequest属性的变化的监听器（attribute）<br>setAttribute() :添加和替换removeAttribute()<br><code>ServletContextAttributeListener:</code><br><code>HttpSessionAttributeListener:</code><br><code>ServletRequestAttributeListener:</code></li>
<li>c、感知型监听器。这种监听器不需要注册。都与会话有关<br><code>HttpSessionBindingListener:</code>感知自己被放到了HttpSession属性中<br><code>HttpSessionActivationListener：</code>感知自己何时随着HttpSession钝化或激活</li>
</ul>
<h4 id="3、监听器案例：查看在线登陆的用户，踢人。"><a href="#3、监听器案例：查看在线登陆的用户，踢人。" class="headerlink" title="3、监听器案例：查看在线登陆的用户，踢人。"></a>3、监听器案例：查看在线登陆的用户，踢人。</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;真正让你失望和绝望的，并不是你的希望，而是你对希望的执着。&lt;br&gt;有了希望，你会产生拒绝；没有希望，你才会接受一切。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、文件上传&quot;&gt;&lt;a href=&quot;#一、文件上传&quot; class=&quot;header
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>过滤器</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/05/07/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/05/07/过滤器/</id>
    <published>2017-05-07T13:17:44.000Z</published>
    <updated>2017-05-07T13:41:28.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>有了希望，你会产生拒绝; 没有希望，你会接受一切。</p>
</blockquote>
<h3 id="一、过滤器是什么？有什么？"><a href="#一、过滤器是什么？有什么？" class="headerlink" title="一、过滤器是什么？有什么？"></a>一、过滤器是什么？有什么？</h3><ul>
<li>1、过滤器属于Servlet规范，从2.3版本就开始有了。</li>
<li>2、过滤器就是对访问的内容进行筛选（拦截）。利用过滤器对请求和响应进行过滤<br><img src="http://i.imgur.com/tphTCRE.png" alt=""></li>
</ul>
<h3 id="二、编写步骤和执行过程"><a href="#二、编写步骤和执行过程" class="headerlink" title="二、编写步骤和执行过程"></a>二、编写步骤和执行过程</h3><ul>
<li><p>1、编码步骤：</p>
<ul>
<li><p>a、编写一个类：实现javax.servlet.Filter接口<br><img src="http://i.imgur.com/DHpgddE.png" alt=""></p>
</li>
<li><p>b、配置web.xml，指定需要过滤的资源。（和Servlet的配置相当类似）<br><img src="http://i.imgur.com/F56CJi2.png" alt=""></p>
</li>
</ul>
</li>
<li><p>2、过滤器的执行过程（生命周期）<br>  <img src="http://i.imgur.com/9r0ivIE.png" alt=""></p>
</li>
<li><p>生命周期：</p>
<ul>
<li>诞生：过滤器的实例是在应用被加载时就完成的实例化，并初始化的。</li>
<li>存活：和应用的生命周期一致的。在内存中是单例的。针对拦截范围内的资源访问，每次访问都会调用void doFIlter(request,response.chain)进行拦截。</li>
<li>死亡：应用被卸载。</li>
</ul>
</li>
<li><p>执行过程：<br><img src="http://i.imgur.com/CCogcDR.png" alt=""></p>
</li>
</ul>
<h3 id="三、串联过滤器"><a href="#三、串联过滤器" class="headerlink" title="三、串联过滤器"></a>三、串联过滤器</h3><p>一个过滤器接着另外一个过滤器。执行的顺序<br><img src="http://i.imgur.com/tgw81wN.png" alt=""></p>
<h3 id="四、案例："><a href="#四、案例：" class="headerlink" title="四、案例："></a>四、案例：</h3><ul>
<li>1、解决请求参数（POST）和响应输出的乱码过滤器</li>
<li>2、动态资源不要缓存的过滤器<br>Servlet/JSP：动态资源不要缓存。</li>
<li>3、静态资源控制缓存时间的过滤器</li>
<li>4、用户自动登录过滤器：<br>Base64编码：很重要<br><img src="http://i.imgur.com/P6s0CrO.png" alt=""><h3 id="五、过滤器配置的细节"><a href="#五、过滤器配置的细节" class="headerlink" title="五、过滤器配置的细节"></a>五、过滤器配置的细节</h3><img src="http://i.imgur.com/4BC83KZ.png" alt=""><br><img src="http://i.imgur.com/3Cv7RVb.png" alt=""></li>
</ul>
<h3 id="六、巩固装饰设计模式"><a href="#六、巩固装饰设计模式" class="headerlink" title="六、巩固装饰设计模式"></a>六、巩固装饰设计模式</h3><ul>
<li>一、装饰<ul>
<li>1、编写一个类，实现与被包装类（数据库驱动对Connection的实现）相同的接口。（使这个类和数据库的驱动实现有着相同的行为）</li>
<li>2、定义一个变量，引用被包装类的实例。</li>
<li>3、定义构造方法，传入被包装类的实例。</li>
<li>4、对于要改写的方法，编写自己的代码即可。</li>
<li>5、对于不需要改写的方法，调用原有对象的对应方法。</li>
</ul>
</li>
<li>二、装饰变体（BufferedReader本身就是包装类，对Reader的包装。LineNumberReader，对BufferedReader的包装，还是他的子类）<ul>
<li>1、编写一个类，继承已经是包装类的类。</li>
<li>2、定义一个变量，引用被包装类的实例。</li>
<li>3、定义构造方法，传入被包装类的实例。</li>
<li>4、覆盖掉需要改写的方法</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有了希望，你会产生拒绝; 没有希望，你会接受一切。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、过滤器是什么？有什么？&quot;&gt;&lt;a href=&quot;#一、过滤器是什么？有什么？&quot; class=&quot;headerlink&quot; title=&quot;一、过滤器是
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>jdbc学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/05/03/jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/05/03/jdbc学习笔记/</id>
    <published>2017-05-03T13:43:55.000Z</published>
    <updated>2017-05-03T15:31:09.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>内心存在的东西，就是“因”，外界给予的东西，就是“缘”。<br>因上努力，果上随缘。</p>
</blockquote>
<h3 id="一、JDBC简介"><a href="#一、JDBC简介" class="headerlink" title="一、JDBC简介"></a>一、JDBC简介</h3><ul>
<li>1、JDBC是SUN公司为了简化操作数据推出一套规范。数据库厂商的驱动就是对JDBC的实现。</li>
<li>2、Java Data Base Connectivity（java数据库连接），它主要由接口组成。<br>java.sql.<em>    javax.sql.</em>   JDK中<br>数据库的驱动jar包</li>
</ul>
<h3 id="二、JDBC的编码步骤"><a href="#二、JDBC的编码步骤" class="headerlink" title="二、JDBC的编码步骤"></a>二、JDBC的编码步骤</h3><ul>
<li>0、前提：拷贝数据库的驱动到构建路径中（classpath）</li>
<li>1、注册驱动</li>
<li>2、获取与数据库的链接</li>
<li>3、创建代表SQL语句的对象</li>
<li>4、执行SQL语句</li>
<li>5、如果是查询语句，需要遍历结果集</li>
<li>6、释放占用的资源</li>
</ul>
<p><img src="http://i1.piimg.com/567571/9c73f966a51950fe.png" alt=""></p>
<h3 id="三、事务入门（重点）"><a href="#三、事务入门（重点）" class="headerlink" title="三、事务入门（重点）"></a>三、事务入门（重点）</h3><ul>
<li>1、MySQL：每一条语句都属于独立事务,默认自动管理的。</li>
<li>2、开启事务：start transaction;   日后的语句都会处于同一个事务之中。<br>提交事务：commit;<br>回滚事务：rollback;</li>
<li>3、JDBC如何控制事务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">conn.setAutoCommit(<span class="number">0</span>);<span class="comment">//修改系统非自动提交。</span></div><div class="line">conn.commit();<span class="comment">//事务提交</span></div><div class="line">conn.rollback();<span class="comment">//事务回滚</span></div><div class="line">SavePoint sp=con.setSavePoint();<span class="comment">//设置保存点</span></div><div class="line">conn.rollback(sp);<span class="comment">//返回保存点</span></div><div class="line">conn.setTransactionIsolation();<span class="comment">//设置隔离级别</span></div><div class="line">conn.getTransactionIsolation();<span class="comment">//获取隔离级别</span></div></pre></td></tr></table></figure>
<ul>
<li>其中隔离级别的设置如下：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">设定事务的隔离级别：con.setTransactionIsolation(Connection.isolationLevel);</div><div class="line">四种隔离级别： </div><div class="line">con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);<span class="comment">//最底级别：只保证不会读到非法数据，上述3个问题有可能发生 </span></div><div class="line">con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED); <span class="comment">//默认级别：可以防止脏读 </span></div><div class="line">con.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);<span class="comment">//可以防止脏读和不可重复读取 </span></div><div class="line">con.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE); <span class="comment">//最高级别：防止上述3种情况，事务串行执行</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="四、事务的特性（重点。面试）"><a href="#四、事务的特性（重点。面试）" class="headerlink" title="四、事务的特性（重点。面试）"></a>四、事务的特性（重点。面试）</h3><ul>
<li>1、事务的特性：<br>原子性：处于事务中的多条语句是不可分割的。<br>一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。比如：转账，转账前A+B=2000，转账后A+B=2000<br>隔离性：多线程并发。一个事务不能被其他线程中的事务所打扰。<br>持久性：事务一旦提交，永久保存起来。</li>
<li>2、事务的隔离级别：属于事务的。都已开启了事务为前提。</li>
<li><p>不考虑事务的隔离级别，会出现以下情况（是错的）</p>
<ul>
<li>脏读：一个线程中的事务读到了另外一个线程中未提交的数据。</li>
<li>不可重复读：一个线程中的事务读到了另外一个线程中已经提交的update的数据。</li>
<li>虚读：一个线程中的事务读到了另外一个线程中已经提交的insert的数据。</li>
</ul>
</li>
<li><p>要想避免以上现象，通过更改事务的隔离级别来避免：</p>
<ul>
<li>READ UNCOMMITTED 脏读、不可重复读、虚读有可能发生。</li>
<li>READ COMMITTED 避免脏读的发生，不可重复读、虚读有可能发生。</li>
<li>REPEATABLE READ 避免脏读、不可重复读的发生，虚读有可能发生。</li>
<li>SERIALIZABLE 避免脏读、不可重复读、虚读的发生。</li>
</ul>
</li>
</ul>
<p>级别依次升高，效率依次降低。<br>MySQL：默认REPEATABLE READ<br>ORACLE：默认READ COMMITTED</p>
<p>MySQL：<br>select @@tx_isolation;//查看当前的隔离级别<br>set transaction isolation level 级别;// 设置当前的事务隔离级别</p>
<h3 id="五、数据库连接池原理：（理解）"><a href="#五、数据库连接池原理：（理解）" class="headerlink" title="五、数据库连接池原理：（理解）"></a>五、数据库连接池原理：（理解）</h3><p><img src="http://i4.buimg.com/567571/1f88728dcfd4cbbd.png" alt=""></p>
<h3 id="六、编程的难点：（设计模式）"><a href="#六、编程的难点：（设计模式）" class="headerlink" title="六、编程的难点：（设计模式）"></a>六、编程的难点：（设计模式）</h3><p>难点：用一个实现了javax.sql.DataSource类的实例时，用户如果调用Connection.close()方法，会把链接关闭，失去了连接池的意义。<br>明确一个问题：用户得到Connection的实现是：数据库驱动对Connection接口的实现。因此，调用的close方法都是数据库驱动的，它会把链接给关闭。（这不是我们要的，我们要把该链接换回池中）。</p>
<p>解决方案：改写驱动原有的close方法。对已知类的某个/某些方法进行功能上的改变，有以下几种编码方案：</p>
<ul>
<li>a、继承：此处行不通。<br>到底针对哪个驱动的实现写子类（很多）<br>数据库驱动对Connection接口的实现类，不允许被继承<br>丢失了原有对象的信息。捡了芝麻丢了西瓜。</li>
<li><p>b、装饰（包装）设计模式：（基础IO）<br>保持被包装对象的原有信息，又可以对某个/某些方法进行改写。<br>口诀：<br>1、编写一个类，实现与被包装类（数据库驱动对Connection的实现）相同的接口。（使这个类和数据库的驱动实现有着相同的行为）<br>2、定义一个变量，引用被包装类的实例。<br>3、定义构造方法，传入被包装类的实例。<br>4、对于要改写的方法，编写自己的代码即可。<br>5、对于不需要改写的方法，调用原有对象的对应方法。</p>
</li>
<li><p>c、默认适配器：（为了后来做准备）<br><img src="http://i1.piimg.com/567571/6bdaa625e79af855.png" alt=""><br><img src="http://i2.muimg.com/567571/0d525673562314e6.png" alt=""></p>
</li>
<li><p>d、动态代理：（很重要 AOP–Aspect-Oriented Programming 核心技术）<br>    基于接口的动态代理：Proxy<br>如果一个类没有实现任何的接口，此种代理就不能使用了。<br>    基于子类的动态代理：CGLIB<br>前提：被代理类的要求<br>1、不能是final的<br>2、必须是public的<br>比如普通的JavaBean就可能没有实现任何的接口。代理类是被代理类的子类。<br><img src="http://i2.muimg.com/567571/fb6e253d772a61c1.png" alt=""></p>
</li>
</ul>
<h3 id="七、数据库操作框架"><a href="#七、数据库操作框架" class="headerlink" title="七、数据库操作框架"></a>七、数据库操作框架</h3><ul>
<li>1、ORM：Object Relation Mapping<br>Hibernate：非常流行<br>JPA：Java Persistent API.ORM标准<br>MyBatis：2010年开始。之前叫做iBatis（重视）</li>
<li>2、JDBC封装框架<br>DBUtils<br>Spring JDBC Template</li>
</ul>
<h3 id="八、实际开发中事务如何管理-非常好"><a href="#八、实际开发中事务如何管理-非常好" class="headerlink" title="八、实际开发中事务如何管理(非常好)"></a>八、实际开发中事务如何管理(非常好)</h3><ul>
<li>1、写4个版本的代码：AOP</li>
<li>2、ThreadLocal（很重要）<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//特点：一个线程存的东西，只有该线程才能取出来。线程局部变量。</span></div><div class="line"><span class="comment">//模拟</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span></span>&#123;</div><div class="line">	<span class="comment">//类似Map的结构</span></div><div class="line">	<span class="keyword">private</span> Map&lt;Runnable,Object&gt; map = <span class="keyword">new</span> HashMap&lt;Runnable,Object&gt;();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">		map.put(Thread.currentThread(),obj);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</div><div class="line">		map.remove(Thread.currentThread());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">		map.get(Thread.currentThread());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;内心存在的东西，就是“因”，外界给予的东西，就是“缘”。&lt;br&gt;因上努力，果上随缘。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、JDBC简介&quot;&gt;&lt;a href=&quot;#一、JDBC简介&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>人生所有的路，都是必经之路</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/04/30/%E4%BA%BA%E7%94%9F%E6%89%80%E6%9C%89%E7%9A%84%E8%B7%AF%EF%BC%8C%E9%83%BD%E6%98%AF%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/04/30/人生所有的路，都是必经之路/</id>
    <published>2017-04-30T07:05:15.000Z</published>
    <updated>2017-04-30T16:14:06.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这段时间在缘分之下，得到了鬼脚七的这本《人生所有的路，都是必经之路》。然后通过观看书籍以及自己生活中的所遇内心有比较多复杂、自认为比较有意义的想法吧。我也怕自己会在随后的生活中淡忘，因为普通人是没办法一开始就从想法到行动吧，至少现如今我还处于这个状态吧。本来我也打算分篇去记录我的那些感悟，但是想着我的那些逻辑想法可能也比较随性，所以就统一在着在这一篇博客下持续更新吧。</p>
</blockquote>
<h3 id="（一）2017-04-02-15-05"><a href="#（一）2017-04-02-15-05" class="headerlink" title="（一）2017-04-02 15:05"></a>（一）2017-04-02 15:05</h3><p>好不易盼来了一个假期吧，开始是兴奋，兴奋过后是烦恼，烦恼这几天的假期如何度过，心中的第一想法就是不想和放假之前一样的度过。因为觉得自己放假前过的这日子还是太单调了，三点一线想来点不一样的元素，其实更直白贴近内心的原因或许就是放假了大家应该都去玩，自己不想一个人显的太孤单吧。是我害怕别人发现我那种状态吧，毕竟以前的假期是繁忙的希望有分身之术吧，既要想着陪女朋友，又要计划陪兄弟哥们。所以我在当晚就赶到我星沙那边的朋友那边去了，但是当我坐在过那边的车上我又是感觉对学校是那样的不舍，我又开始怀念学校这种固定的生活吧，我估计是被这个套子给套住了。总结：我以后做事情应该干脆果断点，在做一方面的事情，别在枯燥难受的时候又想着原先的快乐，出发点应该想清楚是不是自己真的喜欢，如果喜欢这一路都痛快的去追逐，过往不恋，记住第一性初衷。</p>
<h3 id="（二）2017-04-19-22-31"><a href="#（二）2017-04-19-22-31" class="headerlink" title="（二）2017-04-19 22:31"></a>（二）2017-04-19 22:31</h3><p>这段时间是真的比较急躁吧，越想做好一些事情越不知道如何下手，越想安静下来越浮动，每天极像充实又感觉什么没做，感觉不会在乎的事情又老是在眼前浮现，我似乎在等待着什么蓄势待发，可是现在流失的还比较多吧。讲真我也不懂对错，但是我也不会走退路的吧。有太多的未知就让他未来慢慢来吧。我近期也是用鬼脚七那句话反复对自己说，不知道不能解决的就交给佛陀吧，佛会解决的。其实是吧，不管你们质疑的佛陀是否存在，但我是有了寄托，让我内心没那么沉重，佛陀就帮我渡了些苦，何必又去为佛陀的是否存在平添苦恼呢，而且我也相信又佛陀菩萨，我们每个人都是佛陀吧，只是你没有去发现。我也真的得自律自己，一味的想着去模范佛陀做过的事，却忘却了心境的同步。从身边开始吧，做自己的佛陀。</p>
<h3 id="（三）2017-04-30-22-16"><a href="#（三）2017-04-30-22-16" class="headerlink" title="（三）2017-04-30 22:16"></a>（三）2017-04-30 22:16</h3><p>时间真是让人触不及防的东西吧。一转眼一个月的赛前培训结束，比赛也比完了。先不管收获或者留下多少遗憾，还是理性的分析总结和纪念下这段时光吧，也如标题所说。人生所有的路都是必经之路。</p>
<p>环顾着一个月其实可能最紧张的可能就是比赛的前一天了，比赛前一天把能想到能顾及的知识点都过了一遍，甚至挑了一些选择性背下来，但这样并不是想说我准备的多么充分，而是到了那个时候才感觉自己浪费了太多的时间，当然我转念一想其实这一辈子做的所有事其实在时间的资源上大家都是公平的，但是每个人能抓住的时间却出入特别大，大多比赛都会喜欢说“赛出风格，赛出水平”我觉得我们这次也赛出了风格、赛出了我们的水平吧，平时我们付出了多少，在比赛上就回馈了多少。赛后也一直在幻想如果侥幸进了国赛那应该多美好。。。。但转念一想也不好吧，如果真的让我们这样侥幸进了国赛，我们心里也只会觉得对手太垃圾，而不是我们有多么厉害，哈哈 ，大实话。这样也挺好，不及第一名的一半，这个现实真的很残酷好嘛，但没错这也告诫我们，在同龄同一件事上有人比我们做的更加的优秀这么多。这次要好好接受这个教训吧，也留下了遗憾，其实我还是感觉我们其实挺棒的，但还需要更加努力，一起更精进点。其实这个地方上次我也留了个遗憾在这里，上次坐了几个小时车跑到望城为了去靖港古镇，结果住了一天，靖港古镇没有去成。后面回到这个地方就有点物是人非的感觉，而且可能永远也不会去完成这个事情了。但也有感动的，上次去莫名的巧，除了在那学校的小贵，老熊和发卵在，小文和火鸟也在那里，上次热热闹闹的喝了一场（我被套路灌醉。。。），这次去小贵还是赛场负责人，俩人比完赛叫上老熊又去喝了一场。老感觉。大家这么就没见面都没变。哈哈戒了这么久的烟，我知道他们这要破了，我当时也担心估计到学校也会忍不住继续抽起来吧，但是是我多虑了，人还是该随性点的时候久随性点。其实也真的在我不同的时期能交到这些朋友，每个时期的朋友都像我人生的一次还原点，为什么这么说呢，和真正的朋友吧。我希望以前怎么玩怎么开心的过，当我们见面时，就像曾经一样的过。谁也不要让大家感觉自己变了。老铁们，我们一起记住我们的这段回忆，记住我们这些简单的快乐，我希望不管过去多久，以后再次见面我多么沧桑，记住你陪我走过那段时光，当我们再次见面时我依旧会那么年轻。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这段时间在缘分之下，得到了鬼脚七的这本《人生所有的路，都是必经之路》。然后通过观看书籍以及自己生活中的所遇内心有比较多复杂、自认为比较有意义的想法吧。我也怕自己会在随后的生活中淡忘，因为普通人是没办法一开始就从想法到行动吧，至少现如今我还处于这个状
    
    </summary>
    
    
      <category term="观看与感悟" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/%E8%A7%82%E7%9C%8B%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>AChartEngine绘画框架</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/28/AChartEngine%E7%BB%98%E7%94%BB%E6%A1%86%E6%9E%B6/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/28/AChartEngine绘画框架/</id>
    <published>2017-03-28T13:47:00.000Z</published>
    <updated>2017-03-28T14:30:05.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天是比赛准备的第二天，这几天主要在学习绘图方面的知识，今天学习了一个框架。这个是Android系统上用于绘图的框架，支持绘制折线图、面积图、散点图、时间图、进度表、条状图、饼图、圆环图等等。不过这个框架现在不在更新了，但比赛用到的还是这个框架，在学习过程中也发现了一个更好绘图框架MPAndroidChart，后续找时间学习并更新资料到博客。</p>
</blockquote>
<h3 id="AChartEngine的概述与分析"><a href="#AChartEngine的概述与分析" class="headerlink" title="AChartEngine的概述与分析"></a>AChartEngine的概述与分析</h3><p><strong>类之间的关系</strong><br><img src="http://i.imgur.com/oNSMJNx.jpg" alt=""></p>
<ul>
<li><p><strong>1. ChartDemo这个类是整个应用程序的入口,运行之后的效果显示一个list.</strong></p>
</li>
<li><p><strong>2. IDemoChart接口,这个接口定义了三个方法。</strong></p>
<ul>
<li><p>getName()返回值是listitem上显示的标题;</p>
</li>
<li><p>getDesc()返回值是listitem上显示的描述内容.</p>
</li>
<li><p>excute(context)返回值是一个Intent,当点击listitem后跳转到此Intent.</p>
</li>
</ul>
</li>
<li><p><strong>3. AbstractDemoChart类是一个抽象类,实现接口IDemoChart接口,这个类中封装了构建DataSet和renderer的方法,目的快速构建我们的dataset和renderer.这个类具体提供了哪些方法呢?见下图.至于为什么要进行这样的封装看完4中ChartFactory.get…Intent()方法的参数类型后您就明白了.</strong><br><img src="http://i.imgur.com/wCEAM0Z.jpg" alt=""></p>
</li>
<li><p><strong>4.  其他的以*Chat结尾的类大都继承自AbstractDemoChart这个类实现了接口IDemoChart.我们可以重点看一下execute(context)方法,分析之后发现这个方法中构建Intent的步骤大同小异,第一步构建dataset,第二步构建renderer,第三步调用ChartFactory.get…Intent()方法或ChartFactory.get…View()方法,二者的区别在于一个返回Intent,这个intent可以启动一个特定的activity,另一个返回GraphicalView,对这个GraphicalView可以灵活设置也可以仅作为一部分显示在任何activity上.对于ChartFactory.get…Intent()上的参数activityTitle是指设置显示在activity上的标题.</strong></p>
</li>
</ul>
<h3 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h3><pre><code>private void showChart(Context context,LinearLayout layout) {
    XYMultipleSeriesDataset mDataset = getDataset();
    XYMultipleSeriesRenderer mRenderer = getRenderer();
    GraphicalView view = ChartFactory.getLineChartView(context, mDataset, mRenderer);
    layout.addView(view);
}

public XYMultipleSeriesDataset getDataset() {
    XYMultipleSeriesDataset seriesDataset = new XYMultipleSeriesDataset();
    XYSeries xySeries = new XYSeries(&quot;&quot;);
    xySeries.add(1, 36);
    xySeries.add(2, 30);
    xySeries.add(3, 27);
    xySeries.add(4, 29);
    xySeries.add(5, 34);
    xySeries.add(6, 28);
    xySeries.add(7, 33);
    seriesDataset.addSeries(xySeries);
    return seriesDataset;
}

public XYMultipleSeriesRenderer getRenderer() {
    /*描绘器，设置图表整体效果，比如x,y轴效果，缩放比例，颜色设置*/
    XYMultipleSeriesRenderer seriesRenderer = new XYMultipleSeriesRenderer();

    seriesRenderer.setMargins(new int[]{100,100,marginBottom,0});//设置外边距，顺序为：上左下右
    //坐标轴设置
    seriesRenderer.setAxisTitleTextSize(16);
    seriesRenderer.setXAxisMax(8);
    seriesRenderer.setXAxisMin(0);
    seriesRenderer.setYAxisMax(800);
    seriesRenderer.setYAxisMin(0);
    seriesRenderer.setAxesColor(Color.BLACK);
    //颜色设置
    seriesRenderer.setMarginsColor(Color.argb(0x00,0x01,0x01,0x01));
    //缩放设置
    seriesRenderer.setZoomButtonsVisible(true);//设置缩放按钮是否可见
    seriesRenderer.setZoomEnabled(true); //图表是否可以缩放设置
    seriesRenderer.setZoomInLimitX(7);
    seriesRenderer.setZoomRate(1);
    //图表移动设置
    seriesRenderer.setPanEnabled(false);
    //坐标轴标签设置
    seriesRenderer.setLabelsTextSize(44);//设置标签字体大小
    seriesRenderer.setXLabelsAlign(Paint.Align.CENTER);
    seriesRenderer.setYLabelsAlign(Paint.Align.LEFT);
    seriesRenderer.setXLabels(0);//显示的x轴标签的个数
    seriesRenderer.addXTextLabel(1,&quot;2&quot;);
    seriesRenderer.addXTextLabel(2,&quot;4&quot;);
    seriesRenderer.addXTextLabel(3,&quot;6&quot;);
    seriesRenderer.addXTextLabel(4,&quot;8&quot;);
    seriesRenderer.setPointSize(13);//设置坐标点大小

    /*某一组数据的描绘器，描绘该组数据的个性化显示效果，主要是字体跟颜色的效果*/
    XYSeriesRenderer xySeriesRenderer = new XYSeriesRenderer();
    xySeriesRenderer.setPointStrokeWidth(40);
    xySeriesRenderer.setColor(Color.GREEN);
    xySeriesRenderer.setDisplayChartValues(true);
    xySeriesRenderer.setChartValuesTextSize(42);

    seriesRenderer.addSeriesRenderer(xySeriesRenderer);
    return seriesRenderer;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天是比赛准备的第二天，这几天主要在学习绘图方面的知识，今天学习了一个框架。这个是Android系统上用于绘图的框架，支持绘制折线图、面积图、散点图、时间图、进度表、条状图、饼图、圆环图等等。不过这个框架现在不在更新了，但比赛用到的还是这个框架，在
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>canvas绘图</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/27/canvas%E7%BB%98%E5%9B%BE/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/27/canvas绘图/</id>
    <published>2017-03-27T13:55:50.000Z</published>
    <updated>2017-04-12T07:33:37.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天是赛前培训的第一天，也是大学以来第一次上课迟到，可能是因为比赛多了几项特权，所以就特别迫切的想使用一下吧。但是过后心里更多的是负罪感而不是新鲜的快感吧。这次比赛应该会是场很棒的经历吧，不管是为了虚荣还使命感，我都应该好好的完成 它吧。</p>
</blockquote>
<h3 id="如何得到1个Canvas对象"><a href="#如何得到1个Canvas对象" class="headerlink" title="如何得到1个Canvas对象"></a>如何得到1个Canvas对象</h3><ul>
<li>之前提到的onDraw方法的入口参数就是Canvas，我们用变量承载它，就可以使用，而我们操作这个Canvas最终的效果会直接反应在这个View上。</li>
<li>SurfaceView是View的继承了，其内部有专门的线程来完成画图的工作，而不用像View一样需要等待刷新，主要用在游戏和高品质动画方面。既然是View的继承类，SurfaceView自然可以获取到Canvas的对象，方式是通过调用SurfaceView的好基友SurfaceHolder的lockCanvas()方法。</li>
<li>当然，除了获取View或SurfaceView自带的现成的Canvas对象，我们还可以自己创建。从4大基本要素我们就可以知道，1个Canvas对象一定要结合1个Bitmap对象。所以一定要为新建的Canvas对象设置1个Bitmap对象。</li>
</ul>
<h3 id="Canvas能画些什么"><a href="#Canvas能画些什么" class="headerlink" title="Canvas能画些什么"></a>Canvas能画些什么</h3><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>Canvas内部维持了一个mutable Bitmap，所以我们可以用颜色来填充整个Bitmap。而填充的范围受限于clip的范围。</p>
<ul>
<li>drawRGB(int r, int g, int b) ： r-红色要素（0~255），g-绿色要素（0~255），b-蓝色要素（0~255）。</li>
<li>drawARGB(int a, int r, int g, int b)：a-透明度（0~255），r-红色要素（0~255），g-绿色要素（0~255），b-蓝色要素（0~255）。</li>
<li>drawColor(int color)：这里的color要为16进制的颜色号，例如：0xFF000000，共8位，两位一组从左到右分别为ARGB，具体含义同上。若要使用“#FF000000”这样的色号，可以调用Color.parseColor(String colorString)方法来进行转换。</li>
<li>drawColor(int color, PorterDuff.Mode mode)：color同上，PorterDuff.Mode比较有意思，有很多种模式，每一种模式都会有特定的效果，感兴趣的朋友可以自行了解一下。</li>
<li>drawPaint(Paint paint)：Canvas同样可以用画笔来填充Bitmap，当然也受限于clip的范围。<h4 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h4><code>canvas.drawArc</code>（扇形）<br><code>canvas.drawCircle</code>（圆）<br><code>canvas.drawOval</code>（椭圆）<br><code>canvas.drawLine</code>（线）<br><code>canvas.drawPoint</code>（点）<br><code>canvas.drawRect</code>（矩形）<br><code>canvas.drawRoundRect</code>（圆角矩形）<br><code>canvas.drawVertices</code>（顶点）<br><code>cnavas.drawPath</code>（路径）<h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><code>canvas.drawBitmap</code>（位图）<br><code>canvas.drawPicture</code>（图片）<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><code>canvas.drawText</code><h4 id="小案例（折线图）"><a href="#小案例（折线图）" class="headerlink" title="小案例（折线图）"></a>小案例（折线图）</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//主曲线图的名称</span></div><div class="line">	<span class="keyword">private</span> String majorName;</div><div class="line">	<span class="comment">//主曲线图的点集合</span></div><div class="line">	<span class="keyword">private</span> LinkedList&lt;Integer&gt; majorValueList;</div><div class="line">	<span class="comment">//主曲线图y轴最小值</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> majorMin;</div><div class="line">	<span class="comment">//主曲线图y轴最大值</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> majorMax;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> marginBottom;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> marginLeft;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context,ChartPagerBean chartPagerBean)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context);</div><div class="line">		<span class="keyword">this</span>.majorName = chartPagerBean.majorName;</div><div class="line">		<span class="keyword">this</span>.majorValueList = chartPagerBean.majorValueList;</div><div class="line">		<span class="keyword">this</span>.majorMin = chartPagerBean.majorMin;</div><div class="line">		<span class="keyword">this</span>.majorMax = chartPagerBean.majorMax;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">		majorValueList.add(<span class="number">37</span>);</div><div class="line">		majorValueList.add(<span class="number">84</span>);</div><div class="line">		majorValueList.add(<span class="number">94</span>);</div><div class="line">		majorValueList.add(<span class="number">6</span>);</div><div class="line">		majorValueList.add(<span class="number">64</span>);</div><div class="line">		majorValueList.add(<span class="number">74</span>);</div><div class="line">		majorValueList.add(<span class="number">85</span>);</div><div class="line">		majorValueList.add(<span class="number">95</span>);</div><div class="line">		majorValueList.add(<span class="number">59</span>);</div><div class="line"></div><div class="line">		marginBottom = <span class="keyword">this</span>.getBottom() - <span class="number">100</span>;</div><div class="line">		marginLeft = <span class="number">100</span>;</div><div class="line"></div><div class="line">		Paint mPaint = <span class="keyword">new</span> Paint();</div><div class="line">		<span class="comment">//初始化y轴</span></div><div class="line">		mPaint.setColor(Color.BLACK);</div><div class="line">		mPaint.setStrokeWidth(<span class="number">6</span>);</div><div class="line">		canvas.drawLine(marginLeft, marginLeft, marginLeft, marginBottom,mPaint);</div><div class="line">		<span class="comment">//初始化x轴</span></div><div class="line">		canvas.drawLine(marginLeft, marginBottom, <span class="keyword">this</span>.getRight() - <span class="number">20</span>, marginBottom, mPaint);</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">			mPaint.setTextSize(<span class="number">40</span>);</div><div class="line">			mPaint.setColor(Color.WHITE);</div><div class="line">			String[] y=&#123;<span class="string">"800"</span>,<span class="string">"600"</span>,<span class="string">"400"</span>,<span class="string">"200"</span>,<span class="string">"0"</span>&#125;;</div><div class="line">			canvas.drawText(y[i], marginLeft -<span class="number">30</span>, marginLeft +(<span class="number">200</span>*i),mPaint);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">			mPaint.setTextSize(<span class="number">40</span>);</div><div class="line">			mPaint.setColor(Color.WHITE);</div><div class="line">			String[] y=&#123;<span class="string">""</span>,<span class="string">"2"</span>,<span class="string">"4"</span>,<span class="string">"6"</span>,<span class="string">"8"</span>&#125;;</div><div class="line">			canvas.drawText(y[i],marginLeft+(i*<span class="number">400</span>), marginBottom +<span class="number">40</span>,mPaint);</div><div class="line">		&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">		drawPint(mPaint,canvas,majorValueList);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPint</span><span class="params">(Paint mPaint, Canvas canvas, LinkedList&lt;Integer&gt; majorValueList)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;majorValueList.size();i++)&#123;</div><div class="line">			<span class="keyword">int</span> value = majorValueList.get(i);</div><div class="line">			<span class="comment">//majorMin=10;</span></div><div class="line">			mPaint.setColor(Color.RED);</div><div class="line">			<span class="keyword">if</span> (value&lt;majorMin)&#123;</div><div class="line">				mPaint.setColor(Color.GREEN);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			canvas.drawCircle(marginLeft+(i*<span class="number">200</span>), marginLeft+<span class="number">800</span>-value, <span class="number">18</span>,mPaint);<span class="comment">// 小圆</span></div><div class="line">			canvas.drawText(value+<span class="string">""</span>,marginLeft+(i*<span class="number">200</span>),marginLeft+<span class="number">800</span>-value-<span class="number">40</span>,mPaint);</div><div class="line">			<span class="keyword">if</span> (i&gt;<span class="number">0</span>)&#123;</div><div class="line">				mPaint.setColor(Color.BLUE);</div><div class="line">				<span class="keyword">int</span> lastValue = majorValueList.get(i-<span class="number">1</span>);</div><div class="line">				canvas.drawLine(marginLeft+((i-<span class="number">1</span>)*<span class="number">200</span>), marginLeft+<span class="number">800</span>-lastValue,marginLeft+(i*<span class="number">200</span>), marginLeft+<span class="number">800</span>-value,mPaint);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Canvas的保存和回滚"><a href="#Canvas的保存和回滚" class="headerlink" title="Canvas的保存和回滚"></a>Canvas的保存和回滚</h3><p>为了配合Canvas本身的变换操作，Canvas提供了保持当前状态和回滚的方法。来个小例子。<br>我们准备画一个表盘，那么我们就有两种实现的思路：</p>
<ul>
<li><p>表盘上有60个刻度，每个刻度之间间隔6°，这是有规律的，那么我们就可以利用三角函数的知识来把刻度的两个坐标求出来，再利用drawLine画到Canvas上。考验你逻辑思维和数学功底的时候到了，不用仔细想就能知道这个方法有点麻烦。</p>
</li>
<li><p>如果不喜欢第一种方法，那么我们可以尝试一下这一种。Canvas提供了旋转操作的方法，也提供了保存和回复状态的方法，那么我们就用这些搭配起来。首先我在（100，0）和（100，10）两个坐标之间画一条竖线，很简单，整点的刻度就出来了。之后先将Canvas的状态保存起来，在（100，0）和（100，10）两个坐标之间画一条竖线，回复Canvas的状态，一分钟的刻度就出来了。以此类推，思路是不是很简单。</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
     super.onDraw(canvas);

     for (int i = 0; i &lt; 360; i = i + 6) {
        canvas.save();
         canvas.rotate(i, 100, 100);
         canvas.drawLine(100, 0, 100, 10, new Paint());
         canvas.restore();
     }
}
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天是赛前培训的第一天，也是大学以来第一次上课迟到，可能是因为比赛多了几项特权，所以就特别迫切的想使用一下吧。但是过后心里更多的是负罪感而不是新鲜的快感吧。这次比赛应该会是场很棒的经历吧，不管是为了虚荣还使命感，我都应该好好的完成 它吧。&lt;/p&gt;

    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JSP的学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/16/JSP%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/16/JSP的学习笔记/</id>
    <published>2017-03-16T13:02:00.000Z</published>
    <updated>2017-03-20T03:47:33.758Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、JSP简介"><a href="#一、JSP简介" class="headerlink" title="一、JSP简介"></a>一、JSP简介</h3><blockquote>
<p>也是SUN公司推出的开发动态web资源的技术，属于JavaEE技术之一。由于原理上是Servlet， 所以JSP/Servlet在一起。</p>
</blockquote>
<h3 id="二、HTML、Servlet和JSP"><a href="#二、HTML、Servlet和JSP" class="headerlink" title="二、HTML、Servlet和JSP"></a>二、HTML、Servlet和JSP</h3><ul>
<li>1、HTML：静态页面，不能包含java代码，只能有HTML有关的标记</li>
<li>2、Servlet：写java代码，做页面的输出，不是很方便（开发效率很低）</li>
<li>3、JSP：HTML+java</li>
</ul>
<h3 id="三、JSP的原理及生命周期"><a href="#三、JSP的原理及生命周期" class="headerlink" title="三、JSP的原理及生命周期"></a>三、JSP的原理及生命周期</h3><ul>
<li>1、JSP就是Servlet，学习好JSP的关键（语法），时刻想到他对应的Servlet。<br><img src="http://i1.piimg.com/4851/538d9bbbb73148d7.png" alt=""></li>
<li>时常翻阅JSP对应的Servlet源码<h3 id="四、JSP的语法"><a href="#四、JSP的语法" class="headerlink" title="四、JSP的语法"></a>四、JSP的语法</h3></li>
</ul>
<h4 id="4-1模板元素"><a href="#4-1模板元素" class="headerlink" title="4.1模板元素"></a>4.1模板元素</h4><ul>
<li>指JSP中的那些HTML。开发时先编写模板元素，因为他们决定页面的外观。</li>
</ul>
<h4 id="4-2Java程序片段"><a href="#4-2Java程序片段" class="headerlink" title="4.2Java程序片段"></a>4.2Java程序片段</h4><p>语法：&lt;%java程序%&gt;<br>出现在JSP对应Servlet的service方法中。<br>&lt;%声明的变量：局部%&gt;</p>
<h4 id="4-3Java表达式"><a href="#4-3Java表达式" class="headerlink" title="4.3Java表达式"></a>4.3Java表达式</h4><p>语法：&lt;%=表达式%&gt;</p>
<h4 id="4-4JSP声明"><a href="#4-4JSP声明" class="headerlink" title="4.4JSP声明"></a>4.4JSP声明</h4><p>语法：&lt;%!</p>
<p>%&gt;<br>作用：定义JSP对应Serlvet的成员（变量和方法、静态方法）</p>
<p>注意：开发中很少用。面试和考试经常考。</p>
<h4 id="4-5JSP注释"><a href="#4-5JSP注释" class="headerlink" title="4.5JSP注释"></a>4.5JSP注释</h4><p>语法：&lt;%–这是注释–%&gt;</p>
<p>作用：注释掉的代码，JSP引擎不会翻译到Servlet源码中。要注意和HTML注释的区别。</p>
<h4 id="4-6JSP指令："><a href="#4-6JSP指令：" class="headerlink" title="4.6JSP指令："></a>4.6JSP指令：</h4><ul>
<li><strong>简介：</strong><br>指令是为JSP引擎设计的。而只是告诉引擎如何处理JSP页面中的其余部分（非指令部分）；<br>基本语法格式：&lt;%@指令 属性1=”值1” ….%&gt;.<br>一般把指令放在JSP页面的顶部（不是必须的）<br>指令的属性可以写在一个指令的中，也可以分开写：比如：<br>&lt;%@指令 属性1=”值1” 属性2=”值2”%&gt;.<br>等价于：<br>&lt;%@指令 属性1=”值1” %&gt;.<br>&lt;%@指令 属性2=”值2”%&gt;</li>
<li><strong>page：</strong></li>
<li>属性：<br><code>language：</code>告知引擎，脚本用的是java。默认java，支持java。不写也行。<br><code>extends：</code>告知引擎，JSP对应的Servlet的父类是哪个。不需要写，也不要改。<br><code>*import：</code>告知引擎，导入哪些包。<br>注意：引擎自动导入：java.lang.<em>;javax.servlet.</em>;javax.servlet.http.<em>;javax.servlet.jsp.</em>;</li>
</ul>
<p>导入的形式：<br>&lt;%@page import=”java.util.Date,java.util.UUID”%&gt;或者：<br>&lt;%@page import=”java.util.Date”%&gt;<br>&lt;%@page import=”java.util.UUID”%&gt;  用Eclipse：Alt+/ 自动导入<br><code>*session:</code>告知引擎是否产生HttpSession对象，即是否在代码中调用request.getSession()。默认值true。<br>buffer：JspWriter用于输出JSP的内容到页面上。告知引擎，设定他的缓存大小。默认8Kb。<br><code>*errorPage：</code>告知引擎，当前页面出现了异常，应该转发到哪个页面上（路径写法：/代表着当前应用）<br>配置全局错误页面：web.xml<br><img src="http://i1.piimg.com/4851/b62efc127800cb3b.png" alt=""><br><code>*isErrorPage:</code>告知引擎，是否抓住异常。如果该属性为true，页面中就可以使用exception隐含对象，打印异常的详细信息。<br><code>*contentType：</code>告知引擎，响应正文的MIME类型。<br>contentType=”text/html;charset=UTF-8”<br>相当于response.setContentType(“&lt;%=exception.getMessage() %&gt;”);<br><code>*pageEncoding:</code>告知引擎，翻译JSP时（要从磁盘上读JSP文件）所用的码表。<br><img src="http://i1.piimg.com/4851/a6c6554e67d40bff.png" alt=""><br>pageEncoding=”UTF-8”:相当于，告知了引擎用UTF-8读jsp，还response.setContentType(“text/html;charset=UTF-8”);<br><code>*isELIgnored:</code>告知引擎，是否忽略EL表达式。默认值是false，不忽略。</p>
<p>总结：属性众多。一般都用的默认值。用起来很简单，最简单的形式：<br><code>&lt;%@ page  pageEncoding=&quot;UTF-8&quot;%&gt;</code></p>
<ul>
<li><p><strong>include：</strong><br>包含<br>属性：file，以”/”开头，就代表着当前应用。</p>
</li>
<li><p><strong>taglib:</strong><br>引入外部的标签。<br>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core" target="_blank" rel="external">http://java.sun.com/jsp/jstl/core</a>“ prefix=”c”%&gt;</p>
</li>
</ul>
<p>uri：外部的标签的uri地址，好比名称空间<br>prefix:前缀。</p>
<h3 id="五、JSP中的转发和包含"><a href="#五、JSP中的转发和包含" class="headerlink" title="五、JSP中的转发和包含"></a>五、JSP中的转发和包含</h3><ul>
<li>1、转发：<br><code>&lt;jsp:forward page=&quot;/10forward.jsp&quot;&gt;&lt;/jsp:forward&gt;</code><br>JSP的内置标签。</li>
<li>2、参数：不能单独使用<br>向目标传递请求参数</li>
<li>3、包含：（面试题）<br>静态包含：<a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x25;&#64;&#105;&#x6e;&#x63;&#108;&#117;&#100;&#x65;&#x25;">&#x25;&#64;&#105;&#x6e;&#x63;&#108;&#117;&#100;&#x65;&#x25;</a><br>动态包含：其余的<br><code>&lt;jsp:include page=””/&gt;</code></li>
</ul>
<p><strong>总结：用标签可以少些java脚本。</strong></p>
<h3 id="六、JSP的九个隐含对象：（面试题）"><a href="#六、JSP的九个隐含对象：（面试题）" class="headerlink" title="六、JSP的九个隐含对象：（面试题）"></a>六、JSP的九个隐含对象：（面试题）</h3><p>JSP对应的Servlet的service方法中的局部变量</p>
<table>
<thead>
<tr>
<th>JSP隐含对象名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td style="text-align:center">javax.servlet.http.HttpServletRequest</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>response</td>
<td style="text-align:center">javax.servlet.http.HttpServletResponse</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>session</td>
<td style="text-align:center">javax.servlet.http.HttpSession</td>
<td style="text-align:center">page指令有开关</td>
</tr>
<tr>
<td>application</td>
<td style="text-align:center">javax.servlet.ServletContext</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>config</td>
<td style="text-align:center">javax.servlet.ServletConfig</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>page</td>
<td style="text-align:center">javax.servlet.http.HttpServlet</td>
<td style="text-align:center">当前jsp对应Servlet的实例引用</td>
</tr>
<tr>
<td>exception</td>
<td style="text-align:center">java.lang.Throwable</td>
<td style="text-align:center">page指令有开关</td>
</tr>
<tr>
<td>out</td>
<td style="text-align:center">javax.servlet.jsp.JspWriter</td>
<td style="text-align:center">字符输出流。相当于PrintWriter</td>
</tr>
<tr>
<td>pageContext</td>
<td style="text-align:center">javax.servlet.jsp.PageContext</td>
<td style="text-align:center">很重要</td>
</tr>
</tbody>
</table>
<h3 id="七、PageContext抽象类（很重要）"><a href="#七、PageContext抽象类（很重要）" class="headerlink" title="七、PageContext抽象类（很重要）"></a>七、PageContext抽象类（很重要）</h3><ul>
<li><p>本身是一个域（范围）对象，还能操作其他3个域对象中的属性</p>
<ul>
<li>页面范围：<br><code>void setAttribute(String name,Object value);</code><br><code>void removeAttribute(String name);</code><br><code>Object getAttribute(String name);</code></li>
<li>操作其他域对象中的属性：<br><code>void setAttribute(String name,Object value,int scope);</code><br><code>void removeAttribute(String name,int scope);</code><br><code>Object getAttribute(String name,int scope);</code><br><code>int scope:</code>常量，<code>PageContext</code>     <code>PAGE_SCOPE(页面)</code>  <code>REQUEST_SCOPE（请求）</code> <code>SESSION_SCOPE（会话）</code> <code>APPLICATION_SCOPE（应用）</code></li>
<li>在四个范围中依次查找指定名称对象的方法：<br><code>PAGE(页面)</code>  <code>REQUEST（请求）</code> <code>SESSION（会话）</code> <code>APPLICATION（应用）</code><br><code>Object findAttribute(String name);</code></li>
</ul>
</li>
<li><p>获取其他八个JSP隐含对象(自定义标签时用)<br><code>PageContext.getRequest();</code><br><code>getServletContext();</code><br><code>getServletConfig();</code><br><code>getException();</code><br><code>get...</code></p>
</li>
<li>提供转发和包含的简易方法<br><code>pageContext.include(String url);</code></li>
</ul>
<h3 id="八、四大域对象"><a href="#八、四大域对象" class="headerlink" title="八、四大域对象"></a>八、四大域对象</h3><p><strong>实际开发中：存放数据的。</strong></p>
<p><code>PageContext:</code>页面范围。最小。开发中很少用。演示代码。<br><code>ServletRequest:</code>请求范围。不同的资源，只有用转发。<br><code>HttpSession:</code>会话范围。多次请求共享数据，但不同的客户端不能共享。<br><code>ServletContext:</code>应用范围。最大。尽量少用。用时要做同步处理。</p>
<h3 id="九、JSP开发的最佳实践"><a href="#九、JSP开发的最佳实践" class="headerlink" title="九、JSP开发的最佳实践"></a>九、JSP开发的最佳实践</h3><ul>
<li>Servlet：擅长写Java代码逻辑，不擅长输出html的内容。<br>开发中作为：控制器。</li>
<li>JSP：不擅长写Java代码逻辑，擅长显示结果。<br>开发中作为：视图（显示结果）<br><img src="http://i1.piimg.com/4851/7319051e910de6ff.png" alt=""></li>
</ul>
<h3 id="十、JavaBean的概念"><a href="#十、JavaBean的概念" class="headerlink" title="十、JavaBean的概念"></a>十、JavaBean的概念</h3><ul>
<li>1、JavaBean又称之为POJO（Plain Old Java Object）、VO（Value Object）、DO（Data Object）</li>
<li><strong>2、JavaBean的书写规范</strong><br>a、必须是public的<br>b、提供默认的构造方法<br>c、字段都是私有的： private String username;<br>d、提供公有的getter或setter方法：属性。<br>getUsername():读属性，属性名：username.<br>setUsername(String username):写属性，属性名：username。<br>e、一般需要实现java.io.Serializable接口。</li>
</ul>
<p><strong>注意：</strong> private boolean married;   getMarried()===isMarried()</p>
<p><strong>结论：</strong> JavaBean在JavaEE开发中，主要担当封装数据用的。</p>
<h3 id="十一、JSP中使用JavaBean"><a href="#十一、JSP中使用JavaBean" class="headerlink" title="十一、JSP中使用JavaBean"></a>十一、JSP中使用JavaBean</h3><ul>
<li>1、导入JavaBean：用page指令的import</li>
<li>2、声明JavaBean：<br><img src="http://i1.piimg.com/4851/853084b703212266.png" alt=""></li>
<li>3、获取属性：<br><img src="http://i1.piimg.com/4851/0fed44f6eeabb820.png" alt=""><br>如果属性是null，那么界面就显示null。</li>
<li>4、设置属性：<br>注意：类型的转换问题<br><img src="http://i1.piimg.com/4851/b62efc127800cb3b.png" alt=""><br>可以使用请求参数设置JavaBean的属性。<br><img src="http://i1.piimg.com/4851/476cb28dd59eeec9.png" alt=""></li>
<li>5、JavaBean的存活范围：<br>声明JavaBean时，指定scope属性。默认值page，当前页面范围。<br>可选值：page|request|session|application</li>
</ul>
<p>总结：JSP+JavaBean，开发模型，Model1（模型1）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、JSP简介&quot;&gt;&lt;a href=&quot;#一、JSP简介&quot; class=&quot;headerlink&quot; title=&quot;一、JSP简介&quot;&gt;&lt;/a&gt;一、JSP简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;也是SUN公司推出的开发动态web资源的技术，属于JavaEE技术之一。由
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>速读：从0到1</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/15/%E9%80%9F%E8%AF%BB%EF%BC%9A%E4%BB%8E0%E5%88%B01/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/15/速读：从0到1/</id>
    <published>2017-03-15T13:19:30.000Z</published>
    <updated>2017-03-27T13:56:36.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="速读：从0到1"><a href="#速读：从0到1" class="headerlink" title="速读：从0到1"></a>速读：从0到1</h2><h3 id="本书和作者"><a href="#本书和作者" class="headerlink" title="本书和作者"></a>本书和作者</h3><p>这本书是2015年最成功的商业畅销书。不仅因为它的作者是硅谷投资界的思想家，成功创办了PayPal、投资了Facebook的彼得·蒂尔，更因为这本书揭示了心怀梦想的创业者所需要知道的哲学层面的思想准备。当你知道了这些哲学思考，你才能明白为什么彼得能够继续成功创办了Founders Fund，投资了Linkedin、SpaceX、Yelp，甚至他投资的Palantir软件公司帮助美国政府对抗恐怖分子。</p>
<h3 id="什么是“从0到1”？"><a href="#什么是“从0到1”？" class="headerlink" title="什么是“从0到1”？"></a>什么是“从0到1”？</h3><p>进步可以呈两种形式：水平进步和垂直进步。水平进步也称广泛进步，就是从1到N。比如全球化和中国的山寨式创新。垂直进步也称深入进步，是从0到1的进步，比如真正的科技创新。用一个词概括水平进步就是全球化，中国是最好的范例。因为中国的理想未来就是现在的美国。垂直进步也可以用一个词来概括，那就是科技。1815到1914年间，科技迅速发展，全球化也快速蔓延。第一次世界大战到1971年基辛格访华，科技发展快，全球化缓慢。1971年开始，全球化加快，科技发展只局限于信息技术领域。</p>
<p>全球化会造成污染和能源危机，如果全世界都用同一种旧方法去创造财富，那就会成为灾难。丢掉科技创新的全球化不会长久。</p>
<h3 id="从网络泡沫的破灭中学到什么？"><a href="#从网络泡沫的破灭中学到什么？" class="headerlink" title="从网络泡沫的破灭中学到什么？"></a>从网络泡沫的破灭中学到什么？</h3><p>1998年9月到2000年3月，这段短命的网络热潮的背景就是一个溃败无序的世界。旧经济无法应对全球化带来的挑战。如果想要未来更好，就一定要找到处处行得通的方法。间接证据显示，互联网新经济是唯一可以前进的道路。</p>
<p>遭受硅谷劫难的企业家学到4点经验： </p>
<ol>
<li><p>循序渐进。不能沉溺在宏大的愿景中，小幅地循序渐进成长是安全前进的唯一道路；</p>
</li>
<li><p>保持精简和灵活性。事先规划死板又不现实，你应该做些尝试，反复实践，把创业当成未知的实验；</p>
</li>
<li><p>在改进中竞争。不要贸然创造新市场，在已有的客户群上拓展；</p>
</li>
<li><p>专注于产品，而非营销。如果你的产品需要广告或营销人员，就说明你的产品还不够好。</p>
</li>
</ol>
<p>虽然大家普遍信奉这4条，但我认为它们的对立面可能更正确：</p>
<ol>
<li><p>大胆尝试胜过平庸保守；</p>
</li>
<li><p>坏计划也好过没有计划；</p>
</li>
<li><p>竞争性市场很难赚到钱；</p>
</li>
<li><p>营销和产品同样重要。</p>
</li>
</ol>
<p>记住，最反主流的行动不是抵制潮流，而是在潮流中不丢弃自己的独立思考。</p>
<h3 id="垄断企业的谎言"><a href="#垄断企业的谎言" class="headerlink" title="垄断企业的谎言"></a>垄断企业的谎言</h3><p>美国航空公司每年要创造数千亿美元的价值，但每次飞行航空公司只能从每位乘客身上赚到37美分。而谷歌2012年只创造了500亿美元的价值，却从中获利21%，利润率是航空业的100多倍。原因是航空公司竞争太激烈了，而谷歌是垄断的。</p>
<p>别听到垄断就害怕，觉得消费者要受到欺压了。那是在静态的世界中，资源有限，手段单一。在动态世界中，富有创意的垄断者创造出更多的选择，它们是使社会更美好的推动力。经济学家痴迷于竞争是因为他们的想法来自物理学家，把个人和企业都看做可互换的原子，而不是独特的创造者。静态对企业来讲意味着死亡。</p>
<h3 id="要摆脱竞争意识"><a href="#要摆脱竞争意识" class="headerlink" title="要摆脱竞争意识"></a>要摆脱竞争意识</h3><p>竞争意味着大家都没有利润，产品没有实质差异，而且还要挣扎求生。竞争使我们过分重视过去的机会，一味重复过去的模式。也会使人产生幻觉去抓住一些并不存在的“机会”。竞争还会让人分心，受情绪控制去做一些不理智的事情。</p>
<p>我的经验是当你不能打败对手时可以选择联合。1999年末，PayPal和X.com陷入了全面竞争，我们当时关注的不是客观效率而是如何打败它。2000年3月，我和埃隆·马斯克决定合并，作为一个整体，我们熬过了网络泡沫。</p>
<h3 id="垄断企业的特征"><a href="#垄断企业的特征" class="headerlink" title="垄断企业的特征"></a>垄断企业的特征</h3><p>垄断企业通常会综合以下几个特点：专利技术、网络效应、规模经济和品牌优势。</p>
<ol>
<li><p>一般而言，专利技术在某些方面必须比最接近的替代品好10倍才能拥有真正的垄断优势。要做出10倍改进，最明确的方法就是创造全新的事物。PayPal让支付好了10倍以上，iPad比之前的平板电脑好用10倍。 </p>
</li>
<li><p>网络效应使一项产品随着越来越多的人使用变得更加有用。矛盾的是，享有网络效应的企业必须从非常小的市场做起。Facebook最初的使用者只是哈佛一个班的学生。PayPal的第一批用户只有24个人。</p>
</li>
<li><p>垄断企业越大越强，边际成本趋近于零。 </p>
</li>
<li><p>品牌的背后是实力，没有科技公司可以只靠品牌发展。苹果在超级触屏材料、触屏界面上都有复杂的专利技术，生产规模大到可以主导原料的价格。之后才是无处不在的广告和粉丝。</p>
</li>
</ol>
<h3 id="如何打造垄断企业？"><a href="#如何打造垄断企业？" class="headerlink" title="如何打造垄断企业？"></a>如何打造垄断企业？</h3><ol>
<li><p>占领小市场。在一个小市场里占主导地位比在大市场里要容易得多。当PayPal把目光锁定在eBay的数千个超级卖家上时，我们就找对了路子。</p>
</li>
<li><p>扩大规模。一旦你成功创造了或是主导了一个利基市场，就要逐步打入稍大些的相关市场。比如亚马逊从图书到音像制品和软件，最后才到跑车和工业品。 </p>
</li>
<li><p>破坏性创新。“破坏”是指一家公司可以用科技创新低价推出一种低端产品，然后逐步对产品做出改进，最终取代现存公司用旧科技生产的优质产品。但别为了破坏而破坏，如果你认为自己是对抗黑暗势力的起义者，就很容易过分专注于道路上的障碍。如果你真想创造新的事物，就去创造。PayPal给了visa更多的商业机会，整个产业得到了正面的回馈。如果你准备扩张到相邻市场，不要破坏，要尽可能地躲开竞争。</p>
</li>
</ol>
<h3 id="成功不是靠运气"><a href="#成功不是靠运气" class="headerlink" title="成功不是靠运气"></a>成功不是靠运气</h3><p>爱默生说：浅薄的人才会相信运气和境遇，强者只相信因果。根据对未来的确定性和乐观程度，人可以分为四种：</p>
<ol>
<li><p>对未来不明确的悲观主义：比如现在的欧洲。</p>
</li>
<li><p>对未来明确的悲观主义：比如现在的中国，中国人太喜欢提前做好准备了。从中国的角度看，经济增长还不够快。其他国家都害怕中国将要统治世界，而中国是唯一一个认为自己不会统治世界的国家。</p>
</li>
<li><p>对未来明确的乐观主义：1950-1970年的美国。大量大胆的计划被重视和实施，不断地尝试改变世界。 </p>
</li>
<li><p>对未来不明确的乐观主义：1982年以后的美国。金融取代建筑成为主导，不去制定具体计划，却都想在未来获利。银行家和律师盛行。</p>
</li>
</ol>
<p>当今的世界的主流思想就是对未来不明确却很乐观。不明确的金融、不明确的政治、不明确的哲学、不明确的人生。没有计划的进步就叫做“演化”。依靠演化来尝试成功的企业是不靠谱的，所以，长期规划仍是最重要的。乔布斯对苹果的设计绝不是产品，而是整个生态结构。初创企业是你可以明确掌握尽最大努力的机会，因为你不是一张被概率决定命运的彩票。</p>
<h3 id="风险投资应该给什么样的公司？"><a href="#风险投资应该给什么样的公司？" class="headerlink" title="风险投资应该给什么样的公司？"></a>风险投资应该给什么样的公司？</h3><p>我们所在的世界不是正常的世界，而是处在幂次法则之下。风险投资就是为了找到可以指数级增长的公司。撒网式投资然后祈祷的方法通常会全盘皆输，因为风险投资的回报并不遵循正态分布，而是遵循幂次法则：一小部分公司完胜其他所有公司。 </p>
<p>风险投资家总结了两个规则：</p>
<ol>
<li><p>只投资给获利可达整个投资基金总值的有潜力的公司。 </p>
</li>
<li><p>因为第一条太严苛，所以不需要其他规则。不管何时，如果你不关注事业本质，而是关注其是否适合多元化避险策略的财务问题，那么投资就像是在买彩票。一旦你认为自己在抽奖，就已经做好了亏损的心理准备。 </p>
</li>
</ol>
<p>幂次法则不仅对投资者重要，对每个人都重要。创业者最大的投资是花时间成立新公司；每个人选择一份工作也是一项投资，因为你相信自己选择的工作在今后的几十年里会变得很有价值。人生对于创业者和任何人来说都不能“多元化”，你应该把全部注意力放在你擅长的事情上，而且在这之前要先仔细想想未来这件事情是否会变得很有价值。</p>
<h3 id="要始终相信秘密的存在"><a href="#要始终相信秘密的存在" class="headerlink" title="要始终相信秘密的存在"></a>要始终相信秘密的存在</h3><p>秘密分两种：自然的秘密和人的秘密。探索秘密的最佳处所就是无人关注的地方。大多数人只以学校教授给他们的方式思考，而学校本身的目标就在于传授常规知识。那些没有被标准化和制度化的领域都是值得研究的。</p>
<p>当你找到了秘密，不要闷在心里，也不要见谁都说。所有成功的企业都是基于鲜为人知的秘密创立的。好企业是改变世界的密谋者。当你与人分享秘密时，听众就成为了你的谋士。</p>
<p>有些事起步时就要做好：</p>
<ol>
<li><p>首先至关重要的决定是：和谁一起做？有些一拍即合的合伙就像在拉斯维加斯的老虎机前遇到的婚姻一样糟糕。技术能力和才华固然重要，但创始人之间的了解程度和默契程度也同样重要。最好有深厚的交情，否则就是碰运气。</p>
</li>
<li><p>分清楚所有权、经营权和控制权。董事会越小越好，董事们容易沟通，并进行有效监督。除非你上市了，否则董事会不要超过5个人。 </p>
</li>
<li><p>尽量雇佣全职员工。某些岗位可以兼职，但重要岗位一定要全职。</p>
</li>
<li><p>现金奖励不如股权奖励。愿意拿股权奖励的人才是对公司未来有信心的人。股票报酬才能让员工全力以赴。 </p>
</li>
<li><p>只要公司创新，创业就还没结束，一旦创新停止，创业就结束了。你甚至可以使创业无限延伸下去。</p>
</li>
</ol>
<h3 id="打造帮派文化"><a href="#打造帮派文化" class="headerlink" title="打造帮派文化"></a>打造帮派文化</h3><ol>
<li><p>初创公司是肩负统一使命的一个团队，企业文化的好坏取决于内涵而不是公司福利或者涂鸦墙。</p>
</li>
<li><p>时间是最宝贵的资产，将时间浪费在不能长久合作的人身上得不偿失。从一开始我就让员工紧密团结，而不是出于事务关系待在一起。要招聘认同公司使命的人，并且愿意和已有的这些人共事。</p>
</li>
<li><p>要给大家统一的文化衫和卫衣，上面有公司logo，这让大家看起来与众不同。</p>
</li>
<li><p>每名员工只专注一件事情，这样可以避免不必要的竞争和推诿，也让大家更有成就感。</p>
</li>
<li><p>有时被外人成为邪教或者黑帮，也不是件坏事。</p>
</li>
</ol>
<h3 id="三种销售策略"><a href="#三种销售策略" class="headerlink" title="三种销售策略"></a>三种销售策略</h3><ol>
<li><p>如果你的平均销售额在七位数以上，一两年才达成一笔交易，这就是复杂销售。比如太空探索公司。这种销售中CEO最重要。</p>
</li>
<li><p>平均交易额1万到10万美元的销售叫做人员销售。这需要招聘和培训大量专业销售人员。</p>
</li>
<li><p>如果产品的核心功能可以鼓励用户邀请其他朋友成为用户，那么这个产品才能进行病毒式营销。每次只要有人与朋友分享，就自然而然地邀请更多的人加入。</p>
</li>
</ol>
<p>销售策略并不是越多越好，同样有幂次法则在起作用。只要有一条有效的销售途径，你就能成功。需要推销的不仅仅是你的产品，还有你的公司。要把公司推荐给媒体和投资人，以及员工。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;速读：从0到1&quot;&gt;&lt;a href=&quot;#速读：从0到1&quot; class=&quot;headerlink&quot; title=&quot;速读：从0到1&quot;&gt;&lt;/a&gt;速读：从0到1&lt;/h2&gt;&lt;h3 id=&quot;本书和作者&quot;&gt;&lt;a href=&quot;#本书和作者&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
    
      <category term="观看与感悟" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/%E8%A7%82%E7%9C%8B%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Cookie和HttpSession的学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/15/Cookie%E5%92%8CHttpSession%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/15/Cookie和HttpSession的学习笔记/</id>
    <published>2017-03-15T12:05:15.000Z</published>
    <updated>2017-03-17T12:24:57.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</p>
</blockquote>
<h2 id="客户端技术：Cookie"><a href="#客户端技术：Cookie" class="headerlink" title="客户端技术：Cookie"></a>客户端技术：Cookie</h2><blockquote>
<p>回顾HTTP协议的消息头<br>请求消息头：Cookie 客户端向服务器端传递信息<br>响应消息头：Set-Cookie 服务器端向客户端传递信息</p>
</blockquote>
<h3 id="1、Cookie详解："><a href="#1、Cookie详解：" class="headerlink" title="1、Cookie详解："></a>1、Cookie详解：</h3><h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><ul>
<li>name：Cookie的名称，必要的属性</li>
<li>value：Cookie的取值（不能为中文），必要的属性<br>——————-以下为可选属性</li>
<li><p><strong>path：Cookie的路径</strong><br>默认值就是写cookie的那个资源的访问路径<br>比如：<a href="http://localhost:8080/day09_00_cookie/servlet/CookieDemo1" target="_blank" rel="external">http://localhost:8080/day09_00_cookie/servlet/CookieDemo1</a> path就是/day09_00_cookie/servlet/</p>
</li>
<li><p><strong>注意：</strong><br>如果一个存在浏览器缓存中的cookie的路径是/day09/servlet/<br>当访问<a href="http://localhost:8080/day09/CookiePathDemo1时，浏览器根本不带Cookie给服务器。浏览器比对的是cookie的路径和当前访问的资源的路径。" target="_blank" rel="external">http://localhost:8080/day09/CookiePathDemo1时，浏览器根本不带Cookie给服务器。浏览器比对的是cookie的路径和当前访问的资源的路径。</a></p>
</li>
<li><p><strong>浏览器满足一下条件就会带cookie给服务器：</strong><br>当前访问的地址的路径.startWith(已存cookie的路径)。<br>即：如果一个Cookie的路径设置为了当前应用，说明访问该网站的任何资源时浏览器都带该cookie给服务器。（开发中经常做的）</p>
</li>
<li><p>maxAge：Cookie的最大生存时间。默认是在浏览器的内存中。</p>
</li>
<li><p>domain：Cookie的域名（网站）。默认就是写cookie的那个资源所属的网站。<br><a href="http://localhost:8080/day09_00_cookie/servlet/CookieDemo1域名就是localhost" target="_blank" rel="external">http://localhost:8080/day09_00_cookie/servlet/CookieDemo1域名就是localhost</a></p>
</li>
<li><p>version：版本号</p>
</li>
<li>comment:注释</li>
</ul>
<h4 id="把Cookie写给客户端"><a href="#把Cookie写给客户端" class="headerlink" title="把Cookie写给客户端"></a>把Cookie写给客户端</h4><ul>
<li>HttpServletResponse.addCookie(Cookie c):实际上就是向客户端发送了一个响应消息头。</li>
<li><code>注意：客户端只能保存一个网站最多20个Cookie数据，总共最多300个。每个Cookie的大小不能超过4kb。</code><h4 id="服务器端获取客户端带来的Cookie："><a href="#服务器端获取客户端带来的Cookie：" class="headerlink" title="服务器端获取客户端带来的Cookie："></a>服务器端获取客户端带来的Cookie：</h4>Cookie [] HttpServletRequest.getCookies();</li>
</ul>
<p><code>注意：domain+path+name唯一确定一个Cookie。</code></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><pre><code>import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class LoginServlet extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response) 
        throws ServletException, IOException {
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        //验证用户名和密码是否正确：此处输什么都正确
        String usename = request.getParameter(&quot;usename&quot;);
        String password = request.getParameter(&quot;password&quot;);
        String remember = request.getParameter(&quot;remember&quot;);//没有选中就是null

        Cookie c = new Cookie(&quot;loginInfo&quot;,usename);
        c.setPath(request.getContextPath());
        if(remember==null){
            //没有选中，删除cookie
            c.setMaxAge(0);
        }else{
            //用户记住用户名：存cookie
            c.setMaxAge(Integer.MAX_VALUE);
        }
        response.addCookie(c);
        out.write(&quot;登录成功&quot;);

    }

    public void doPost(HttpServletRequest request, HttpServletResponse response) 
        throws ServletException, IOException {
        doGet(request,response);
    }

}

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class LoginUIServlet extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response) 
        throws ServletException, IOException {
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        String username = &quot;&quot;;
        String checked = &quot;&quot;;
        //得到指定的cookie
        Cookie cs[] = request.getCookies();
        for(int i=0;cs!=null&amp;&amp;i&lt;cs.length;i++){
            if(&quot;loginInfo&quot;.equals(cs[i].getName())){
                username = cs[i].getValue();
                checked=&quot;checked=&apos;checked&apos;&quot;;
                break;
            }
        }

        out.write(&quot;&lt;form action=&apos;&quot;+request.getContextPath()+&quot;/servlet/LoginServlet&apos; method=&apos;post&apos;&gt;&quot;);
        out.write(&quot;账号：&lt;input type=&apos;text&apos; name=&apos;usename&apos; value=&apos;&quot;+username+&quot;&apos; /&gt;&lt;br/&gt;&quot;);
        out.write(&quot;密码：&lt;input type=&apos;password&apos; name=&apos;password&apos; value=&apos;&apos; /&gt;&lt;br/&gt;&quot;);
        out.write(&quot;记住账号：&lt;input type=&apos;checkbox&apos; name=&apos;remember&apos; &quot;+checked+&quot;/&gt;&lt;br/&gt;&quot;);
        out.write(&quot;&lt;input type=&apos;submit&apos; value=&apos;登录&apos;/&gt;&quot;);
        out.write(&quot;&lt;/form&gt;&quot;);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response) 
        throws ServletException, IOException {
        doGet(request,response);
    }

}
</code></pre><h2 id="服务器端技术：HttpSession"><a href="#服务器端技术：HttpSession" class="headerlink" title="服务器端技术：HttpSession"></a>服务器端技术：HttpSession</h2><h3 id="HttpSession-用途"><a href="#HttpSession-用途" class="headerlink" title="HttpSession 用途"></a>HttpSession 用途</h3><ul>
<li>它也是一个域对象：session servletContext request</li>
<li>同一个会话下，可以使一个应用的多个资源共享数据</li>
<li>cookie 客户端技术，只能存字符串。HttpSession服务器端的技术，它可以存对象</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><strong>把数据保存在HttpSession对象中，该对象也是一个域对象</strong></p>
<ul>
<li><code>setAttribute(String name,Object value)</code> 存对象</li>
<li><code>getAttribute(String name)</code>    取对象</li>
<li><code>remvoeArrtibute(String name)</code></li>
<li><code>getId()</code></li>
<li><code>setMaxInactiveInterval(int interval)</code> 设置session的存活时间 单位秒</li>
<li><code>invalidate()</code> 销毁session</li>
</ul>
<h3 id="getSession-内部执行原理"><a href="#getSession-内部执行原理" class="headerlink" title="getSession() 内部执行原理"></a>getSession() 内部执行原理</h3><ul>
<li>1,获取名称为JSESSIONID的cookie的值</li>
<li>2，没有这样的cookie，创建一个新的HttpSession对象，分配一个唯一的SessionId,并且向客户端写了一个名为JSESSIONID=sessionId的cookie</li>
<li>3,有这样的Cookie，获取cookie的值（即HttpSession对象的值），从服务器的内存中根据Id找那个HttpSession对象<br>找到了：取出继续为你服务<br>找不到：从2开始<br><img src="http://i1.piimg.com/4851/c6ef3c69c9d9ffc7.png" alt=""><br>HttpSession request.getSession(boolean b):<br>b如果为true，和getSession()完全一样的<br>b为false，服务器只是查找，找不到不会创建新的，返回null。<br>HttpSession.invalidate();使HttpSession对象立即失效。</li>
</ul>
<h3 id="客户端禁用Cookie后的会话数据的保持"><a href="#客户端禁用Cookie后的会话数据的保持" class="headerlink" title="客户端禁用Cookie后的会话数据的保持"></a>客户端禁用Cookie后的会话数据的保持</h3><p>客户端永远不会向服务器端带任何cookie。<br>解决办法：<br>方式一：（乌龙）文字提示：请不要禁用您的Cookie<br>方式二：在访问的地址后面加上JSESSIONID=session的id。<br><a href="http://localhost:8080/servlet/ServletDemo1" target="_blank" rel="external">http://localhost:8080/servlet/ServletDemo1</a>   URL重写，必须对网站的所有地址都重写<br><a href="http://localhost:8080/servlet/ServletDemo1;JSESSIONID=123" target="_blank" rel="external">http://localhost:8080/servlet/ServletDemo1;JSESSIONID=123</a></p>
<p>response.encodeUrl(String url);自动重写。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>Request和Response的学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/14/Request%E5%92%8CResponse%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/14/Request和Response的学习笔记/</id>
    <published>2017-03-14T11:29:30.000Z</published>
    <updated>2017-03-14T14:13:19.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天写博客比以往都要早一点，从图书馆一回寝室就开始把今天学的凭记忆先记录下来，（其实主要还是怕贪玩又忘记写。）这是我写的第5篇博客，从上月22号坚持每天去图书馆刚好三周21天，是我戒烟的第25天。讲实话这些坚持真的让自己很难受，但当我看到这些统计出的文字时又是满满的感动。</p>
</blockquote>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul>
<li>web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象和代表响应的request对象。</li>
<li>request和response对象既然代表请求和响应，那我们要获取客户端（浏览器）提交过来的数据，只需要找request对象就行了。要客户端输出数据，只需要找response对象就行了。<br><strong>注意：</strong> request中封装的是浏览器的信息和请求参数，即浏览器的请求；response中封装的是服务器向浏览器发送的数据、响应头和编码格式等，即服务器的响应。</li>
</ul>
<h2 id="二、HttpServletResponse-响应对象"><a href="#二、HttpServletResponse-响应对象" class="headerlink" title="二、HttpServletResponse 响应对象"></a>二、HttpServletResponse 响应对象</h2><h3 id="1、字节流向客户端输出中文数据"><a href="#1、字节流向客户端输出中文数据" class="headerlink" title="1、字节流向客户端输出中文数据"></a>1、字节流向客户端输出中文数据</h3><ul>
<li>默认情况下：浏览器是乱码的（他默认查GBK）<ol>
<li>解决方案一：更改浏览器的码表（不建议）</li>
<li>解决方案二(不建议)：向客户端输出一个<meta>标签,模拟了响应消息头：<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"></li>
<li>解决方案三（建议）:向客户端输出响应消息头：response.setHeader(“Content-Type”, “text/html;charset=UTF-8”);</li>
<li>解决方案四（建议）：向客户端输出响应消息头response.setContentType(“text/html;charset=UTF-8”);</li>
</ol>
</li>
</ul>
<p>案例代码：</p>
<pre><code>import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//字节流向客户端输出中文数据
public class ResponseDemo1 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
        test2(response);
    }

    //字节流输出数据查UTF-8
    private void test2(HttpServletResponse response) throws IOException {
        String data = &quot;不见了远处的青山&quot;;

        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        ServletOutputStream out = response.getOutputStream();
        out.write(data.getBytes(&quot;UTF-8&quot;));//默认情况下：浏览器是乱码的（他默认查GBK）
    }
    //字节流输出数据查本地码表
    private void test1(HttpServletResponse response) throws IOException {
        String data = &quot;不见了远处的青山&quot;;
        ServletOutputStream out = response.getOutputStream();
        out.write(data.getBytes());//String:  getBytes()查本地默认的码表GBK getBytes(String charset)查指定码表
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="2、字符流输出中文数据"><a href="#2、字符流输出中文数据" class="headerlink" title="2、字符流输出中文数据"></a>2、字符流输出中文数据</h3><ul>
<li>HttpServletResponse的实例由Tomcat服务器提供，默认查ISO-8859-1的。</li>
<li>Tomcat8.X ,默认编码就变为了UTF-8</li>
</ul>
<p>案例源码：</p>
<pre><code>import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//字符流输出中文数据
public class ResponseDemo2 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String data = &quot;幸福是什么呢&quot;;
        //改变字符流查的码表，还能告知客户端用UTF-8进行解码
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        out.write(data);
    }

    private void test1(HttpServletResponse response) throws IOException {
        String data = &quot;幸福是什么&quot;;
        //改变字符流查的码表
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        //告知客户端用UTF-8进行解码
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        out.write(data);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><p><strong>注意：</strong> 在开发中尽量使用字节流，因为字节流可以处理任何数据，而字符流只能用来处理文本。</p>
<h3 id="3、输出随机验证码图片：CAPTCHA图像"><a href="#3、输出随机验证码图片：CAPTCHA图像" class="headerlink" title="3、输出随机验证码图片：CAPTCHA图像"></a>3、输出随机验证码图片：CAPTCHA图像</h3><p>案例源码：</p>
<pre><code>import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//输出随机验证码图片：CAPTCHA图像
public class ResponseDemo3 extends HttpServlet {
    public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
        int width = 120;
        int height = 25;
        //创建一副内存图像
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        //得到画笔
        Graphics g = image.getGraphics();
        //开始画
        //边线
        g.setColor(Color.BLUE);
        g.drawRect(0, 0, width, height);
        //填充背景色
        g.setColor(Color.YELLOW);
        g.fillRect(1, 1, width-2, height-2);
        //话干扰线
        g.setColor(Color.GRAY);

        Random r = new Random();
        for(int i=0;i&lt;9;i++)
            g.drawLine(r.nextInt(width), r.nextInt(height), r.nextInt(width), r.nextInt(height));
        //验证码
        g.setColor(Color.RED);
        g.setFont(new Font(&quot;宋体&quot;, Font.ITALIC|Font.BOLD, 19));
        int x = 20;
        for(int i=0;i&lt;4;i++){
            g.drawString(r.nextInt(10)+&quot;&quot;, x,20 );
            //g.drawString(base.charAt(r.nextInt(base.length()))+&quot;&quot;, x, 20);
            x+=18;
        }
        //输出
        response.setHeader(&quot;Expires&quot;, &quot;-1&quot;);
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
        ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream());
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="4、控制客户端定时刷新"><a href="#4、控制客户端定时刷新" class="headerlink" title="4、控制客户端定时刷新"></a>4、控制客户端定时刷新</h3><pre><code>import java.io.IOException;
import java.util.Random;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//控制客户端定时刷新
public class ResponseDemo4 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        test2(response);
    }
    //定时刷新到别处
    private void test2(HttpServletResponse response) throws IOException {
        response.setContentType(&quot;text/htm;charset=UTF-8&quot;);
        response.setHeader(&quot;Refresh&quot;, &quot;2;URL=http://www.itheima.com&quot;);
        response.getWriter().write(&quot;登录成功，2秒后跳转到主页&quot;);
    }
    //定时刷新自己
    private void test1(HttpServletResponse response) throws IOException {
        Random r = new Random();
        //response.setHeader(&quot;Refresh&quot;, &quot;1&quot;);
        response.setIntHeader(&quot;Refresh&quot;, 1);
        response.getWriter().write(r.nextInt()+&quot;&quot;);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="5、控制缓存的时间"><a href="#5、控制缓存的时间" class="headerlink" title="5、控制缓存的时间"></a>5、控制缓存的时间</h3><ul>
<li>静态资源需要控制缓存时间</li>
<li>动态资源一般不要缓存</li>
</ul>
<p>案例源码：</p>
<pre><code>import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ResponseDemo5 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String data = &quot;不见了远处的青山&quot;;
        //让他缓存1个小时
        response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis()+1*60*60*1000);
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        response.getWriter().write(data);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="6、请求重定向"><a href="#6、请求重定向" class="headerlink" title="6、请求重定向"></a>6、请求重定向</h3><ul>
<li>演示请求重定向:可以重定向到任何地址上</li>
<li>发出2次请求</li>
<li>地址栏会发生变化</li>
</ul>
<p>案例源码：</p>
<pre><code>import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ResponseDemo6 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        response.sendRedirect(&quot;http://www.itheima.com&quot;);
    }
    //重定向到应用内的资源
    private void test1(HttpServletResponse response) throws IOException {
        //response.setStatus(302);
        //response.setHeader(&quot;Location&quot;, &quot;/day08_00_response/servlet/ResponseDemo7&quot;);
        response.sendRedirect(&quot;/day08_00_response/servlet/    ResponseDemo7&quot;);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="7、response细节"><a href="#7、response细节" class="headerlink" title="7、response细节"></a>7、response细节</h3><ul>
<li>getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOutputStream、PrintWriter对象。</li>
<li>getOutputStream和getWriter这两个方法互相排斥，调用其中的任何一个方法后，就不能再调用另一个方法。</li>
<li>servlet程序向ServletOutputStream和PrintWriter对象中写入的数据将被servlet引擎从response里面获取，servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。</li>
<li>servlet的service方法结束后，servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，servlet引擎将调用close方法关闭该输出对象。</li>
</ul>
<h2 id="三、HttpServletRequest-请求对象"><a href="#三、HttpServletRequest-请求对象" class="headerlink" title="三、HttpServletRequest 请求对象"></a>三、HttpServletRequest 请求对象</h2><blockquote>
<p>HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头的所有信息都封装在这个对象中，开发人员通过这个对象的方法，可以获得客户这些信息。</p>
</blockquote>
<h3 id="3-1常用方法"><a href="#3-1常用方法" class="headerlink" title="3.1常用方法"></a>3.1常用方法</h3><h4 id="3-1-1获得浏览器的信息"><a href="#3-1-1获得浏览器的信息" class="headerlink" title="3.1.1获得浏览器的信息"></a>3.1.1获得浏览器的信息</h4><blockquote>
<p>getRequestURL()方法返回客户端发出请求时完整的URL<br>getRequestURI()方法返回请求行中的资源名部分<br>getQueryString()方法返回请求行中的参数部分<br>getRemoteAddr()方法返回请求的客户机的完整IP地址<br>getRemoteHost()方法返回发出请求的客户机的完整主机名<br>getRemotePort()方法返回客户机所使用的网络端口号<br>getLocalAddr()方法返回Web服务器的IP地址<br>getLocalName()方法返回Web服务器的主机名<br>getMethod()得到客户机的请求方式</p>
</blockquote>
<h4 id="3-1-2获得浏览器的请求头"><a href="#3-1-2获得浏览器的请求头" class="headerlink" title="3.1.2获得浏览器的请求头"></a>3.1.2获得浏览器的请求头</h4><blockquote>
<p>getHeader(String name)方法<br>getHeaders(String name)方法<br>getHeaderNames方法</p>
</blockquote>
<p><strong>例1.获取请求头</strong></p>
<pre><code>import java.io.IOException;
import java.util.Enumeration;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class RequestDemo2 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //获取请求头，但是这个头可能出现多次，此时我们可以使用getHeaders方法
        String head = request.getHeader(&quot;Accept-Encoding&quot;);

            System.out.println(head);
        if(head.contains(&quot;gzip&quot;)){
            //看是否包含gzip头，若存在，再向其输出压缩数据
        }else{
            //不存在则输出没有压缩的数据
        }

        //当一个头出现多次
        Enumeration e = request.getHeaders(&quot;Accept-Encoding&quot;);
        while(e.hasMoreElements()){
            String value = (String) e.nextElement();
            System.out.println(value);
        }

        //获得所有的头和对应的值
           e = request.getHeaderNames();
        while(e.hasMoreElements()){
            String name = (String) e.nextElement();
            String value = request.getHeader(name);
            System.out.println(value);
        }
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre><h4 id="3-1-3获得浏览器请求参数（即浏览器提交的数据）"><a href="#3-1-3获得浏览器请求参数（即浏览器提交的数据）" class="headerlink" title="3.1.3获得浏览器请求参数（即浏览器提交的数据）"></a>3.1.3获得浏览器请求参数（即浏览器提交的数据）</h4><pre><code>import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.beanutils.BeanUtils;

import com.itheima.domain.User;
//获取请求参数
public class RequestDemo3 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        test8(request, response);
    }
    //终极解决方案：借助BeanUtil框架
    private void test8(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        User user = new User();
        System.out.println(&quot;封装前：&quot;+user);
        try {
            BeanUtils.populate(user, request.getParameterMap());
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(&quot;封装后：&quot;+user);
    }
    //getParameterMap获取参数:封装到JavaBean中
    private void test7(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //key:请求参数名 value:请求参数值数组
        Map&lt;String,String[]&gt; map = request.getParameterMap();
        User user = new User();
        System.out.println(&quot;封装前：&quot;+user);
        for(Map.Entry&lt;String, String[]&gt; me:map.entrySet()){
            String paramName = me.getKey();//参数名称
            String paramValues[] = me.getValue();//参数值
            try {
                PropertyDescriptor pd = new PropertyDescriptor(paramName, User.class);
                Method m = pd.getWriteMethod();//setter方法
                if(paramValues.length&gt;1){
                m.invoke(user, (Object)paramValues);//参考补充视频：反射main方法
                }else{
                    m.invoke(user, paramValues);
                }
            } catch (Exception e1) {
                e1.printStackTrace();
            }
        }
        System.out.println(&quot;封装后：&quot;+user);
    }
    //getParameterMap获取参数
    private void test6(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //key:请求参数名 value:请求参数值数组
        Map&lt;String,String[]&gt; map = request.getParameterMap();
        for(Map.Entry&lt;String, String[]&gt; me:map.entrySet()){
            System.out.println(me.getKey()+&quot;=&quot;+Arrays.asList(me.getValue()));
        }
    }

    //把请求参数的值封装到JavaBean中
    //约定优于编码：表单的输入域的name取值和JavaBean中的属性（getter和setter方法）保持一致
    private void test5(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {


        Enumeration&lt;String&gt; e = request.getParameterNames();//参数名
        User user = new User();
        System.out.println(&quot;封装前：&quot;+user);
        while(e.hasMoreElements()){
            String paramName = e.nextElement();//即是JavaBean中的属性名称
            String paramValue = request.getParameter(paramName);
            //setUsername(paramValue); setPassword(paramValue);
            //JavaBean的内省
        try {
            PropertyDescriptor pd = new PropertyDescriptor(paramName, User.class);
            Method m = pd.getWriteMethod();//setter方法
            m.invoke(user, paramValue);
            } catch (Exception e1) {
            e1.printStackTrace();
            }
        }
        System.out.println(&quot;封装后：&quot;+user);
    }    
//private void test4(HttpServletRequest request, HttpServletResponse response)
//            throws ServletException, IOException {
//        User user = new User();
//        System.out.println(&quot;封装前：&quot;+user);
//        String username = request.getParameter(&quot;username&quot;);
//        String password = request.getParameter(&quot;password&quot;);
//        String gender = request.getParameter(&quot;gender&quot;);
//        user.setUsername(username);
//        user.setPassword(password);
//        user.setGender(gender);
//        System.out.println(&quot;封装后：&quot;+user);
//    }    
    //以下内容只用简单的程序开发

    //获取所有的请求参数名和值
    private void test3(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        Enumeration&lt;String&gt; e = request.getParameterNames();//参数名
        while(e.hasMoreElements()){
            String paramName = e.nextElement();
            String values [] = request.getParameterValues(paramName);
            System.out.println(paramName+&quot;=&quot;+Arrays.asList(values));
        }
    }
    //获取重名请求参数的值
    private void test2(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String username = request.getParameter(&quot;username&quot;);//不区分get还是post的
        String passwords[] = request.getParameterValues(&quot;password&quot;);//获取重名的请求参数值
        System.out.println(username+&quot;:&quot;+Arrays.asList(passwords));
    }
    //获取单一的请求参数的值(用户所有的输入都是String)
    private void test1(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        String username = request.getParameter(&quot;username&quot;);//不区分get还是post的
        String password = request.getParameter(&quot;password&quot;);
        System.out.println(username+&quot;:&quot;+password);
    }
    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h4 id="3-1-4请求参数的中文乱码问题"><a href="#3-1-4请求参数的中文乱码问题" class="headerlink" title="3.1.4请求参数的中文乱码问题"></a>3.1.4请求参数的中文乱码问题</h4><pre><code>import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
//中文乱码问题
public class RequestDemo4 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        //post提交时乱码解决方式：设置服务器打开请求数据时用的码表，即request使用的码表
        //request.setCharacterEncoding(&quot;UTF-8&quot;);

        String username = request.getParameter(&quot;username&quot;);
        System.out.println(username);

        //get提交时乱码解决方式：先使用iso8859-1得到数据，然后再使用正确的编码转换过来
        byte[] source = username.getBytes(&quot;iso8859-1&quot;);
        username = new String(source, &quot;UTF-8&quot;);
        System.out.println(username);

    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>使用post方式提交表单数据时需要注意几点：<ul>
<li>在html中我们使用<meta name="content-type" content="text/html; charset=UTF-8">规定保存此文件的格式，我们可以选中文件右键àProperties可以在下面的Default处看到文件的编码格式，是和我们设置的编码一致的。</li>
<li>表单在提交的时候我们需要查看浏览器使用哪张码表打开此表单，如果使用GBK打开此表单，那么填写在此表单中提交的数据也将使用GBK编码，提交到服务器之后request.getParameter默认会使用iso8859-1码表将获得的数据转换成字符串，此时会出现乱码。我们可以使用request.setCharacterEncoding(“GBK”);将Request使用的码表换成GBK，这样和浏览器使用的编码就一致了。</li>
</ul>
</li>
</ul>
<ul>
<li>使用get方式提交表单数据时需要注意：<ul>
<li>当使用get方式提交表单数据时，设置Request编码是无效的，于是我们需要先使用iso8859码表得到乱码数据，然后再使用何时的码表将乱码转换成正确的文本数据。这是看视频教程中是这样解决的，但是在自己本地却不好使，当我的网页使用UTF-8打开时提交的数据能正确显示，但是如果使用GBK打开则不能正确显示。也就是网页使用UTF-8编码的数据提交才能正确显示，不是默认去查iso8859-1吗，这难道是tomcat的原因？？？？</li>
<li>还有个问题没有解决：就是当直接使用地址<a href="http://localhost:8080/ResAndReq/servlet/RequestDemo4?username=&#39;中国" target="_blank" rel="external">http://localhost:8080/ResAndReq/servlet/RequestDemo4?username=&#39;中国</a>‘ 访问服务器时，不需要设置任何编码就可以显示正确的文本。而且不管浏览器使用什么编码我们在地址栏中都可以看到正确的文本。URL其实对于汉字是直接使用的ASCII码，只是每个字的编码前加上一个%号？？？？</li>
<li>最后还可以更改服务器配置文件，在server.xml中的<connector>标签的最后加上一个属性：URIEncoding=”UTF-8”即可。这时什么都不需要设置了直接使用String username = request.getParameter(“username”);这种方式一般不适用.这里我们还有一种灵活的方式,在<connector>标签添加下面这个属性将useBodyEncodingForURI属性设置为true，那么如果我们request.setCharacterEncoding(“UTF-8”);之后连接器就使用什么编码。不管是什么方式，但是更改服务器的配置文件一般不推荐。</connector></connector></li>
</ul>
</li>
</ul>
<h3 id="请求重定向和请求转发的区别："><a href="#请求重定向和请求转发的区别：" class="headerlink" title="请求重定向和请求转发的区别："></a>请求重定向和请求转发的区别：</h3><p><img src="http://i.imgur.com/RwfiPOf.png" alt=""></p>
<p>（1）一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发。这里的两个servlet共享一个request和response对象。同时地址栏不会发生变化。<br>（2）一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源，称之为请求重定向。地址栏会发生变化。<br>（3）RequestDispatcher.forward方法只能将请求转发给同一个web应用中的组件（即多个servlet）；而HttpServletResponse.sendRedirect方法可以重定向到同一个站点上的其他应用程序中的资源（多个web应用），甚至是使用绝对URL重定向到其他站点的资源。<br>（4）调用HttpServletResponse.sendRedirect方法重定向的访问过程结束后，浏览器地址栏中显示的URL地址会发生变化，由初始的URL地址变成重定向的目标URL；调用RequestDispatcher.forward方法的请求转发过程结束后，浏览器地址栏保持初始的URL地址。<br>（5）HttpServletResponse.sendRedirect方法对浏览器的请求直接做出响应，响应的结果就是告诉浏览器去重新发出对另外一个URL的访问请求；RequestDispatcher.forward方法在服务器端内部将请求转发给另外一个资源（servlet），浏览器只知道发出了请求并得到了响应结果，并不知道在服务器内部发生了转发行为。<br>（6）RequestDispatcher.forward方法调用者与被调用者之间共享相同的request和response对象，它们属于同一个访问请求和响应过程；而HttpServletResponse.sendRedirect方法调用者与被调用者使用各自的request和response对象，它们属于两个独立的访问请求和响应过程。<br>（7）include方法<br>RequestDispatcher.include方法用于将RequestDispatcher对象封装的资源内容作为当前响应内容的一部分包含进来，从而实现可编程的服务器包含功能。被包含的servlet程序不能改变响应消息的状态码和响应头，如果它里面存在这样的语句，这些语句的执行结果将被忽略。</p>
<h3 id="转发和包含的小细节："><a href="#转发和包含的小细节：" class="headerlink" title="转发和包含的小细节："></a>转发和包含的小细节：</h3><p>转发：</p>
<ul>
<li>转发前后，源输出的任何响应正文无效</li>
<li>转发前会清空响应对象中的正文内容</li>
</ul>
<p>包含：</p>
<ul>
<li>只会包含目标的正文，头部信息包含前清空</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天写博客比以往都要早一点，从图书馆一回寝室就开始把今天学的凭记忆先记录下来，（其实主要还是怕贪玩又忘记写。）这是我写的第5篇博客，从上月22号坚持每天去图书馆刚好三周21天，是我戒烟的第25天。讲实话这些坚持真的让自己很难受，但当我看到这些统计出
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>Servlet学习笔记</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/13/Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/13/Servlet学习笔记/</id>
    <published>2017-03-13T12:43:20.000Z</published>
    <updated>2017-03-14T00:09:03.338Z</updated>
    
    <content type="html"><![CDATA[<p>这本是昨晚应该发的博客，但昨晚玩“阴阳师”去了，拖延了一天，今天重新整理复习把servlet的知识在罗列整理一下。把阴阳师卸了。。。</p>
<h2 id="1、Servlet简介"><a href="#1、Servlet简介" class="headerlink" title="1、Servlet简介"></a>1、Servlet简介</h2><ul>
<li>Servlet技术基于Request-Response编程模型 —- HTTP协议也是基于此模型（请求-响应模型） </li>
<li>Servlet中的方法<br><code>public void service(ServletRequest req,ServletResponse res)
throws ServletException,java.io.IOException</code><br><code>ServletRequest req:</code>代表着请求对象，该对象中有HTTP协议的请求部分的所有内容。它的实现类由服务器提供的，封装数据也是服务器来做的。<br><code>ServletResponse res：</code>代表着响应对象，该对象中由我们写数据（HTTP协议的响应部分）进去。它的实现类也是由服务器提供的。</li>
<li>执行过程<br><img src="http://i.imgur.com/7aMDTvN.png" alt=""></li>
</ul>
<h2 id="2、关于Servlet的一些类"><a href="#2、关于Servlet的一些类" class="headerlink" title="2、关于Servlet的一些类"></a>2、关于Servlet的一些类</h2><ul>
<li><p>Servlet接口</p>
<ul>
<li>定义了所有Servlet需要实现的方法</li>
<li>它定义了init destory service等方法</li>
<li>为了解决基于请求-响应模型的数据处理（没有涉及与HTTP协议相关的API）</li>
</ul>
</li>
<li><p>GenericServlet抽象类</p>
<ul>
<li>它是Servlet接口的实现类</li>
<li>它扩展了一些方法</li>
<li>也没有涉及与HTTP协议相关的API</li>
</ul>
</li>
<li><p>HttpServlet抽象类</p>
<ul>
<li>它继承于GenericServlet</li>
<li>它新增了一些与HTTP协议相关的方法，如doGet，doPost等等</li>
<li>HttpServlet在实现Servlet接口时，覆写了service方法，该方法内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，程序员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。<br><img src="http://i.imgur.com/5Dy9rMH.png" alt=""></li>
</ul>
</li>
<li>HttpServlet比Servlet更为强大，也可以保护Servlet接口不被轻易改动，所以程序员自己创建的Servlet都是继承于HttpServlet，从而间接地实现了Servlet接口。</li>
</ul>
<h2 id="3、Servlet生命周期"><a href="#3、Servlet生命周期" class="headerlink" title="3、Servlet生命周期"></a>3、Servlet生命周期</h2><ul>
<li>生命周期<ol>
<li>实例化：Servlet 容器创建 Servlet 的实例</li>
<li>初始化 ：该容器调用 init 方法</li>
<li>请求处理：如果请求 Servlet，则容器调用 service 方法</li>
<li>服务终止：销毁实例之前调用 destroy 方法</li>
</ol>
</li>
</ul>
<blockquote>
<p>其中，init方法只有在Servlet第一次被请求加载时被调用一次，当有客户再请求Servlet服务时，web服务器将启动一个新的线程，在该线程中，调用service方法响应客户的请求。<br><strong>一个Servlet可以配置多个url-pattern</strong></p>
<ul>
<li>URL 配置格式 三种：<ol>
<li>完全路径匹配 (以/开始 ) 例如：/hello/init </li>
<li>目录匹配 (以/开始) 例如：/<em> 、 /abc/</em><br><code>/</code> 代表网站根目录<br><code>/*</code>表示任何路径都可以匹配到这个Servlet<br><code>/abc/*</code>表示abc目录下的任何路径都可以匹配到这个Servlet</li>
<li>扩展名 (不能以/开始) 例如：<em>.do、 </em>.action</li>
</ol>
</li>
</ul>
</blockquote>
<ul>
<li>优先级：完全匹配&gt;目录匹配 &gt; 扩展名匹配 </li>
</ul>
<h2 id="4、ServletConfig获得初始化参数"><a href="#4、ServletConfig获得初始化参数" class="headerlink" title="4、ServletConfig获得初始化参数"></a>4、ServletConfig获得初始化参数</h2><ul>
<li>init方法中的ServletConfig对象<ul>
<li>getInitParameter（String)—— 通过name获得value</li>
<li>getInitParameterNames() —– 获得所有name </li>
</ul>
</li>
<li>结论：子类Servlet不需要覆写init(ServletConfig), 只需要通过GenericServlet中 getServletConfig()方法来获得ServletConfig对象。<blockquote>
<p>ServletConfig 配置初始化数据，只能在配置Servlet获得，其它Servlet无法获得 —– 每个Servlet程序都对应一个ServletConfig对象 </p>
</blockquote>
</li>
</ul>
<h2 id="5、web引用对象——ServletContext"><a href="#5、web引用对象——ServletContext" class="headerlink" title="5、web引用对象——ServletContext"></a>5、web引用对象——ServletContext</h2><ul>
<li>web容器在启动时，它会为每一个web应用创建一个ServletContext对象，这个对象代表当前web应用。</li>
<li>操作ServletContext必须通过ServletConfig获得对象。可以通过ServletConfig.getServletContext方法来获得ServletContext对象。</li>
<li><p>由于一个web应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。<br><strong>应用：</strong></p>
<ol>
<li>获得整个web应用初始化参数</li>
</ol>
<ul>
<li>和ServletConfig对象有什么不同？<br>如果用ServletConfig对象配置参数，只对配置的Servlet有效，如果通过ServletContext对象配置参数，所有的Servlet都可以访问。</li>
<li>配置方法，在web.xml中添加如下格式的代码：</li>
<li>获得 hobby 全局参数：<br>  // 通过ServletConfig 获得 ServletContext<pre><code>`ServletContext context = getServletConfig().getServletContext();`
// 上面写法可以简化一下
`ServletContext context = getServletContext();`
// 读取全局初始化参数
`System.out.println(context.getInitParameter(&quot;hobby&quot;));`
</code></pre></li>
</ul>
<ol>
<li>实现全局数据共享</li>
</ol>
<ul>
<li>预期效果：在ServletContext中 保存站点访问次数 ，每当一个用户访问站点，将访问次数+1。所有Servlet都可以获得该数据</li>
<li>在CountServlet 初始化过程中，向ServletContext 保存访问次数为0。<br>利用<code>ServletContext.setAttribute(&quot;KEY&quot;,&quot;VALUE&quot;);</code></li>
<li><p>代码实现(只显示init方法和doGet方法：</p>
<pre><code>public void init() throws ServletException {
    // 向ServletContext 保存访问次数 0
    // 获得ServletContext对象
    ServletContext context = getServletContext();
    // 保存数据 setAttribute
    context.setAttribute(&quot;visittimes&quot;, 0);

}

public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
    // 每次访问 执行 doGet --- 将visittimes 次数 +1

    // 1、从ServletContext中获得 访问次数
    ServletContext context = getServletContext();
    int times = (Integer) context.getAttribute(&quot;visittimes&quot;);

    // 2、访问次数 +1
    times++;

    // 3、将访问次数更新回去 ServletContext
    context.setAttribute(&quot;visittimes&quot;, times);

    System.out.println(&quot;网站被访问了一次！&quot;);
}
</code></pre></li>
</ul>
<ol>
<li>实现服务器端转发功能（少见，现在多用request、response）</li>
<li>读取web工程资源文件（必须使用绝对磁盘路径）<ul>
<li>使用java application 读取文件，读取当前工程下所有文件 —– 使用相对路径读取文件。</li>
<li>使用Servlet读取文件只能读取WebRoot下所有文件(注意Servlet是运行在tomcat中的） —- 必须使用绝对磁盘路径读取文件。</li>
<li>如何获得绝对磁盘路径？<ul>
<li>通过站点根目录绝对路径获得磁盘绝对路径 —— <code>getServletContext().getRealPath(&quot;/WEB-INF/XXX.txt&quot;)</code></li>
<li>因为 WEB-INF/classes 非常特殊 （存放.class文件目录），被类加载器加载，可以通过Class类对象读取该目录下文件（假设该Servlet名字叫做ReadFileServlet）。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="6、缺省Servlet"><a href="#6、缺省Servlet" class="headerlink" title="6、缺省Servlet"></a>6、缺省Servlet</h2><ul>
<li>如果某个Servlet的映射路径仅仅为一个正斜杠“/”，那么这个Servlet就成为当前web应用的缺省Servlet。</li>
<li>凡是在web.xml文件中找不到匹配的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理其他Servlet都不处理的访问请求。</li>
<li>在<tomcat的安装目录>\conf\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。</tomcat的安装目录></li>
<li>当访问tomcat服务器中的某个静态HTML和图片时，实际上是在访问这个缺省的Servlet。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本是昨晚应该发的博客，但昨晚玩“阴阳师”去了，拖延了一天，今天重新整理复习把servlet的知识在罗列整理一下。把阴阳师卸了。。。&lt;/p&gt;
&lt;h2 id=&quot;1、Servlet简介&quot;&gt;&lt;a href=&quot;#1、Servlet简介&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
    
      <category term="java web" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/11/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/11/HTTP协议/</id>
    <published>2017-03-11T10:37:39.000Z</published>
    <updated>2017-03-14T00:11:01.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、HTTP协议概述"><a href="#1、HTTP协议概述" class="headerlink" title="1、HTTP协议概述"></a>1、HTTP协议概述</h2><ul>
<li>HTTP是什么？超文本传输协议。<br>描述客户端和服务器端的数据标准，该协议由W3C维护和管理。<br>版本：</li>
<li>HTTP1.0:每次发出请求都需要建立网络连接</li>
<li>HTTP1.1:(主流)在一次网络连接上发出多次请求和得到多次响应。多了一些头。</li>
<li>明确：<br>浏览器遇到以下标记时，会自动发出请求<br><img src="http://i.imgur.com/dhiU7TO.jpg" alt=""></li>
</ul>
<h2 id="2、HTTP协议的组成"><a href="#2、HTTP协议的组成" class="headerlink" title="2、HTTP协议的组成"></a>2、HTTP协议的组成</h2><ul>
<li>2.1请求部分<br><img src="http://i.imgur.com/1YIseVf.jpg" alt=""></li>
<li>2.2响应部分<br><img src="http://i.imgur.com/77vLg7f.jpg" alt=""></li>
</ul>
<h2 id="3、请求部分详解"><a href="#3、请求部分详解" class="headerlink" title="3、请求部分详解"></a>3、请求部分详解</h2><ul>
<li><p>3.1请求行：<br><code>GET /app1/1.html HTTP/1.1</code><br>GET：请求方式。<br>常用的请求方式：GET(默认的)、POST、HEAD、OPTIONS等<br>GET：默认的<br><a href="http://localhost:8080/app1/1.html?username=abc&amp;password=123" target="_blank" rel="external">http://localhost:8080/app1/1.html?username=abc&amp;password=123</a><br>提交的数据显示出来了，相对不安全，协议的第一行有长度限制，<1kb. (有请求数据时推荐)post：可以通过<form="" method="”post”/"></1kb.></p>
<pre><code>      username=abc&amp;password=123
         提交的数据在请求正文中的，相对安全，长度没有限制。

/app1/1.html ：请求的资源地址。（URI）
       URL：协议+主机：端口+资源地址
              http://localhost:8080/app1/1.html
</code></pre><p>HTTP/1.1:客户端浏览器使用的协议的版本。</p>
</li>
</ul>
<ul>
<li>3.2请求消息头：（做好笔记，记住常用的头）<ul>
<li>作用：向服务器端传递附加信息（暗号指令）</li>
<li>Accept:告知服务器，客户端可以接受的数据类型（MIME类型）</li>
<li>文件系统：通过文件的扩展名区分不同的文件的。txt jpeg</li>
<li>MIME类型：大类型/小类型。  txt—&gt;text/plain   html—-&gt;text/html js—-&gt;text/javascript (具体对应关系：Tomcat\conf\web.xml) </li>
<li>Accept-Encoding：告知服务器，客户端可以接受的压缩编码。比如gzip</li>
<li>Accept-Language：告知服务器，客户端支持的语言</li>
<li>Referer：告知服务器，从哪个页面过来的。<ul>
<li>作用：统计广告的投放效果；防止盗链。</li>
</ul>
</li>
<li>Content-Type：告知服务器，请求正文的MIME类型<ul>
<li>默认类型：application/x-www-form-urlencoded(表单enctype属性的默认取值)</li>
<li>具体体现：username=abc&amp;password=123</li>
<li>其他类型：multipart/form-data(文件上传时用的)</li>
</ul>
</li>
<li>If-Modified-Since：告知服务器，当前访问的资源，缓存中的文件的最后修改时间。</li>
<li>User-Agent:告知服务器，浏览器的类型</li>
<li>Content-Length：请求正文的数据长度</li>
<li>Cookie：（<strong>*</strong>重要）会话管理有关</li>
</ul>
</li>
</ul>
<ul>
<li>3.3请求正文：<br>数据能提交到服务器，表单中的输入域必须有name属性值<br>POST请求是才有正文<br>username=abc&amp;password=123</li>
</ul>
<h2 id="4、响应部分详解"><a href="#4、响应部分详解" class="headerlink" title="4、响应部分详解"></a>4、响应部分详解</h2><ul>
<li><p>4.1响应行：<br><code>HTTP/1.1 200 OK</code></p>
<ul>
<li>HTTP/1.1 ：说明服务器端用的协议版本</li>
<li>200 ：响应状态码</li>
<li>1XX 2XX 3XX 4XX 5XX</li>
<li>2XX:处理完毕</li>
<li>4XX：请求有误</li>
<li>5XX：服务器有误</li>
<li>记住常用的响应码：<ul>
<li>200：一切正常</li>
<li>302/307:请求重定向</li>
<li>304：服务器上的资源没有发生改变</li>
<li>404：访问的地址不存在</li>
<li>500：服务器端错误</li>
<li>OK：响应吗描述</li>
</ul>
</li>
</ul>
</li>
<li><p>4.2响应消息头：</p>
<ul>
<li>作用：服务器端向客户端传递的附加信息（暗号指令）</li>
<li>Location：告知客户端，你去访问的地址。<br>和302/307实现请求重定向</li>
<li>Content-Encoding：告知客户端，响应正文使用的压缩编码（gzip）</li>
<li>Content-Length:告知客户端，响应正文的长度</li>
<li>Content-Type：告知客户端，响应文正的MIME类型。默认text/html</li>
<li>Refresh:告知客户端，定时刷新</li>
<li>Content-Disposition：告知客户端，用下载的方式打开<br>attachment;filename=23.jpg</li>
<li><p>Set-Cookie:(<strong>*</strong>)会话有关</p>
</li>
<li><p>Expires: -1 控制时间的</p>
</li>
<li>Cache-Control: no-cache (1.1) </li>
<li>Pragma: no-cache   (1.0)<br>三头一块用，用于告知浏览器，不要缓存。</li>
</ul>
</li>
<li><p>4.3响应正文：<br>浏览器解析的正文内容，右键查看源码一样的</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、HTTP协议概述&quot;&gt;&lt;a href=&quot;#1、HTTP协议概述&quot; class=&quot;headerlink&quot; title=&quot;1、HTTP协议概述&quot;&gt;&lt;/a&gt;1、HTTP协议概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTTP是什么？超文本传输协议。&lt;br&gt;描述客户端和服务器端的数
    
    </summary>
    
    
      <category term="http" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>利用JAXP进行SAX解析</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/11/%E5%88%A9%E7%94%A8JAXP%E8%BF%9B%E8%A1%8CSAX%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/11/利用JAXP进行SAX解析/</id>
    <published>2017-03-10T16:03:44.000Z</published>
    <updated>2017-03-12T10:36:03.332Z</updated>
    
    <content type="html"><![CDATA[<p>昨天学习了JAXP的DOM解析，今天有学了一下JAXP的SAX解析。相对于DOM解析，SAX解析是针对DOM解析需要读取整个xml才能构建DOM树。对于比较大的xml，容易导致内存溢出的缺点而诞生的。（不耗费很多的内存）；缺点是只适合查询。</p>
<ul>
<li>SAX：Simple API for XML。来自开源社区。</li>
<li>原理：<br><img src="http://i.imgur.com/MzzYlaV.png" alt=""><br>SAX解析是读到XML文档的每一部分，就立刻进行解析。调用对应处理器的响应方法。</li>
</ul>
<p><strong>//理解SAX解析的原理</strong></p>
<ul>
<li>// 得到创建解析器的工厂<br><code>SAXParserFactory spf = SAXParserFactory.newInstance();</code></li>
<li>// 得到解析器<br><code>SAXParser parser = spf.newSAXParser();</code></li>
<li>// 得到读取器<br><code>XMLReader reader = parser.getXMLReader();</code></li>
<li>// 给读取器注册内容处理器（ContentHandler）<br><code>reader.setContentHandler(new MyContentHandler());</code></li>
<li><p>// 解析文档<br><code>reader.parse(&quot;src/book.xml&quot;);</code></p>
</li>
<li><p>内容处理器</p>
<pre><code>class MyContentHandler implements ContentHandler {

    public void startDocument() throws SAXException {
        System.out.println(&quot;读到了文档的开始&quot;);
    }

    public void endDocument() throws SAXException {
        System.out.println(&quot;读到了文档的结束&quot;);
    }

    public void startElement(String uri, String localName, String qName,
    Attributes atts) throws SAXException {
        System.out.println(&quot;读到了元素的开始：&quot;+qName);
    }

    public void endElement(String uri, String localName, String qName)
            throws SAXException {
        System.out.println(&quot;读到了元素的结束：&quot;+qName);
    }

    public void characters(char[] ch, int start, int length)throws SAXException {
        System.out.println(&quot;读到了文本内容：&quot;+new String(ch,start,length));
    }

    public void setDocumentLocator(Locator locator) {

    }

    public void startPrefixMapping(String prefix, String uri)
        throws SAXException {

    }

    public void endPrefixMapping(String prefix) throws SAXException {

    }

    public void ignorableWhitespace(char[] ch, int start, int length)
        throws SAXException {

    }

    public void processingInstruction(String target, String data)
        throws SAXException {

    }

    public void skippedEntity(String name) throws SAXException {

    }
</code></pre><p>  }</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天学习了JAXP的DOM解析，今天有学了一下JAXP的SAX解析。相对于DOM解析，SAX解析是针对DOM解析需要读取整个xml才能构建DOM树。对于比较大的xml，容易导致内存溢出的缺点而诞生的。（不耗费很多的内存）；缺点是只适合查询。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SAX
    
    </summary>
    
    
      <category term="xml" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>利用JAXP开发包：DOM解析</title>
    <link href="https://github.com/lgrknight/lgrknight.github.io/2017/03/09/%E5%88%A9%E7%94%A8JAXP%E5%BC%80%E5%8F%91%E5%8C%85%EF%BC%9ADOM%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/lgrknight/lgrknight.github.io/2017/03/09/利用JAXP开发包：DOM解析/</id>
    <published>2017-03-09T14:31:47.000Z</published>
    <updated>2017-03-12T10:35:58.110Z</updated>
    
    <content type="html"><![CDATA[<p><strong>解析方式：（W3C</strong></p>
<ul>
<li>DOM：Document Object Model文档对象模型<ul>
<li>Node：节点<ul>
<li>Document：代表整棵树</li>
<li>Element:元素</li>
<li>Attr：属性（只有元素才有属性）</li>
<li>Text：文本</li>
</ul>
</li>
<li>有点：增删改查方便，简单</li>
<li>缺点：需要读取整个xml才能构建DOM树。对于比较大的xml，容易导致内存溢出。</li>
</ul>
</li>
<li>SAX：Simpl API for Xml</li>
</ul>
<p><strong>常用的XML解析器：</strong><br> <code>JAXP</code>、<code>Dom4J</code>、<code>JDom</code></p>
<p><strong>JAXP:</strong></p>
<ul>
<li>存在JDK中，SUN公司提供。</li>
<li>Java API for XML Processing=JAXP</li>
<li>由以下包：</li>
<li>org.w3c.dom:标准和规范（学习规范）</li>
<li>javax.xml:具体的实现</li>
</ul>
<p><strong>演示：JAXP对LocList进行DOM方式的解析</strong></p>
<ul>
<li><p>//得到解析器，通过解析器加载XML文件，得到代表这个xml的Document对象<br>  //具体做法</p>
<ul>
<li>//得到创建解析器的工厂：DocumentBuilderFactory<br><code>DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</code></li>
<li>//通过工厂得到解析器：DocumentBuilder<br><code>DocumentBuilder builder = factory.newDocumentBuilder();</code></li>
<li>//加载xml文件：得到了Document对象<br><code>Document document = builder.parse(&quot;src/LocList.xml&quot;);</code> //向上转型</li>
</ul>
</li>
<li><p>进行一些元素操作之后，会有把内存中的Document写入xml文件的需求<br>//具体做法<br><code>TransformerFactory tf = TransformerFactory.newInstance();</code><br><code>Transformer ts = tf.newTransformer();</code><br><code>ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;解析方式：（W3C&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM：Document Object Model文档对象模型&lt;ul&gt;
&lt;li&gt;Node：节点&lt;ul&gt;
&lt;li&gt;Document：代表整棵树&lt;/li&gt;
&lt;li&gt;Element:元素&lt;/li&gt;
&lt;
    
    </summary>
    
    
      <category term="xml" scheme="https://github.com/lgrknight/lgrknight.github.io/tags/xml/"/>
    
  </entry>
  
</feed>
